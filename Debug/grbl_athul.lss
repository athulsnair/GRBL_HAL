
grbl_athul.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000064  00800100  00007c98  00007d2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007c98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000005cc  00800164  00800164  00007d90  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00007d90  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007dc0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  00007e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008cea  00000000  00000000  000083b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002599  00000000  00000000  000110a2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000509d  00000000  00000000  0001363b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000012b0  00000000  00000000  000186d8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001a70  00000000  00000000  00019988  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000635b  00000000  00000000  0001b3f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000580  00000000  00000000  00021753  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 e5 04 	jmp	0x9ca	; 0x9ca <__ctors_end>
       4:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
       8:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
       c:	0c 94 5b 11 	jmp	0x22b6	; 0x22b6 <__vector_3>
      10:	0c 94 2c 36 	jmp	0x6c58	; 0x6c58 <__vector_4>
      14:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      18:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      1c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      20:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      24:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      28:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      2c:	0c 94 8d 2c 	jmp	0x591a	; 0x591a <__vector_11>
      30:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      34:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      38:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      3c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      40:	0c 94 70 2e 	jmp	0x5ce0	; 0x5ce0 <__vector_16>
      44:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      48:	0c 94 85 28 	jmp	0x510a	; 0x510a <__vector_18>
      4c:	0c 94 38 28 	jmp	0x5070	; 0x5070 <__vector_19>
      50:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      54:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      58:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      5c:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      60:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      64:	0c 94 02 05 	jmp	0xa04	; 0xa04 <__bad_interrupt>
      68:	11 07       	cpc	r17, r17
      6a:	11 07       	cpc	r17, r17
      6c:	11 07       	cpc	r17, r17
      6e:	11 07       	cpc	r17, r17
      70:	a6 06       	cpc	r10, r22
      72:	23 10       	cpse	r2, r3
      74:	23 10       	cpse	r2, r3
      76:	23 10       	cpse	r2, r3
      78:	23 10       	cpse	r2, r3
      7a:	23 10       	cpse	r2, r3
      7c:	9a 06       	cpc	r9, r26
      7e:	23 10       	cpse	r2, r3
      80:	23 10       	cpse	r2, r3
      82:	23 10       	cpse	r2, r3
      84:	23 10       	cpse	r2, r3
      86:	23 10       	cpse	r2, r3
      88:	23 10       	cpse	r2, r3
      8a:	64 07       	cpc	r22, r20
      8c:	64 07       	cpc	r22, r20
      8e:	64 07       	cpc	r22, r20
      90:	9c 07       	cpc	r25, r28
      92:	9c 07       	cpc	r25, r28
      94:	23 10       	cpse	r2, r3
      96:	23 10       	cpse	r2, r3
      98:	23 10       	cpse	r2, r3
      9a:	23 10       	cpse	r2, r3
      9c:	23 10       	cpse	r2, r3
      9e:	23 10       	cpse	r2, r3
      a0:	9a 06       	cpc	r9, r26
      a2:	23 10       	cpse	r2, r3
      a4:	9a 06       	cpc	r9, r26
      a6:	23 10       	cpse	r2, r3
      a8:	23 10       	cpse	r2, r3
      aa:	23 10       	cpse	r2, r3
      ac:	23 10       	cpse	r2, r3
      ae:	23 10       	cpse	r2, r3
      b0:	23 10       	cpse	r2, r3
      b2:	23 10       	cpse	r2, r3
      b4:	11 07       	cpc	r17, r17
      b6:	23 10       	cpse	r2, r3
      b8:	ca 07       	cpc	r28, r26
      ba:	23 10       	cpse	r2, r3
      bc:	23 10       	cpse	r2, r3
      be:	a7 07       	cpc	r26, r23
      c0:	23 10       	cpse	r2, r3
      c2:	23 10       	cpse	r2, r3
      c4:	23 10       	cpse	r2, r3
      c6:	23 10       	cpse	r2, r3
      c8:	23 10       	cpse	r2, r3
      ca:	a7 07       	cpc	r26, r23
      cc:	23 10       	cpse	r2, r3
      ce:	23 10       	cpse	r2, r3
      d0:	23 10       	cpse	r2, r3
      d2:	a6 06       	cpc	r10, r22
      d4:	bf 07       	cpc	r27, r31
      d6:	bf 07       	cpc	r27, r31
      d8:	bf 07       	cpc	r27, r31
      da:	bf 07       	cpc	r27, r31
      dc:	bf 07       	cpc	r27, r31
      de:	bf 07       	cpc	r27, r31
      e0:	23 10       	cpse	r2, r3
      e2:	c4 07       	cpc	r28, r20
      e4:	23 10       	cpse	r2, r3
      e6:	23 10       	cpse	r2, r3
      e8:	23 10       	cpse	r2, r3
      ea:	23 10       	cpse	r2, r3
      ec:	23 10       	cpse	r2, r3
      ee:	23 10       	cpse	r2, r3
      f0:	23 10       	cpse	r2, r3
      f2:	23 10       	cpse	r2, r3
      f4:	23 10       	cpse	r2, r3
      f6:	23 10       	cpse	r2, r3
      f8:	23 10       	cpse	r2, r3
      fa:	23 10       	cpse	r2, r3
      fc:	23 10       	cpse	r2, r3
      fe:	23 10       	cpse	r2, r3
     100:	23 10       	cpse	r2, r3
     102:	23 10       	cpse	r2, r3
     104:	23 10       	cpse	r2, r3
     106:	23 10       	cpse	r2, r3
     108:	17 07       	cpc	r17, r23
     10a:	23 10       	cpse	r2, r3
     10c:	23 10       	cpse	r2, r3
     10e:	23 10       	cpse	r2, r3
     110:	23 10       	cpse	r2, r3
     112:	23 10       	cpse	r2, r3
     114:	23 10       	cpse	r2, r3
     116:	23 10       	cpse	r2, r3
     118:	23 10       	cpse	r2, r3
     11a:	23 10       	cpse	r2, r3
     11c:	78 07       	cpc	r23, r24
     11e:	78 07       	cpc	r23, r24
     120:	9a 06       	cpc	r9, r26
     122:	91 07       	cpc	r25, r17
     124:	91 07       	cpc	r25, r17
     126:	f9 07       	cpc	r31, r25
     128:	f9 07       	cpc	r31, r25
     12a:	f9 07       	cpc	r31, r25
     12c:	09 08       	sbc	r0, r9
     12e:	09 08       	sbc	r0, r9
     130:	09 08       	sbc	r0, r9
     132:	41 10       	cpse	r4, r1
     134:	41 10       	cpse	r4, r1
     136:	1d 08       	sbc	r1, r13
     138:	1d 08       	sbc	r1, r13
     13a:	41 10       	cpse	r4, r1
     13c:	41 10       	cpse	r4, r1
     13e:	41 10       	cpse	r4, r1
     140:	41 10       	cpse	r4, r1
     142:	41 10       	cpse	r4, r1
     144:	41 10       	cpse	r4, r1
     146:	41 10       	cpse	r4, r1
     148:	41 10       	cpse	r4, r1
     14a:	41 10       	cpse	r4, r1
     14c:	41 10       	cpse	r4, r1
     14e:	41 10       	cpse	r4, r1
     150:	41 10       	cpse	r4, r1
     152:	41 10       	cpse	r4, r1
     154:	41 10       	cpse	r4, r1
     156:	41 10       	cpse	r4, r1
     158:	41 10       	cpse	r4, r1
     15a:	41 10       	cpse	r4, r1
     15c:	41 10       	cpse	r4, r1
     15e:	41 10       	cpse	r4, r1
     160:	41 10       	cpse	r4, r1
     162:	f9 07       	cpc	r31, r25
     164:	4e 08       	sbc	r4, r14
     166:	45 10       	cpse	r4, r5
     168:	45 10       	cpse	r4, r5
     16a:	58 08       	sbc	r5, r8
     16c:	65 08       	sbc	r6, r5
     16e:	72 08       	sbc	r7, r2
     170:	7f 08       	sbc	r7, r15
     172:	45 10       	cpse	r4, r5
     174:	83 08       	sbc	r8, r3
     176:	45 10       	cpse	r4, r5
     178:	91 08       	sbc	r9, r1
     17a:	45 10       	cpse	r4, r5
     17c:	9b 08       	sbc	r9, r11
     17e:	a5 08       	sbc	r10, r5
     180:	d6 08       	sbc	r13, r6
     182:	45 10       	cpse	r4, r5
     184:	45 10       	cpse	r4, r5
     186:	45 10       	cpse	r4, r5
     188:	af 08       	sbc	r10, r15
     18a:	bc 08       	sbc	r11, r12
     18c:	c9 08       	sbc	r12, r9
     18e:	d7 0e       	add	r13, r23
     190:	ec 0e       	add	r14, r28
     192:	0b 0f       	add	r16, r27
     194:	ec 0e       	add	r14, r28
     196:	11 0f       	add	r17, r17
     198:	28 0f       	add	r18, r24
     19a:	17 0f       	add	r17, r23
     19c:	21 0f       	add	r18, r17
     19e:	3d 0f       	add	r19, r29
     1a0:	47 0f       	add	r20, r23
     1a2:	53 0f       	add	r21, r19
     1a4:	75 0f       	add	r23, r21
     1a6:	96 0f       	add	r25, r22
     1a8:	a4 0f       	add	r26, r20
     1aa:	b3 0f       	add	r27, r19
     1ac:	c1 0f       	add	r28, r17
     1ae:	69 22       	and	r6, r25
     1b0:	6e 22       	and	r6, r30
     1b2:	73 22       	and	r7, r19
     1b4:	78 22       	and	r7, r24
     1b6:	7d 22       	and	r7, r29
     1b8:	82 22       	and	r8, r18
     1ba:	87 22       	and	r8, r23
     1bc:	8c 22       	and	r8, r28
     1be:	91 22       	and	r9, r17
     1c0:	96 22       	and	r9, r22
     1c2:	9b 22       	and	r9, r27
     1c4:	af 22       	and	r10, r31
     1c6:	af 22       	and	r10, r31
     1c8:	af 22       	and	r10, r31
     1ca:	af 22       	and	r10, r31
     1cc:	af 22       	and	r10, r31
     1ce:	af 22       	and	r10, r31
     1d0:	af 22       	and	r10, r31
     1d2:	af 22       	and	r10, r31
     1d4:	a5 22       	and	r10, r21
     1d6:	a0 22       	and	r10, r16
     1d8:	aa 22       	and	r10, r26
     1da:	02 23       	and	r16, r18
     1dc:	07 23       	and	r16, r23
     1de:	0c 23       	and	r16, r28
     1e0:	11 23       	and	r17, r17
     1e2:	16 23       	and	r17, r22
     1e4:	1b 23       	and	r17, r27
     1e6:	20 23       	and	r18, r16
     1e8:	25 23       	and	r18, r21
     1ea:	3d 27       	eor	r19, r29
     1ec:	51 27       	eor	r21, r17
     1ee:	56 27       	eor	r21, r22
     1f0:	5f 27       	eor	r21, r31
     1f2:	4c 27       	eor	r20, r28
     1f4:	5f 27       	eor	r21, r31
     1f6:	5f 27       	eor	r21, r31
     1f8:	5f 27       	eor	r21, r31
     1fa:	42 27       	eor	r20, r18
     1fc:	5f 27       	eor	r21, r31
     1fe:	5f 27       	eor	r21, r31
     200:	5f 27       	eor	r21, r31
     202:	5f 27       	eor	r21, r31
     204:	5f 27       	eor	r21, r31
     206:	5f 27       	eor	r21, r31
     208:	5f 27       	eor	r21, r31
     20a:	47 27       	eor	r20, r23
     20c:	5f 27       	eor	r21, r31
     20e:	5f 27       	eor	r21, r31
     210:	5f 27       	eor	r21, r31
     212:	5f 27       	eor	r21, r31
     214:	5f 27       	eor	r21, r31
     216:	5f 27       	eor	r21, r31
     218:	5f 27       	eor	r21, r31
     21a:	5f 27       	eor	r21, r31
     21c:	5f 27       	eor	r21, r31
     21e:	5f 27       	eor	r21, r31
     220:	5f 27       	eor	r21, r31
     222:	5f 27       	eor	r21, r31
     224:	5f 27       	eor	r21, r31
     226:	5f 27       	eor	r21, r31
     228:	5f 27       	eor	r21, r31
     22a:	5b 27       	eor	r21, r27
     22c:	5f 27       	eor	r21, r31
     22e:	5f 27       	eor	r21, r31
     230:	5f 27       	eor	r21, r31
     232:	5f 27       	eor	r21, r31
     234:	5f 27       	eor	r21, r31
     236:	5f 27       	eor	r21, r31
     238:	5f 27       	eor	r21, r31
     23a:	5f 27       	eor	r21, r31
     23c:	5f 27       	eor	r21, r31
     23e:	5f 27       	eor	r21, r31
     240:	5f 27       	eor	r21, r31
     242:	5f 27       	eor	r21, r31
     244:	5f 27       	eor	r21, r31
     246:	5f 27       	eor	r21, r31
     248:	5f 27       	eor	r21, r31
     24a:	5f 27       	eor	r21, r31
     24c:	5f 27       	eor	r21, r31
     24e:	5f 27       	eor	r21, r31
     250:	5f 27       	eor	r21, r31
     252:	5f 27       	eor	r21, r31
     254:	5f 27       	eor	r21, r31
     256:	5f 27       	eor	r21, r31
     258:	5f 27       	eor	r21, r31
     25a:	5f 27       	eor	r21, r31
     25c:	5f 27       	eor	r21, r31
     25e:	5f 27       	eor	r21, r31
     260:	5f 27       	eor	r21, r31
     262:	5f 27       	eor	r21, r31
     264:	5f 27       	eor	r21, r31
     266:	5f 27       	eor	r21, r31
     268:	5f 27       	eor	r21, r31
     26a:	42 27       	eor	r20, r18
     26c:	84 2a       	or	r8, r20
     26e:	8a 2a       	or	r8, r26
     270:	8d 2a       	or	r8, r29
     272:	92 2a       	or	r9, r18
     274:	97 2a       	or	r9, r23
     276:	a5 2a       	or	r10, r21
     278:	b3 2a       	or	r11, r19
     27a:	3e 2b       	or	r19, r30
     27c:	3e 2b       	or	r19, r30
     27e:	3e 2b       	or	r19, r30
     280:	c1 2a       	or	r12, r17
     282:	c4 2a       	or	r12, r20
     284:	cd 2a       	or	r12, r29
     286:	d6 2a       	or	r13, r22
     288:	3e 2b       	or	r19, r30
     28a:	3e 2b       	or	r19, r30
     28c:	3e 2b       	or	r19, r30
     28e:	3e 2b       	or	r19, r30
     290:	3e 2b       	or	r19, r30
     292:	3e 2b       	or	r19, r30
     294:	e4 2a       	or	r14, r20
     296:	f4 2a       	or	r15, r20
     298:	04 2b       	or	r16, r20
     29a:	12 2b       	or	r17, r18
     29c:	15 2b       	or	r17, r21
     29e:	1e 2b       	or	r17, r30
     2a0:	27 2b       	or	r18, r23
     2a2:	2e 2b       	or	r18, r30
     2a4:	08 4a       	sbci	r16, 0xA8	; 168
     2a6:	d7 3b       	cpi	r29, 0xB7	; 183
     2a8:	3b ce       	rjmp	.-906    	; 0xffffff20 <__eeprom_end+0xff7eff20>
     2aa:	01 6e       	ori	r16, 0xE1	; 225
     2ac:	84 bc       	out	0x24, r8	; 36
     2ae:	bf fd       	.word	0xfdbf	; ????
     2b0:	c1 2f       	mov	r28, r17
     2b2:	3d 6c       	ori	r19, 0xCD	; 205
     2b4:	74 31       	cpi	r23, 0x14	; 20
     2b6:	9a bd       	out	0x2a, r25	; 42
     2b8:	56 83       	std	Z+6, r21	; 0x06
     2ba:	3d da       	rcall	.-2950   	; 0xfffff736 <__eeprom_end+0xff7ef736>
     2bc:	3d 00       	.word	0x003d	; ????
     2be:	c7 7f       	andi	r28, 0xF7	; 247
     2c0:	11 be       	out	0x31, r1	; 49
     2c2:	d9 e4       	ldi	r29, 0x49	; 73
     2c4:	bb 4c       	sbci	r27, 0xCB	; 203
     2c6:	3e 91       	ld	r19, -X
     2c8:	6b aa       	std	Y+51, r6	; 0x33
     2ca:	aa be       	out	0x3a, r10	; 58
     2cc:	00 00       	nop
     2ce:	00 80       	ld	r0, Z
     2d0:	3f 05       	cpc	r19, r15
     2d2:	a8 4c       	sbci	r26, 0xC8	; 200
     2d4:	cd b2       	in	r12, 0x1d	; 29
     2d6:	d4 4e       	sbci	r29, 0xE4	; 228
     2d8:	b9 38       	cpi	r27, 0x89	; 137
     2da:	36 a9       	ldd	r19, Z+54	; 0x36
     2dc:	02 0c       	add	r0, r2
     2de:	50 b9       	out	0x00, r21	; 0
     2e0:	91 86       	std	Z+9, r9	; 0x09
     2e2:	88 08       	sbc	r8, r8
     2e4:	3c a6       	std	Y+44, r3	; 0x2c
     2e6:	aa aa       	std	Y+50, r10	; 0x32
     2e8:	2a be       	out	0x3a, r2	; 58
     2ea:	00 00       	nop
     2ec:	00 80       	ld	r0, Z
     2ee:	3f 00       	.word	0x003f	; ????

000002f0 <__trampolines_end>:
     2f0:	3e 0d       	add	r19, r14
     2f2:	0a 00       	.word	0x000a	; ????

000002f4 <__c.2959>:
     2f4:	2c 4c 69 6d 3a 00                                   ,Lim:.

000002fa <__c.2957>:
     2fa:	2c 52 58 3a 00                                      ,RX:.

000002ff <__c.2955>:
     2ff:	2c 42 75 66 3a 00                                   ,Buf:.

00000305 <__c.2950>:
     305:	2c 00                                               ,.

00000307 <__c.2948>:
     307:	2c 57 50 6f 73 3a 00                                ,WPos:.

0000030e <__c.2943>:
     30e:	2c 00                                               ,.

00000310 <__c.2941>:
     310:	2c 4d 50 6f 73 3a 00                                ,MPos:.

00000317 <__c.2939>:
     317:	3c 44 6f 6f 72 00                                   <Door.

0000031d <__c.2936>:
     31d:	3c 43 68 65 63 6b 00                                <Check.

00000324 <__c.2933>:
     324:	3c 41 6c 61 72 6d 00                                <Alarm.

0000032b <__c.2930>:
     32b:	3c 48 6f 6d 65 00                                   <Home.

00000331 <__c.2927>:
     331:	3c 48 6f 6c 64 00                                   <Hold.

00000337 <__c.2924>:
     337:	3c 52 75 6e 00                                      <Run.

0000033c <__c.2919>:
     33c:	3c 49 64 6c 65 00                                   <Idle.

00000342 <__c.2904>:
     342:	5d 0d 0a 00                                         ]...

00000346 <__c.2902>:
     346:	5b 30 2e 39 6a 2e 32 30 31 36 30 37 32 36 3a 00     [0.9j.20160726:.

00000356 <__c.2897>:
     356:	0d 0a 00                                            ...

00000359 <__c.2895>:
     359:	3d 00                                               =.

0000035b <__c.2893>:
     35b:	24 4e 00                                            $N.

0000035e <__c.2887>:
     35e:	5d 0d 0a 00                                         ]...

00000362 <__c.2885>:
     362:	20 53 00                                             S.

00000365 <__c.2883>:
     365:	20 46 00                                             F.

00000368 <__c.2881>:
     368:	20 54 00                                             T.

0000036b <__c.2879>:
     36b:	20 4d 38 00                                          M8.

0000036f <__c.2875>:
     36f:	20 4d 39 00                                          M9.

00000373 <__c.2872>:
     373:	20 4d 35 00                                          M5.

00000377 <__c.2869>:
     377:	20 4d 34 00                                          M4.

0000037b <__c.2865>:
     37b:	20 4d 33 00                                          M3.

0000037f <__c.2862>:
     37f:	20 4d 32 00                                          M2.

00000383 <__c.2859>:
     383:	20 4d 31 00                                          M1.

00000387 <__c.2855>:
     387:	20 4d 30 00                                          M0.

0000038b <__c.2852>:
     38b:	20 47 39 34 00                                       G94.

00000390 <__c.2850>:
     390:	20 47 39 33 00                                       G93.

00000395 <__c.2848>:
     395:	20 47 39 31 00                                       G91.

0000039a <__c.2846>:
     39a:	20 47 39 30 00                                       G90.

0000039f <__c.2844>:
     39f:	20 47 32 30 00                                       G20.

000003a4 <__c.2842>:
     3a4:	20 47 32 31 00                                       G21.

000003a9 <__c.2840>:
     3a9:	20 47 31 39 00                                       G19.

000003ae <__c.2837>:
     3ae:	20 47 31 38 00                                       G18.

000003b3 <__c.2833>:
     3b3:	20 47 31 37 00                                       G17.

000003b8 <__c.2830>:
     3b8:	20 47 00                                             G.

000003bb <__c.2828>:
     3bb:	47 33 38 2e 00                                      G38..

000003c0 <__c.2825>:
     3c0:	47 38 30 00                                         G80.

000003c4 <__c.2822>:
     3c4:	47 33 00                                            G3.

000003c7 <__c.2819>:
     3c7:	47 32 00                                            G2.

000003ca <__c.2816>:
     3ca:	47 31 00                                            G1.

000003cd <__c.2812>:
     3cd:	47 30 00                                            G0.

000003d0 <__c.2809>:
     3d0:	5b 00                                               [.

000003d2 <__c.2805>:
     3d2:	5d 0d 0a 00                                         ]...

000003d6 <__c.2803>:
     3d6:	5b 54 4c 4f 3a 00                                   [TLO:.

000003dc <__c.2798>:
     3dc:	5d 0d 0a 00                                         ]...

000003e0 <__c.2796>:
     3e0:	2c 00                                               ,.

000003e2 <__c.2794>:
     3e2:	5b 47 39 32 3a 00                                   [G92:.

000003e8 <__c.2786>:
     3e8:	5d 0d 0a 00                                         ]...

000003ec <__c.2784>:
     3ec:	2c 00                                               ,.

000003ee <__c.2782>:
     3ee:	3a 00                                               :.

000003f0 <__c.2779>:
     3f0:	33 30 00                                            30.

000003f3 <__c.2775>:
     3f3:	32 38 00                                            28.

000003f6 <__c.2772>:
     3f6:	5b 47 00                                            [G.

000003f9 <__c.2765>:
     3f9:	5d 0d 0a 00                                         ]...

000003fd <__c.2763>:
     3fd:	3a 00                                               :.

000003ff <__c.2758>:
     3ff:	2c 00                                               ,.

00000401 <__c.2756>:
     401:	5b 50 52 42 3a 00                                   [PRB:.

00000407 <__c.2744>:
     407:	29 0d 0a 00                                         )...

0000040b <__c.2742>:
     40b:	20 6d 61 78 20 74 72 61 76 65 6c 2c 20 6d 6d 00      max travel, mm.

0000041b <__c.2739>:
     41b:	20 61 63 63 65 6c 2c 20 6d 6d 2f 73 65 63 5e 32      accel, mm/sec^2
	...

0000042c <__c.2736>:
     42c:	20 6d 61 78 20 72 61 74 65 2c 20 6d 6d 2f 6d 69      max rate, mm/mi
     43c:	6e 00                                               n.

0000043e <__c.2732>:
     43e:	2c 20 73 74 65 70 2f 6d 6d 00                       , step/mm.

00000448 <__c.2729>:
     448:	7a 00                                               z.

0000044a <__c.2726>:
     44a:	79 00                                               y.

0000044c <__c.2722>:
     44c:	78 00                                               x.

0000044e <__c.2719>:
     44e:	20 28 00                                             (.

00000451 <__c.2712>:
     451:	3d 00                                               =.

00000453 <__c.2710>:
     453:	24 00                                               $.

00000455 <__c.2705>:
     455:	20 28 68 6f 6d 69 6e 67 20 70 75 6c 6c 2d 6f 66      (homing pull-of
     465:	66 2c 20 6d 6d 29 0d 0a 00                          f, mm)...

0000046e <__c.2703>:
     46e:	20 28 68 6f 6d 69 6e 67 20 64 65 62 6f 75 6e 63      (homing debounc
     47e:	65 2c 20 6d 73 65 63 29 0d 0a 24 32 37 3d 00        e, msec)..$27=.

0000048d <__c.2701>:
     48d:	20 28 68 6f 6d 69 6e 67 20 73 65 65 6b 2c 20 6d      (homing seek, m
     49d:	6d 2f 6d 69 6e 29 0d 0a 24 32 36 3d 00              m/min)..$26=.

000004aa <__c.2699>:
     4aa:	20 28 68 6f 6d 69 6e 67 20 66 65 65 64 2c 20 6d      (homing feed, m
     4ba:	6d 2f 6d 69 6e 29 0d 0a 24 32 35 3d 00              m/min)..$25=.

000004c7 <__c.2697>:
     4c7:	29 0d 0a 24 32 34 3d 00                             )..$24=.

000004cf <__c.2695>:
     4cf:	20 28 68 6f 6d 69 6e 67 20 64 69 72 20 69 6e 76      (homing dir inv
     4df:	65 72 74 20 6d 61 73 6b 3a 00                       ert mask:.

000004e9 <__c.2693>:
     4e9:	20 28 68 6f 6d 69 6e 67 20 63 79 63 6c 65 2c 20      (homing cycle, 
     4f9:	62 6f 6f 6c 29 0d 0a 24 32 33 3d 00                 bool)..$23=.

00000505 <__c.2691>:
     505:	20 28 68 61 72 64 20 6c 69 6d 69 74 73 2c 20 62      (hard limits, b
     515:	6f 6f 6c 29 0d 0a 24 32 32 3d 00                    ool)..$22=.

00000520 <__c.2689>:
     520:	20 28 73 6f 66 74 20 6c 69 6d 69 74 73 2c 20 62      (soft limits, b
     530:	6f 6f 6c 29 0d 0a 24 32 31 3d 00                    ool)..$21=.

0000053b <__c.2687>:
     53b:	20 28 72 65 70 6f 72 74 20 69 6e 63 68 65 73 2c      (report inches,
     54b:	20 62 6f 6f 6c 29 0d 0a 24 32 30 3d 00               bool)..$20=.

00000558 <__c.2685>:
     558:	20 28 61 72 63 20 74 6f 6c 65 72 61 6e 63 65 2c      (arc tolerance,
     568:	20 6d 6d 29 0d 0a 24 31 33 3d 00                     mm)..$13=.

00000573 <__c.2683>:
     573:	20 28 6a 75 6e 63 74 69 6f 6e 20 64 65 76 69 61      (junction devia
     583:	74 69 6f 6e 2c 20 6d 6d 29 0d 0a 24 31 32 3d 00     tion, mm)..$12=.

00000593 <__c.2681>:
     593:	29 0d 0a 24 31 31 3d 00                             )..$11=.

0000059b <__c.2679>:
     59b:	20 28 73 74 61 74 75 73 20 72 65 70 6f 72 74 20      (status report 
     5ab:	6d 61 73 6b 3a 00                                   mask:.

000005b1 <__c.2677>:
     5b1:	20 28 70 72 6f 62 65 20 70 69 6e 20 69 6e 76 65      (probe pin inve
     5c1:	72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 31 30 3d 00     rt, bool)..$10=.

000005d1 <__c.2675>:
     5d1:	20 28 6c 69 6d 69 74 20 70 69 6e 73 20 69 6e 76      (limit pins inv
     5e1:	65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 36 3d 00     ert, bool)..$6=.

000005f1 <__c.2673>:
     5f1:	20 28 73 74 65 70 20 65 6e 61 62 6c 65 20 69 6e      (step enable in
     601:	76 65 72 74 2c 20 62 6f 6f 6c 29 0d 0a 24 35 3d     vert, bool)..$5=
	...

00000612 <__c.2671>:
     612:	29 0d 0a 24 34 3d 00                                )..$4=.

00000619 <__c.2669>:
     619:	20 28 64 69 72 20 70 6f 72 74 20 69 6e 76 65 72      (dir port inver
     629:	74 20 6d 61 73 6b 3a 00                             t mask:.

00000631 <__c.2667>:
     631:	29 0d 0a 24 33 3d 00                                )..$3=.

00000638 <__c.2665>:
     638:	20 28 73 74 65 70 20 70 6f 72 74 20 69 6e 76 65      (step port inve
     648:	72 74 20 6d 61 73 6b 3a 00                          rt mask:.

00000651 <__c.2663>:
     651:	20 28 73 74 65 70 20 69 64 6c 65 20 64 65 6c 61      (step idle dela
     661:	79 2c 20 6d 73 65 63 29 0d 0a 24 32 3d 00           y, msec)..$2=.

0000066f <__c.2661>:
     66f:	20 28 73 74 65 70 20 70 75 6c 73 65 2c 20 75 73      (step pulse, us
     67f:	65 63 29 0d 0a 24 31 3d 00                          ec)..$1=.

00000688 <__c.2659>:
     688:	24 30 3d 00                                         $0=.

0000068c <__c.2655>:
     68c:	24 24 20 28 76 69 65 77 20 47 72 62 6c 20 73 65     $$ (view Grbl se
     69c:	74 74 69 6e 67 73 29 0d 0a 24 23 20 28 76 69 65     ttings)..$# (vie
     6ac:	77 20 23 20 70 61 72 61 6d 65 74 65 72 73 29 0d     w # parameters).
     6bc:	0a 24 47 20 28 76 69 65 77 20 70 61 72 73 65 72     .$G (view parser
     6cc:	20 73 74 61 74 65 29 0d 0a 24 49 20 28 76 69 65      state)..$I (vie
     6dc:	77 20 62 75 69 6c 64 20 69 6e 66 6f 29 0d 0a 24     w build info)..$
     6ec:	4e 20 28 76 69 65 77 20 73 74 61 72 74 75 70 20     N (view startup 
     6fc:	62 6c 6f 63 6b 73 29 0d 0a 24 78 3d 76 61 6c 75     blocks)..$x=valu
     70c:	65 20 28 73 61 76 65 20 47 72 62 6c 20 73 65 74     e (save Grbl set
     71c:	74 69 6e 67 29 0d 0a 24 4e 78 3d 6c 69 6e 65 20     ting)..$Nx=line 
     72c:	28 73 61 76 65 20 73 74 61 72 74 75 70 20 62 6c     (save startup bl
     73c:	6f 63 6b 29 0d 0a 24 43 20 28 63 68 65 63 6b 20     ock)..$C (check 
     74c:	67 63 6f 64 65 20 6d 6f 64 65 29 0d 0a 24 58 20     gcode mode)..$X 
     75c:	28 6b 69 6c 6c 20 61 6c 61 72 6d 20 6c 6f 63 6b     (kill alarm lock
     76c:	29 0d 0a 24 48 20 28 72 75 6e 20 68 6f 6d 69 6e     )..$H (run homin
     77c:	67 20 63 79 63 6c 65 29 0d 0a 7e 20 28 63 79 63     g cycle)..~ (cyc
     78c:	6c 65 20 73 74 61 72 74 29 0d 0a 21 20 28 66 65     le start)..! (fe
     79c:	65 64 20 68 6f 6c 64 29 0d 0a 3f 20 28 63 75 72     ed hold)..? (cur
     7ac:	72 65 6e 74 20 73 74 61 74 75 73 29 0d 0a 63 74     rent status)..ct
     7bc:	72 6c 2d 78 20 28 72 65 73 65 74 20 47 72 62 6c     rl-x (reset Grbl
     7cc:	29 0d 0a 00                                         )...

000007d0 <__c.2651>:
     7d0:	0d 0a 47 72 62 6c 20 30 2e 39 6a 20 5b 27 24 27     ..Grbl 0.9j ['$'
     7e0:	20 66 6f 72 20 68 65 6c 70 5d 0d 0a 00               for help]...

000007ed <__c.2647>:
     7ed:	5d 0d 0a 00                                         ]...

000007f1 <__c.2645>:
     7f1:	52 65 73 74 6f 72 69 6e 67 20 64 65 66 61 75 6c     Restoring defaul
     801:	74 73 00                                            ts.

00000804 <__c.2642>:
     804:	50 67 6d 20 45 6e 64 00                             Pgm End.

0000080c <__c.2639>:
     80c:	43 68 65 63 6b 20 44 6f 6f 72 00                    Check Door.

00000817 <__c.2636>:
     817:	44 69 73 61 62 6c 65 64 00                          Disabled.

00000820 <__c.2633>:
     820:	45 6e 61 62 6c 65 64 00                             Enabled.

00000828 <__c.2630>:
     828:	43 61 75 74 69 6f 6e 3a 20 55 6e 6c 6f 63 6b 65     Caution: Unlocke
     838:	64 00                                               d.

0000083a <__c.2627>:
     83a:	27 24 48 27 7c 27 24 58 27 20 74 6f 20 75 6e 6c     '$H'|'$X' to unl
     84a:	6f 63 6b 00                                         ock.

0000084e <__c.2623>:
     84e:	52 65 73 65 74 20 74 6f 20 63 6f 6e 74 69 6e 75     Reset to continu
     85e:	65 00                                               e.

00000860 <__c.2620>:
     860:	5b 00                                               [.

00000862 <__c.2615>:
     862:	0d 0a 00                                            ...

00000865 <__c.2613>:
     865:	48 6f 6d 69 6e 67 20 66 61 69 6c 00                 Homing fail.

00000871 <__c.2610>:
     871:	50 72 6f 62 65 20 66 61 69 6c 00                    Probe fail.

0000087c <__c.2607>:
     87c:	41 62 6f 72 74 20 64 75 72 69 6e 67 20 63 79 63     Abort during cyc
     88c:	6c 65 00                                            le.

0000088f <__c.2604>:
     88f:	53 6f 66 74 20 6c 69 6d 69 74 00                    Soft limit.

0000089a <__c.2600>:
     89a:	48 61 72 64 20 6c 69 6d 69 74 00                    Hard limit.

000008a5 <__c.2597>:
     8a5:	41 4c 41 52 4d 3a 20 00                             ALARM: .

000008ad <__c.2592>:
     8ad:	0d 0a 00                                            ...

000008b0 <__c.2590>:
     8b0:	49 6e 76 61 6c 69 64 20 67 63 6f 64 65 20 49 44     Invalid gcode ID
     8c0:	3a 00                                               :.

000008c2 <__c.2587>:
     8c2:	55 6e 64 65 66 69 6e 65 64 20 66 65 65 64 20 72     Undefined feed r
     8d2:	61 74 65 00                                         ate.

000008d6 <__c.2584>:
     8d6:	55 6e 73 75 70 70 6f 72 74 65 64 20 63 6f 6d 6d     Unsupported comm
     8e6:	61 6e 64 00                                         and.

000008ea <__c.2581>:
     8ea:	4d 6f 64 61 6c 20 67 72 6f 75 70 20 76 69 6f 6c     Modal group viol
     8fa:	61 74 69 6f 6e 00                                   ation.

00000900 <__c.2578>:
     900:	4c 69 6e 65 20 6f 76 65 72 66 6c 6f 77 00           Line overflow.

0000090e <__c.2575>:
     90e:	48 6f 6d 69 6e 67 20 6e 6f 74 20 65 6e 61 62 6c     Homing not enabl
     91e:	65 64 00                                            ed.

00000921 <__c.2572>:
     921:	41 6c 61 72 6d 20 6c 6f 63 6b 00                    Alarm lock.

0000092c <__c.2569>:
     92c:	4e 6f 74 20 69 64 6c 65 00                          Not idle.

00000935 <__c.2566>:
     935:	45 45 50 52 4f 4d 20 72 65 61 64 20 66 61 69 6c     EEPROM read fail
     945:	2e 20 55 73 69 6e 67 20 64 65 66 61 75 6c 74 73     . Using defaults
	...

00000956 <__c.2563>:
     956:	56 61 6c 75 65 20 3c 20 33 20 75 73 65 63 00        Value < 3 usec.

00000965 <__c.2560>:
     965:	53 65 74 74 69 6e 67 20 64 69 73 61 62 6c 65 64     Setting disabled
	...

00000976 <__c.2557>:
     976:	56 61 6c 75 65 20 3c 20 30 00                       Value < 0.

00000980 <__c.2554>:
     980:	49 6e 76 61 6c 69 64 20 73 74 61 74 65 6d 65 6e     Invalid statemen
     990:	74 00                                               t.

00000992 <__c.2551>:
     992:	42 61 64 20 6e 75 6d 62 65 72 20 66 6f 72 6d 61     Bad number forma
     9a2:	74 00                                               t.

000009a4 <__c.2547>:
     9a4:	45 78 70 65 63 74 65 64 20 63 6f 6d 6d 61 6e 64     Expected command
     9b4:	20 6c 65 74 74 65 72 00                              letter.

000009bc <__c.2544>:
     9bc:	65 72 72 6f 72 3a 20 00                             error: .

000009c4 <__c.2542>:
     9c4:	6f 6b 0d 0a 00 00                                   ok....

000009ca <__ctors_end>:
     9ca:	11 24       	eor	r1, r1
     9cc:	1f be       	out	0x3f, r1	; 63
     9ce:	cf ef       	ldi	r28, 0xFF	; 255
     9d0:	d8 e0       	ldi	r29, 0x08	; 8
     9d2:	de bf       	out	0x3e, r29	; 62
     9d4:	cd bf       	out	0x3d, r28	; 61

000009d6 <__do_copy_data>:
     9d6:	11 e0       	ldi	r17, 0x01	; 1
     9d8:	a0 e0       	ldi	r26, 0x00	; 0
     9da:	b1 e0       	ldi	r27, 0x01	; 1
     9dc:	e8 e9       	ldi	r30, 0x98	; 152
     9de:	fc e7       	ldi	r31, 0x7C	; 124
     9e0:	02 c0       	rjmp	.+4      	; 0x9e6 <__do_copy_data+0x10>
     9e2:	05 90       	lpm	r0, Z+
     9e4:	0d 92       	st	X+, r0
     9e6:	a4 36       	cpi	r26, 0x64	; 100
     9e8:	b1 07       	cpc	r27, r17
     9ea:	d9 f7       	brne	.-10     	; 0x9e2 <__do_copy_data+0xc>

000009ec <__do_clear_bss>:
     9ec:	27 e0       	ldi	r18, 0x07	; 7
     9ee:	a4 e6       	ldi	r26, 0x64	; 100
     9f0:	b1 e0       	ldi	r27, 0x01	; 1
     9f2:	01 c0       	rjmp	.+2      	; 0x9f6 <.do_clear_bss_start>

000009f4 <.do_clear_bss_loop>:
     9f4:	1d 92       	st	X+, r1

000009f6 <.do_clear_bss_start>:
     9f6:	a0 33       	cpi	r26, 0x30	; 48
     9f8:	b2 07       	cpc	r27, r18
     9fa:	e1 f7       	brne	.-8      	; 0x9f4 <.do_clear_bss_loop>
     9fc:	0e 94 f8 13 	call	0x27f0	; 0x27f0 <main>
     a00:	0c 94 4a 3e 	jmp	0x7c94	; 0x7c94 <_exit>

00000a04 <__bad_interrupt>:
     a04:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000a08 <coolant_stop>:
}


void coolant_stop()
{
  COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
     a08:	43 98       	cbi	0x08, 3	; 8
     a0a:	08 95       	ret

00000a0c <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT);
     a0c:	3b 9a       	sbi	0x07, 3	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
     a0e:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
     a12:	08 95       	ret

00000a14 <coolant_set_state>:
}


void coolant_set_state(uint8_t mode)
{
  if (mode == COOLANT_FLOOD_ENABLE) {
     a14:	82 30       	cpi	r24, 0x02	; 2
     a16:	11 f4       	brne	.+4      	; 0xa1c <coolant_set_state+0x8>
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
     a18:	43 9a       	sbi	0x08, 3	; 8
     a1a:	08 95       	ret
    } else if (mode == COOLANT_MIST_ENABLE) {
      COOLANT_MIST_PORT |= (1 << COOLANT_MIST_BIT);
  #endif

  } else {
    coolant_stop();
     a1c:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
     a20:	08 95       	ret

00000a22 <coolant_run>:
  }
}


void coolant_run(uint8_t mode)
{
     a22:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
     a24:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <sys+0x1>
     a28:	92 30       	cpi	r25, 0x02	; 2
     a2a:	31 f0       	breq	.+12     	; 0xa38 <coolant_run+0x16>
     a2c:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.  
     a2e:	0e 94 3b 22 	call	0x4476	; 0x4476 <protocol_buffer_synchronize>
  coolant_set_state(mode);
     a32:	8c 2f       	mov	r24, r28
     a34:	0e 94 0a 05 	call	0xa14	; 0xa14 <coolant_set_state>
}
     a38:	cf 91       	pop	r28
     a3a:	08 95       	ret

00000a3c <eeprom_get_char>:
     a3c:	f9 99       	sbic	0x1f, 1	; 31
     a3e:	fe cf       	rjmp	.-4      	; 0xa3c <eeprom_get_char>
     a40:	92 bd       	out	0x22, r25	; 34
     a42:	81 bd       	out	0x21, r24	; 33
     a44:	81 e0       	ldi	r24, 0x01	; 1
     a46:	8f bb       	out	0x1f, r24	; 31
     a48:	80 b5       	in	r24, 0x20	; 32
     a4a:	08 95       	ret

00000a4c <eeprom_put_char>:
     a4c:	f8 94       	cli
     a4e:	f9 99       	sbic	0x1f, 1	; 31
     a50:	fe cf       	rjmp	.-4      	; 0xa4e <eeprom_put_char+0x2>
     a52:	92 bd       	out	0x22, r25	; 34
     a54:	81 bd       	out	0x21, r24	; 33
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	8f bb       	out	0x1f, r24	; 31
     a5a:	80 b5       	in	r24, 0x20	; 32
     a5c:	86 27       	eor	r24, r22
     a5e:	96 2f       	mov	r25, r22
     a60:	98 23       	and	r25, r24
     a62:	59 f0       	breq	.+22     	; 0xa7a <eeprom_put_char+0x2e>
     a64:	6f 3f       	cpi	r22, 0xFF	; 255
     a66:	29 f0       	breq	.+10     	; 0xa72 <eeprom_put_char+0x26>
     a68:	60 bd       	out	0x20, r22	; 32
     a6a:	84 e0       	ldi	r24, 0x04	; 4
     a6c:	8f bb       	out	0x1f, r24	; 31
     a6e:	f9 9a       	sbi	0x1f, 1	; 31
     a70:	0a c0       	rjmp	.+20     	; 0xa86 <eeprom_put_char+0x3a>
     a72:	84 e1       	ldi	r24, 0x14	; 20
     a74:	8f bb       	out	0x1f, r24	; 31
     a76:	f9 9a       	sbi	0x1f, 1	; 31
     a78:	06 c0       	rjmp	.+12     	; 0xa86 <eeprom_put_char+0x3a>
     a7a:	88 23       	and	r24, r24
     a7c:	21 f0       	breq	.+8      	; 0xa86 <eeprom_put_char+0x3a>
     a7e:	60 bd       	out	0x20, r22	; 32
     a80:	84 e2       	ldi	r24, 0x24	; 36
     a82:	8f bb       	out	0x1f, r24	; 31
     a84:	f9 9a       	sbi	0x1f, 1	; 31
     a86:	78 94       	sei
     a88:	08 95       	ret

00000a8a <memcpy_to_eeprom_with_checksum>:
     a8a:	8f 92       	push	r8
     a8c:	9f 92       	push	r9
     a8e:	af 92       	push	r10
     a90:	bf 92       	push	r11
     a92:	cf 92       	push	r12
     a94:	df 92       	push	r13
     a96:	ef 92       	push	r14
     a98:	ff 92       	push	r15
     a9a:	0f 93       	push	r16
     a9c:	1f 93       	push	r17
     a9e:	cf 93       	push	r28
     aa0:	df 93       	push	r29
     aa2:	7c 01       	movw	r14, r24
     aa4:	8b 01       	movw	r16, r22
     aa6:	6a 01       	movw	r12, r20
     aa8:	41 15       	cp	r20, r1
     aaa:	51 05       	cpc	r21, r1
     aac:	09 f1       	breq	.+66     	; 0xaf0 <memcpy_to_eeprom_with_checksum+0x66>
     aae:	5a 01       	movw	r10, r20
     ab0:	c0 e0       	ldi	r28, 0x00	; 0
     ab2:	d1 e0       	ldi	r29, 0x01	; 1
     ab4:	01 c0       	rjmp	.+2      	; 0xab8 <memcpy_to_eeprom_with_checksum+0x2e>
     ab6:	c4 01       	movw	r24, r8
     ab8:	c1 11       	cpse	r28, r1
     aba:	08 c0       	rjmp	.+16     	; 0xacc <memcpy_to_eeprom_with_checksum+0x42>
     abc:	6c 2f       	mov	r22, r28
     abe:	cc 0f       	add	r28, r28
     ac0:	77 0b       	sbc	r23, r23
     ac2:	c7 2f       	mov	r28, r23
     ac4:	cc 1f       	adc	r28, r28
     ac6:	cc 27       	eor	r28, r28
     ac8:	cc 1f       	adc	r28, r28
     aca:	01 c0       	rjmp	.+2      	; 0xace <memcpy_to_eeprom_with_checksum+0x44>
     acc:	cd 2f       	mov	r28, r29
     ace:	f8 01       	movw	r30, r16
     ad0:	61 91       	ld	r22, Z+
     ad2:	8f 01       	movw	r16, r30
     ad4:	c6 0f       	add	r28, r22
     ad6:	4c 01       	movw	r8, r24
     ad8:	ff ef       	ldi	r31, 0xFF	; 255
     ada:	8f 1a       	sub	r8, r31
     adc:	9f 0a       	sbc	r9, r31
     ade:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
     ae2:	21 e0       	ldi	r18, 0x01	; 1
     ae4:	a2 1a       	sub	r10, r18
     ae6:	b1 08       	sbc	r11, r1
     ae8:	31 f7       	brne	.-52     	; 0xab6 <memcpy_to_eeprom_with_checksum+0x2c>
     aea:	ec 0c       	add	r14, r12
     aec:	fd 1c       	adc	r15, r13
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <memcpy_to_eeprom_with_checksum+0x68>
     af0:	c0 e0       	ldi	r28, 0x00	; 0
     af2:	6c 2f       	mov	r22, r28
     af4:	c7 01       	movw	r24, r14
     af6:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	ef 90       	pop	r14
     b06:	df 90       	pop	r13
     b08:	cf 90       	pop	r12
     b0a:	bf 90       	pop	r11
     b0c:	af 90       	pop	r10
     b0e:	9f 90       	pop	r9
     b10:	8f 90       	pop	r8
     b12:	08 95       	ret

00000b14 <memcpy_from_eeprom_with_checksum>:
     b14:	8f 92       	push	r8
     b16:	9f 92       	push	r9
     b18:	af 92       	push	r10
     b1a:	bf 92       	push	r11
     b1c:	cf 92       	push	r12
     b1e:	df 92       	push	r13
     b20:	ef 92       	push	r14
     b22:	ff 92       	push	r15
     b24:	0f 93       	push	r16
     b26:	1f 93       	push	r17
     b28:	cf 93       	push	r28
     b2a:	df 93       	push	r29
     b2c:	7b 01       	movw	r14, r22
     b2e:	6a 01       	movw	r12, r20
     b30:	41 15       	cp	r20, r1
     b32:	51 05       	cpc	r21, r1
     b34:	11 f1       	breq	.+68     	; 0xb7a <memcpy_from_eeprom_with_checksum+0x66>
     b36:	c8 2f       	mov	r28, r24
     b38:	d9 2f       	mov	r29, r25
     b3a:	5a 01       	movw	r10, r20
     b3c:	cb 01       	movw	r24, r22
     b3e:	91 2c       	mov	r9, r1
     b40:	88 24       	eor	r8, r8
     b42:	83 94       	inc	r8
     b44:	8c 01       	movw	r16, r24
     b46:	0f 5f       	subi	r16, 0xFF	; 255
     b48:	1f 4f       	sbci	r17, 0xFF	; 255
     b4a:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
     b4e:	91 10       	cpse	r9, r1
     b50:	08 c0       	rjmp	.+16     	; 0xb62 <memcpy_from_eeprom_with_checksum+0x4e>
     b52:	29 2d       	mov	r18, r9
     b54:	99 0c       	add	r9, r9
     b56:	33 0b       	sbc	r19, r19
     b58:	23 2f       	mov	r18, r19
     b5a:	22 1f       	adc	r18, r18
     b5c:	22 27       	eor	r18, r18
     b5e:	22 1f       	adc	r18, r18
     b60:	01 c0       	rjmp	.+2      	; 0xb64 <memcpy_from_eeprom_with_checksum+0x50>
     b62:	28 2d       	mov	r18, r8
     b64:	98 2e       	mov	r9, r24
     b66:	92 0e       	add	r9, r18
     b68:	89 93       	st	Y+, r24
     b6a:	81 e0       	ldi	r24, 0x01	; 1
     b6c:	a8 1a       	sub	r10, r24
     b6e:	b1 08       	sbc	r11, r1
     b70:	c8 01       	movw	r24, r16
     b72:	41 f7       	brne	.-48     	; 0xb44 <memcpy_from_eeprom_with_checksum+0x30>
     b74:	ec 0c       	add	r14, r12
     b76:	fd 1c       	adc	r15, r13
     b78:	01 c0       	rjmp	.+2      	; 0xb7c <memcpy_from_eeprom_with_checksum+0x68>
     b7a:	91 2c       	mov	r9, r1
     b7c:	c7 01       	movw	r24, r14
     b7e:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
     b82:	21 e0       	ldi	r18, 0x01	; 1
     b84:	30 e0       	ldi	r19, 0x00	; 0
     b86:	89 15       	cp	r24, r9
     b88:	11 f0       	breq	.+4      	; 0xb8e <memcpy_from_eeprom_with_checksum+0x7a>
     b8a:	20 e0       	ldi	r18, 0x00	; 0
     b8c:	30 e0       	ldi	r19, 0x00	; 0
     b8e:	c9 01       	movw	r24, r18
     b90:	df 91       	pop	r29
     b92:	cf 91       	pop	r28
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	df 90       	pop	r13
     b9e:	cf 90       	pop	r12
     ba0:	bf 90       	pop	r11
     ba2:	af 90       	pop	r10
     ba4:	9f 90       	pop	r9
     ba6:	8f 90       	pop	r8
     ba8:	08 95       	ret

00000baa <gc_check_same_position>:
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
}


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	1f 93       	push	r17
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	7c 01       	movw	r14, r24
     bb8:	06 2f       	mov	r16, r22
     bba:	17 2f       	mov	r17, r23
     bbc:	ec 01       	movw	r28, r24
     bbe:	2c 96       	adiw	r28, 0x0c	; 12
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     bc0:	f7 01       	movw	r30, r14
     bc2:	61 91       	ld	r22, Z+
     bc4:	71 91       	ld	r23, Z+
     bc6:	81 91       	ld	r24, Z+
     bc8:	91 91       	ld	r25, Z+
     bca:	7f 01       	movw	r14, r30
     bcc:	f8 01       	movw	r30, r16
     bce:	21 91       	ld	r18, Z+
     bd0:	31 91       	ld	r19, Z+
     bd2:	41 91       	ld	r20, Z+
     bd4:	51 91       	ld	r21, Z+
     bd6:	8f 01       	movw	r16, r30
     bd8:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
     bdc:	81 11       	cpse	r24, r1
     bde:	05 c0       	rjmp	.+10     	; 0xbea <gc_check_same_position+0x40>


static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
     be0:	ec 16       	cp	r14, r28
     be2:	fd 06       	cpc	r15, r29
     be4:	69 f7       	brne	.-38     	; 0xbc0 <gc_check_same_position+0x16>
    if (pos_a[idx] != pos_b[idx]) { return(false); }
  }
  return(true);
     be6:	81 e0       	ldi	r24, 0x01	; 1
     be8:	01 c0       	rjmp	.+2      	; 0xbec <gc_check_same_position+0x42>

static uint8_t gc_check_same_position(float *pos_a, float *pos_b) 
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    if (pos_a[idx] != pos_b[idx]) { return(false); }
     bea:	80 e0       	ldi	r24, 0x00	; 0
  }
  return(true);
}
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	1f 91       	pop	r17
     bf2:	0f 91       	pop	r16
     bf4:	ff 90       	pop	r15
     bf6:	ef 90       	pop	r14
     bf8:	08 95       	ret

00000bfa <gc_init>:
#define FAIL(status) return(status);


void gc_init() 
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     bfa:	8f e3       	ldi	r24, 0x3F	; 63
     bfc:	ec e8       	ldi	r30, 0x8C	; 140
     bfe:	f5 e0       	ldi	r31, 0x05	; 5
     c00:	df 01       	movw	r26, r30
     c02:	1d 92       	st	X+, r1
     c04:	8a 95       	dec	r24
     c06:	e9 f7       	brne	.-6      	; 0xc02 <gc_init+0x8>
  
  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { 
     c08:	6f ea       	ldi	r22, 0xAF	; 175
     c0a:	75 e0       	ldi	r23, 0x05	; 5
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
     c12:	81 11       	cpse	r24, r1
     c14:	03 c0       	rjmp	.+6      	; 0xc1c <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL); 
     c16:	87 e0       	ldi	r24, 0x07	; 7
     c18:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
     c1c:	08 95       	ret

00000c1e <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position() 
{
  system_convert_array_steps_to_mpos(gc_state.position,sys.position);
     c1e:	68 e0       	ldi	r22, 0x08	; 8
     c20:	76 e0       	ldi	r23, 0x06	; 6
     c22:	83 ea       	ldi	r24, 0xA3	; 163
     c24:	95 e0       	ldi	r25, 0x05	; 5
     c26:	0e 94 97 38 	call	0x712e	; 0x712e <system_convert_array_steps_to_mpos>
     c2a:	08 95       	ret

00000c2c <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and 
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine 
// coordinates, respectively.
uint8_t gc_execute_line(char *line) 
{
     c2c:	2f 92       	push	r2
     c2e:	3f 92       	push	r3
     c30:	4f 92       	push	r4
     c32:	5f 92       	push	r5
     c34:	6f 92       	push	r6
     c36:	7f 92       	push	r7
     c38:	8f 92       	push	r8
     c3a:	9f 92       	push	r9
     c3c:	af 92       	push	r10
     c3e:	bf 92       	push	r11
     c40:	cf 92       	push	r12
     c42:	df 92       	push	r13
     c44:	ef 92       	push	r14
     c46:	ff 92       	push	r15
     c48:	0f 93       	push	r16
     c4a:	1f 93       	push	r17
     c4c:	cf 93       	push	r28
     c4e:	df 93       	push	r29
     c50:	cd b7       	in	r28, 0x3d	; 61
     c52:	de b7       	in	r29, 0x3e	; 62
     c54:	ab 97       	sbiw	r28, 0x2b	; 43
     c56:	0f b6       	in	r0, 0x3f	; 63
     c58:	f8 94       	cli
     c5a:	de bf       	out	0x3e, r29	; 62
     c5c:	0f be       	out	0x3f, r0	; 63
     c5e:	cd bf       	out	0x3d, r28	; 61
     c60:	7c 01       	movw	r14, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     c62:	89 e3       	ldi	r24, 0x39	; 57
     c64:	eb ec       	ldi	r30, 0xCB	; 203
     c66:	f5 e0       	ldi	r31, 0x05	; 5
     c68:	df 01       	movw	r26, r30
     c6a:	1d 92       	st	X+, r1
     c6c:	8a 95       	dec	r24
     c6e:	e9 f7       	brne	.-6      	; 0xc6a <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     c70:	8a e0       	ldi	r24, 0x0A	; 10
     c72:	ec e8       	ldi	r30, 0x8C	; 140
     c74:	f5 e0       	ldi	r31, 0x05	; 5
     c76:	ac ec       	ldi	r26, 0xCC	; 204
     c78:	b5 e0       	ldi	r27, 0x05	; 5
     c7a:	01 90       	ld	r0, Z+
     c7c:	0d 92       	st	X+, r0
     c7e:	8a 95       	dec	r24
     c80:	e1 f7       	brne	.-8      	; 0xc7a <gc_execute_line+0x4e>
     a number, which can either be a 'G'/'M' command or sets/assigns a command value. Also, 
     perform initial error-checks for command word modal group violations, for any repeated
     words, and for negative values set for the value words F, N, P, T, and S. */
     
  uint8_t word_bit; // Bit-value for assigning tracking variables
  uint8_t char_counter = 0;  
     c82:	19 8e       	std	Y+25, r1	; 0x19
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Value words. 
     c84:	61 2c       	mov	r6, r1
     c86:	71 2c       	mov	r7, r1
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 

  // Initialize command and value words variables. Tracks words contained in this block.
  uint16_t command_words = 0; // G and M command words. Also used for modal group violations.
     c88:	c1 2c       	mov	r12, r1
     c8a:	d1 2c       	mov	r13, r1
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
  uint8_t ijk_words = 0; // IJK tracking 
     c8c:	1b a2       	std	Y+35, r1	; 0x23
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
  float coordinate_data[N_AXIS]; // Multi-use variable to store coordinate data for execution
  float parameter_data[N_AXIS]; // Multi-use variable to store parameter data for execution
  
  // Initialize bitflag tracking variables for axis indices compatible operations.
  uint8_t axis_words = 0; // XYZ tracking
     c8e:	1e 8e       	std	Y+30, r1	; 0x1e
     values struct, word tracking variables, and a non-modal commands tracker for the new 
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
     c90:	1a a2       	std	Y+34, r1	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     c92:	aa 24       	eor	r10, r10
     c94:	a3 94       	inc	r10
     c96:	b1 2c       	mov	r11, r1
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     c98:	0f 2e       	mov	r0, r31
     c9a:	f1 e6       	ldi	r31, 0x61	; 97
     c9c:	8f 2e       	mov	r8, r31
     c9e:	f3 e0       	ldi	r31, 0x03	; 3
     ca0:	9f 2e       	mov	r9, r31
     ca2:	f0 2d       	mov	r31, r0
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
     ca4:	a5 c2       	rjmp	.+1354   	; 0x11f0 <gc_execute_line+0x5c4>
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     ca6:	9f eb       	ldi	r25, 0xBF	; 191
     ca8:	91 0f       	add	r25, r17
     caa:	9a 31       	cpi	r25, 0x1A	; 26
     cac:	10 f0       	brcs	.+4      	; 0xcb2 <gc_execute_line+0x86>
     cae:	0c 94 1f 10 	jmp	0x203e	; 0x203e <gc_execute_line+0x1412>
    char_counter++;
     cb2:	8f 5f       	subi	r24, 0xFF	; 255
     cb4:	89 8f       	std	Y+25, r24	; 0x19
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     cb6:	ae 01       	movw	r20, r28
     cb8:	46 5e       	subi	r20, 0xE6	; 230
     cba:	5f 4f       	sbci	r21, 0xFF	; 255
     cbc:	be 01       	movw	r22, r28
     cbe:	67 5e       	subi	r22, 0xE7	; 231
     cc0:	7f 4f       	sbci	r23, 0xFF	; 255
     cc2:	c7 01       	movw	r24, r14
     cc4:	0e 94 76 18 	call	0x30ec	; 0x30ec <read_float>
     cc8:	88 23       	and	r24, r24
     cca:	11 f4       	brne	.+4      	; 0xcd0 <gc_execute_line+0xa4>
     ccc:	0c 94 21 10 	jmp	0x2042	; 0x2042 <gc_execute_line+0x1416>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant, 
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later. 
    int_value = trunc(value);
     cd0:	2a 8c       	ldd	r2, Y+26	; 0x1a
     cd2:	3b 8c       	ldd	r3, Y+27	; 0x1b
     cd4:	4c 8c       	ldd	r4, Y+28	; 0x1c
     cd6:	5d 8c       	ldd	r5, Y+29	; 0x1d
     cd8:	c2 01       	movw	r24, r4
     cda:	b1 01       	movw	r22, r2
     cdc:	0e 94 f0 3d 	call	0x7be0	; 0x7be0 <trunc>
     ce0:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
     ce4:	06 2f       	mov	r16, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     ce6:	70 e0       	ldi	r23, 0x00	; 0
     ce8:	80 e0       	ldi	r24, 0x00	; 0
     cea:	90 e0       	ldi	r25, 0x00	; 0
     cec:	0e 94 5f 3b 	call	0x76be	; 0x76be <__floatsisf>
     cf0:	9b 01       	movw	r18, r22
     cf2:	ac 01       	movw	r20, r24
     cf4:	c2 01       	movw	r24, r4
     cf6:	b1 01       	movw	r22, r2
     cf8:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
     cfc:	20 e0       	ldi	r18, 0x00	; 0
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	48 ec       	ldi	r20, 0xC8	; 200
     d02:	52 e4       	ldi	r21, 0x42	; 66
     d04:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
     d08:	0e 94 7a 3d 	call	0x7af4	; 0x7af4 <round>
     d0c:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
        // NOTE: Rounding must be used to catch small floating point errors. 

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     d10:	17 34       	cpi	r17, 0x47	; 71
     d12:	21 f0       	breq	.+8      	; 0xd1c <gc_execute_line+0xf0>
     d14:	1d 34       	cpi	r17, 0x4D	; 77
     d16:	09 f4       	brne	.+2      	; 0xd1a <gc_execute_line+0xee>
     d18:	5c c1       	rjmp	.+696    	; 0xfd2 <gc_execute_line+0x3a6>
     d1a:	b2 c1       	rjmp	.+868    	; 0x1080 <gc_execute_line+0x454>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */
         
      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     d1c:	80 2f       	mov	r24, r16
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	8f 35       	cpi	r24, 0x5F	; 95
     d22:	91 05       	cpc	r25, r1
     d24:	10 f0       	brcs	.+4      	; 0xd2a <gc_execute_line+0xfe>
     d26:	0c 94 23 10 	jmp	0x2046	; 0x2046 <gc_execute_line+0x141a>
     d2a:	fc 01       	movw	r30, r24
     d2c:	ec 5c       	subi	r30, 0xCC	; 204
     d2e:	ff 4f       	sbci	r31, 0xFF	; 255
     d30:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     d34:	61 15       	cp	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	11 f0       	breq	.+4      	; 0xd3e <gc_execute_line+0x112>
     d3a:	0c 94 a4 10 	jmp	0x2148	; 0x2148 <gc_execute_line+0x151c>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     d3e:	ba a1       	ldd	r27, Y+34	; 0x22
     d40:	bb 23       	and	r27, r27
     d42:	11 f4       	brne	.+4      	; 0xd48 <gc_execute_line+0x11c>
     d44:	0c 94 87 10 	jmp	0x210e	; 0x210e <gc_execute_line+0x14e2>
     d48:	0c 94 25 10 	jmp	0x204a	; 0x204a <gc_execute_line+0x141e>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
     d4c:	0c 31       	cpi	r16, 0x1C	; 28
     d4e:	09 f1       	breq	.+66     	; 0xd92 <gc_execute_line+0x166>
     d50:	28 f4       	brcc	.+10     	; 0xd5c <gc_execute_line+0x130>
     d52:	04 30       	cpi	r16, 0x04	; 4
     d54:	71 f0       	breq	.+28     	; 0xd72 <gc_execute_line+0x146>
     d56:	0a 30       	cpi	r16, 0x0A	; 10
     d58:	a1 f0       	breq	.+40     	; 0xd82 <gc_execute_line+0x156>
     d5a:	1e c1       	rjmp	.+572    	; 0xf98 <gc_execute_line+0x36c>
     d5c:	05 33       	cpi	r16, 0x35	; 53
     d5e:	09 f4       	brne	.+2      	; 0xd62 <gc_execute_line+0x136>
     d60:	44 c0       	rjmp	.+136    	; 0xdea <gc_execute_line+0x1be>
     d62:	0c 35       	cpi	r16, 0x5C	; 92
     d64:	09 f4       	brne	.+2      	; 0xd68 <gc_execute_line+0x13c>
     d66:	49 c0       	rjmp	.+146    	; 0xdfa <gc_execute_line+0x1ce>
     d68:	0e 31       	cpi	r16, 0x1E	; 30
     d6a:	49 f1       	breq	.+82     	; 0xdbe <gc_execute_line+0x192>
     d6c:	15 c1       	rjmp	.+554    	; 0xf98 <gc_execute_line+0x36c>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d6e:	e1 e0       	ldi	r30, 0x01	; 1
     d70:	ea a3       	std	Y+34, r30	; 0x22
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d72:	e1 e0       	ldi	r30, 0x01	; 1
     d74:	ab ec       	ldi	r26, 0xCB	; 203
     d76:	b5 e0       	ldi	r27, 0x05	; 5
     d78:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d7a:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
     d7c:	12 c1       	rjmp	.+548    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d7e:	f1 e0       	ldi	r31, 0x01	; 1
     d80:	fa a3       	std	Y+34, r31	; 0x22
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d82:	82 e0       	ldi	r24, 0x02	; 2
     d84:	ab ec       	ldi	r26, 0xCB	; 203
     d86:	b5 e0       	ldi	r27, 0x05	; 5
     d88:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     d8a:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
     d8c:	0a c1       	rjmp	.+532    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     d8e:	b1 e0       	ldi	r27, 0x01	; 1
     d90:	ba a3       	std	Y+34, r27	; 0x22
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
     d92:	61 15       	cp	r22, r1
     d94:	71 05       	cpc	r23, r1
     d96:	29 f0       	breq	.+10     	; 0xda2 <gc_execute_line+0x176>
     d98:	6a 30       	cpi	r22, 0x0A	; 10
     d9a:	71 05       	cpc	r23, r1
     d9c:	41 f0       	breq	.+16     	; 0xdae <gc_execute_line+0x182>
     d9e:	0c 94 27 10 	jmp	0x204e	; 0x204e <gc_execute_line+0x1422>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     da2:	23 e0       	ldi	r18, 0x03	; 3
     da4:	eb ec       	ldi	r30, 0xCB	; 203
     da6:	f5 e0       	ldi	r31, 0x05	; 5
     da8:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     daa:	80 e0       	ldi	r24, 0x00	; 0
            switch(int_value) {
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
     dac:	01 c1       	rjmp	.+514    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     dae:	84 e0       	ldi	r24, 0x04	; 4
     db0:	ab ec       	ldi	r26, 0xCB	; 203
     db2:	b5 e0       	ldi	r27, 0x05	; 5
     db4:	8c 93       	st	X, r24
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     db6:	80 e0       	ldi	r24, 0x00	; 0
              case 4: gc_block.non_modal_command = NON_MODAL_DWELL; break; // G4
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
     db8:	fb c0       	rjmp	.+502    	; 0xfb0 <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     dba:	b1 e0       	ldi	r27, 0x01	; 1
     dbc:	ba a3       	std	Y+34, r27	; 0x22
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
     dbe:	61 15       	cp	r22, r1
     dc0:	71 05       	cpc	r23, r1
     dc2:	29 f0       	breq	.+10     	; 0xdce <gc_execute_line+0x1a2>
     dc4:	6a 30       	cpi	r22, 0x0A	; 10
     dc6:	71 05       	cpc	r23, r1
     dc8:	41 f0       	breq	.+16     	; 0xdda <gc_execute_line+0x1ae>
     dca:	0c 94 29 10 	jmp	0x2052	; 0x2052 <gc_execute_line+0x1426>
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     dce:	25 e0       	ldi	r18, 0x05	; 5
     dd0:	eb ec       	ldi	r30, 0xCB	; 203
     dd2:	f5 e0       	ldi	r31, 0x05	; 5
     dd4:	20 83       	st	Z, r18
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     dd6:	80 e0       	ldi	r24, 0x00	; 0
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
     dd8:	eb c0       	rjmp	.+470    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     dda:	e6 e0       	ldi	r30, 0x06	; 6
     ddc:	ab ec       	ldi	r26, 0xCB	; 203
     dde:	b5 e0       	ldi	r27, 0x05	; 5
     de0:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     de2:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
     de4:	e5 c0       	rjmp	.+458    	; 0xfb0 <gc_execute_line+0x384>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     de6:	f1 e0       	ldi	r31, 0x01	; 1
     de8:	fa a3       	std	Y+34, r31	; 0x22
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     dea:	e7 e0       	ldi	r30, 0x07	; 7
     dec:	ab ec       	ldi	r26, 0xCB	; 203
     dee:	b5 e0       	ldi	r27, 0x05	; 5
     df0:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     df2:	80 e0       	ldi	r24, 0x00	; 0
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
     df4:	d6 c0       	rjmp	.+428    	; 0xfa2 <gc_execute_line+0x376>
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     df6:	f1 e0       	ldi	r31, 0x01	; 1
     df8:	fa a3       	std	Y+34, r31	; 0x22
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
     dfa:	61 15       	cp	r22, r1
     dfc:	71 05       	cpc	r23, r1
     dfe:	29 f0       	breq	.+10     	; 0xe0a <gc_execute_line+0x1de>
     e00:	6a 30       	cpi	r22, 0x0A	; 10
     e02:	71 05       	cpc	r23, r1
     e04:	41 f0       	breq	.+16     	; 0xe16 <gc_execute_line+0x1ea>
     e06:	0c 94 2b 10 	jmp	0x2056	; 0x2056 <gc_execute_line+0x142a>
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     e0a:	e8 e0       	ldi	r30, 0x08	; 8
     e0c:	ab ec       	ldi	r26, 0xCB	; 203
     e0e:	b5 e0       	ldi	r27, 0x05	; 5
     e10:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     e12:	80 e0       	ldi	r24, 0x00	; 0
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
     e14:	cd c0       	rjmp	.+410    	; 0xfb0 <gc_execute_line+0x384>
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e16:	e9 e0       	ldi	r30, 0x09	; 9
     e18:	ab ec       	ldi	r26, 0xCB	; 203
     e1a:	b5 e0       	ldi	r27, 0x05	; 5
     e1c:	ec 93       	st	X, r30
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     e1e:	80 e0       	ldi	r24, 0x00	; 0
                break;
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
     e20:	c7 c0       	rjmp	.+398    	; 0xfb0 <gc_execute_line+0x384>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     e22:	fa a1       	ldd	r31, Y+34	; 0x22
     e24:	f1 11       	cpse	r31, r1
     e26:	0c 94 2d 10 	jmp	0x205a	; 0x205a <gc_execute_line+0x142e>
            axis_command = AXIS_COMMAND_MOTION_MODE; 
     e2a:	22 e0       	ldi	r18, 0x02	; 2
     e2c:	2a a3       	std	Y+34, r18	; 0x22
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
            switch(int_value) {
     e2e:	02 30       	cpi	r16, 0x02	; 2
     e30:	b9 f0       	breq	.+46     	; 0xe60 <gc_execute_line+0x234>
     e32:	28 f4       	brcc	.+10     	; 0xe3e <gc_execute_line+0x212>
     e34:	00 23       	and	r16, r16
     e36:	59 f0       	breq	.+22     	; 0xe4e <gc_execute_line+0x222>
     e38:	01 30       	cpi	r16, 0x01	; 1
     e3a:	69 f0       	breq	.+26     	; 0xe56 <gc_execute_line+0x22a>
     e3c:	af c0       	rjmp	.+350    	; 0xf9c <gc_execute_line+0x370>
     e3e:	06 32       	cpi	r16, 0x26	; 38
     e40:	c9 f0       	breq	.+50     	; 0xe74 <gc_execute_line+0x248>
     e42:	00 35       	cpi	r16, 0x50	; 80
     e44:	e1 f1       	breq	.+120    	; 0xebe <gc_execute_line+0x292>
     e46:	03 30       	cpi	r16, 0x03	; 3
     e48:	09 f0       	breq	.+2      	; 0xe4c <gc_execute_line+0x220>
     e4a:	a8 c0       	rjmp	.+336    	; 0xf9c <gc_execute_line+0x370>
     e4c:	0e c0       	rjmp	.+28     	; 0xe6a <gc_execute_line+0x23e>
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e4e:	10 92 cc 05 	sts	0x05CC, r1	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e52:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
     e54:	a6 c0       	rjmp	.+332    	; 0xfa2 <gc_execute_line+0x376>
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e56:	31 e0       	ldi	r19, 0x01	; 1
     e58:	30 93 cc 05 	sts	0x05CC, r19	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e5c:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
     e5e:	a1 c0       	rjmp	.+322    	; 0xfa2 <gc_execute_line+0x376>
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e60:	82 e0       	ldi	r24, 0x02	; 2
     e62:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e66:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
     e68:	9c c0       	rjmp	.+312    	; 0xfa2 <gc_execute_line+0x376>
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e6a:	83 e0       	ldi	r24, 0x03	; 3
     e6c:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e70:	81 e0       	ldi	r24, 0x01	; 1
            switch(int_value) {
              case 0: gc_block.modal.motion = MOTION_MODE_SEEK; break; // G0
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
     e72:	97 c0       	rjmp	.+302    	; 0xfa2 <gc_execute_line+0x376>
              case 38: 
                switch(mantissa) {
     e74:	6e 31       	cpi	r22, 0x1E	; 30
     e76:	71 05       	cpc	r23, r1
     e78:	99 f0       	breq	.+38     	; 0xea0 <gc_execute_line+0x274>
     e7a:	28 f4       	brcc	.+10     	; 0xe86 <gc_execute_line+0x25a>
     e7c:	64 31       	cpi	r22, 0x14	; 20
     e7e:	71 05       	cpc	r23, r1
     e80:	51 f0       	breq	.+20     	; 0xe96 <gc_execute_line+0x26a>
     e82:	0c 94 2f 10 	jmp	0x205e	; 0x205e <gc_execute_line+0x1432>
     e86:	68 32       	cpi	r22, 0x28	; 40
     e88:	71 05       	cpc	r23, r1
     e8a:	79 f0       	breq	.+30     	; 0xeaa <gc_execute_line+0x27e>
     e8c:	62 33       	cpi	r22, 0x32	; 50
     e8e:	71 05       	cpc	r23, r1
     e90:	89 f0       	breq	.+34     	; 0xeb4 <gc_execute_line+0x288>
     e92:	0c 94 2f 10 	jmp	0x205e	; 0x205e <gc_execute_line+0x1432>
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e96:	84 e0       	ldi	r24, 0x04	; 4
     e98:	80 93 cc 05 	sts	0x05CC, r24	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     e9c:	81 e0       	ldi	r24, 0x01	; 1
              case 1: gc_block.modal.motion = MOTION_MODE_LINEAR; break; // G1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
     e9e:	88 c0       	rjmp	.+272    	; 0xfb0 <gc_execute_line+0x384>
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     ea0:	95 e0       	ldi	r25, 0x05	; 5
     ea2:	90 93 cc 05 	sts	0x05CC, r25	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     ea6:	81 e0       	ldi	r24, 0x01	; 1
              case 2: gc_block.modal.motion = MOTION_MODE_CW_ARC; break; // G2
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
     ea8:	83 c0       	rjmp	.+262    	; 0xfb0 <gc_execute_line+0x384>
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     eaa:	a6 e0       	ldi	r26, 0x06	; 6
     eac:	a0 93 cc 05 	sts	0x05CC, r26	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     eb0:	81 e0       	ldi	r24, 0x01	; 1
              case 3: gc_block.modal.motion = MOTION_MODE_CCW_ARC; break; // G3
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
     eb2:	7e c0       	rjmp	.+252    	; 0xfb0 <gc_execute_line+0x384>
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     eb4:	b7 e0       	ldi	r27, 0x07	; 7
     eb6:	b0 93 cc 05 	sts	0x05CC, r27	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     eba:	81 e0       	ldi	r24, 0x01	; 1
              case 38: 
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
     ebc:	79 c0       	rjmp	.+242    	; 0xfb0 <gc_execute_line+0x384>
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     ebe:	e8 e0       	ldi	r30, 0x08	; 8
     ec0:	e0 93 cc 05 	sts	0x05CC, r30	; 0x8005cc <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     ec4:	81 e0       	ldi	r24, 0x01	; 1
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
                }
                mantissa = 0; // Set to zero to indicate valid non-integer G command.
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
     ec6:	6d c0       	rjmp	.+218    	; 0xfa2 <gc_execute_line+0x376>
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
            switch(int_value) {
     ec8:	02 31       	cpi	r16, 0x12	; 18
     eca:	49 f0       	breq	.+18     	; 0xede <gc_execute_line+0x2b2>
     ecc:	03 31       	cpi	r16, 0x13	; 19
     ece:	61 f0       	breq	.+24     	; 0xee8 <gc_execute_line+0x2bc>
     ed0:	01 31       	cpi	r16, 0x11	; 17
     ed2:	09 f0       	breq	.+2      	; 0xed6 <gc_execute_line+0x2aa>
     ed4:	65 c0       	rjmp	.+202    	; 0xfa0 <gc_execute_line+0x374>
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     ed6:	10 92 d0 05 	sts	0x05D0, r1	; 0x8005d0 <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     eda:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
     edc:	62 c0       	rjmp	.+196    	; 0xfa2 <gc_execute_line+0x376>
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ede:	f1 e0       	ldi	r31, 0x01	; 1
     ee0:	f0 93 d0 05 	sts	0x05D0, r31	; 0x8005d0 <gc_block+0x5>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     ee4:	82 e0       	ldi	r24, 0x02	; 2
            switch(int_value) {
              case 17: gc_block.modal.plane_select = PLANE_SELECT_XY; break;
              case 18: gc_block.modal.plane_select = PLANE_SELECT_ZX; break;
     ee6:	5d c0       	rjmp	.+186    	; 0xfa2 <gc_execute_line+0x376>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
     ee8:	82 e0       	ldi	r24, 0x02	; 2
     eea:	80 93 d0 05 	sts	0x05D0, r24	; 0x8005d0 <gc_block+0x5>
     eee:	59 c0       	rjmp	.+178    	; 0xfa2 <gc_execute_line+0x376>
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
     ef0:	61 15       	cp	r22, r1
     ef2:	71 05       	cpc	r23, r1
     ef4:	59 f4       	brne	.+22     	; 0xf0c <gc_execute_line+0x2e0>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
     ef6:	0a 35       	cpi	r16, 0x5A	; 90
     ef8:	21 f4       	brne	.+8      	; 0xf02 <gc_execute_line+0x2d6>
     efa:	10 92 cf 05 	sts	0x05CF, r1	; 0x8005cf <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     efe:	83 e0       	ldi	r24, 0x03	; 3
     f00:	57 c0       	rjmp	.+174    	; 0xfb0 <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
     f02:	21 e0       	ldi	r18, 0x01	; 1
     f04:	20 93 cf 05 	sts	0x05CF, r18	; 0x8005cf <gc_block+0x4>
              case 19: gc_block.modal.plane_select = PLANE_SELECT_YZ; break;
            }
            break;
          case 90: case 91: 
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
     f08:	83 e0       	ldi	r24, 0x03	; 3
     f0a:	52 c0       	rjmp	.+164    	; 0xfb0 <gc_execute_line+0x384>
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     f0c:	6a 30       	cpi	r22, 0x0A	; 10
     f0e:	71 05       	cpc	r23, r1
     f10:	11 f0       	breq	.+4      	; 0xf16 <gc_execute_line+0x2ea>
     f12:	0c 94 31 10 	jmp	0x2062	; 0x2062 <gc_execute_line+0x1436>
     f16:	0a 35       	cpi	r16, 0x5A	; 90
     f18:	11 f4       	brne	.+4      	; 0xf1e <gc_execute_line+0x2f2>
     f1a:	0c 94 33 10 	jmp	0x2066	; 0x2066 <gc_execute_line+0x143a>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
     f1e:	84 e0       	ldi	r24, 0x04	; 4
     f20:	47 c0       	rjmp	.+142    	; 0xfb0 <gc_execute_line+0x384>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
     f22:	0d 35       	cpi	r16, 0x5D	; 93
     f24:	29 f4       	brne	.+10     	; 0xf30 <gc_execute_line+0x304>
     f26:	31 e0       	ldi	r19, 0x01	; 1
     f28:	30 93 cd 05 	sts	0x05CD, r19	; 0x8005cd <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f2c:	85 e0       	ldi	r24, 0x05	; 5
     f2e:	39 c0       	rjmp	.+114    	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
     f30:	10 92 cd 05 	sts	0x05CD, r1	; 0x8005cd <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94: 
            word_bit = MODAL_GROUP_G5; 
     f34:	85 e0       	ldi	r24, 0x05	; 5
     f36:	35 c0       	rjmp	.+106    	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
     f38:	04 31       	cpi	r16, 0x14	; 20
     f3a:	29 f4       	brne	.+10     	; 0xf46 <gc_execute_line+0x31a>
     f3c:	81 e0       	ldi	r24, 0x01	; 1
     f3e:	80 93 ce 05 	sts	0x05CE, r24	; 0x8005ce <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f42:	86 e0       	ldi	r24, 0x06	; 6
     f44:	2e c0       	rjmp	.+92     	; 0xfa2 <gc_execute_line+0x376>
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
     f46:	10 92 ce 05 	sts	0x05CE, r1	; 0x8005ce <gc_block+0x3>
            word_bit = MODAL_GROUP_G5; 
            if (int_value == 93) { gc_block.modal.feed_rate = FEED_RATE_MODE_INVERSE_TIME; } // G93
            else { gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN; } // G94
            break;
          case 20: case 21: 
            word_bit = MODAL_GROUP_G6; 
     f4a:	86 e0       	ldi	r24, 0x06	; 6
     f4c:	2a c0       	rjmp	.+84     	; 0xfa2 <gc_execute_line+0x376>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     f4e:	9a a1       	ldd	r25, Y+34	; 0x22
     f50:	91 11       	cpse	r25, r1
     f52:	0c 94 35 10 	jmp	0x206a	; 0x206a <gc_execute_line+0x143e>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     f56:	01 33       	cpi	r16, 0x31	; 49
     f58:	31 f4       	brne	.+12     	; 0xf66 <gc_execute_line+0x33a>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
     f5a:	10 92 d1 05 	sts	0x05D1, r1	; 0x8005d1 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f5e:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f60:	a3 e0       	ldi	r26, 0x03	; 3
     f62:	aa a3       	std	Y+34, r26	; 0x22
     f64:	25 c0       	rjmp	.+74     	; 0xfb0 <gc_execute_line+0x384>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
     f66:	6a 30       	cpi	r22, 0x0A	; 10
     f68:	71 05       	cpc	r23, r1
     f6a:	11 f0       	breq	.+4      	; 0xf70 <gc_execute_line+0x344>
     f6c:	0c 94 37 10 	jmp	0x206e	; 0x206e <gc_execute_line+0x1442>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
     f70:	b1 e0       	ldi	r27, 0x01	; 1
     f72:	b0 93 d1 05 	sts	0x05D1, r27	; 0x8005d1 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     f76:	88 e0       	ldi	r24, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     f78:	e3 e0       	ldi	r30, 0x03	; 3
     f7a:	ea a3       	std	Y+34, r30	; 0x22
     f7c:	19 c0       	rjmp	.+50     	; 0xfb0 <gc_execute_line+0x384>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
     f7e:	06 53       	subi	r16, 0x36	; 54
     f80:	00 93 d2 05 	sts	0x05D2, r16	; 0x8005d2 <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59: 
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
     f84:	89 e0       	ldi	r24, 0x09	; 9
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
     f86:	0d c0       	rjmp	.+26     	; 0xfa2 <gc_execute_line+0x376>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
     f88:	67 2b       	or	r22, r23
     f8a:	11 f0       	breq	.+4      	; 0xf90 <gc_execute_line+0x364>
     f8c:	0c 94 39 10 	jmp	0x2072	; 0x2072 <gc_execute_line+0x1446>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
     f90:	8a e0       	ldi	r24, 0x0A	; 10
     f92:	0e c0       	rjmp	.+28     	; 0xfb0 <gc_execute_line+0x384>
            word_bit = MODAL_GROUP_G6; 
            if (int_value == 20) { gc_block.modal.units = UNITS_MODE_INCHES; }  // G20
            else { gc_block.modal.units = UNITS_MODE_MM; } // G21
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
     f94:	87 e0       	ldi	r24, 0x07	; 7
     f96:	05 c0       	rjmp	.+10     	; 0xfa2 <gc_execute_line+0x376>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	03 c0       	rjmp	.+6      	; 0xfa2 <gc_execute_line+0x376>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE; 
            // No break. Continues to next line.
          case 80: 
            word_bit = MODAL_GROUP_G1; 
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <gc_execute_line+0x376>
                break;
              case 80: gc_block.modal.motion = MOTION_MODE_NONE; break; // G80
            }            
            break;
          case 17: case 18: case 19: 
            word_bit = MODAL_GROUP_G2; 
     fa0:	82 e0       	ldi	r24, 0x02	; 2
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
     fa2:	67 2b       	or	r22, r23
     fa4:	29 f0       	breq	.+10     	; 0xfb0 <gc_execute_line+0x384>
     fa6:	0c 94 3b 10 	jmp	0x2076	; 0x2076 <gc_execute_line+0x144a>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
     faa:	80 e0       	ldi	r24, 0x00	; 0
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     fac:	f1 e0       	ldi	r31, 0x01	; 1
     fae:	fa a3       	std	Y+34, r31	; 0x22
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     fb0:	95 01       	movw	r18, r10
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <gc_execute_line+0x38c>
     fb4:	22 0f       	add	r18, r18
     fb6:	33 1f       	adc	r19, r19
     fb8:	8a 95       	dec	r24
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <gc_execute_line+0x388>
     fbc:	c9 01       	movw	r24, r18
     fbe:	96 01       	movw	r18, r12
     fc0:	28 23       	and	r18, r24
     fc2:	39 23       	and	r19, r25
     fc4:	23 2b       	or	r18, r19
     fc6:	11 f0       	breq	.+4      	; 0xfcc <gc_execute_line+0x3a0>
     fc8:	0c 94 3d 10 	jmp	0x207a	; 0x207a <gc_execute_line+0x144e>
        command_words |= bit(word_bit);
     fcc:	c8 2a       	or	r12, r24
     fce:	d9 2a       	or	r13, r25
        break;
     fd0:	0f c1       	rjmp	.+542    	; 0x11f0 <gc_execute_line+0x5c4>
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
     fd2:	67 2b       	or	r22, r23
     fd4:	11 f0       	breq	.+4      	; 0xfda <gc_execute_line+0x3ae>
     fd6:	0c 94 3f 10 	jmp	0x207e	; 0x207e <gc_execute_line+0x1452>
        switch(int_value) {
     fda:	80 2f       	mov	r24, r16
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	8f 31       	cpi	r24, 0x1F	; 31
     fe0:	91 05       	cpc	r25, r1
     fe2:	10 f0       	brcs	.+4      	; 0xfe8 <gc_execute_line+0x3bc>
     fe4:	0c 94 41 10 	jmp	0x2082	; 0x2082 <gc_execute_line+0x1456>
     fe8:	fc 01       	movw	r30, r24
     fea:	ed 56       	subi	r30, 0x6D	; 109
     fec:	ff 4f       	sbci	r31, 0xFF	; 255
     fee:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
            switch(int_value) {
     ff2:	02 30       	cpi	r16, 0x02	; 2
     ff4:	49 f0       	breq	.+18     	; 0x1008 <gc_execute_line+0x3dc>
     ff6:	0e 31       	cpi	r16, 0x1E	; 30
     ff8:	39 f0       	breq	.+14     	; 0x1008 <gc_execute_line+0x3dc>
     ffa:	01 11       	cpse	r16, r1
     ffc:	2c c0       	rjmp	.+88     	; 0x1056 <gc_execute_line+0x42a>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     ffe:	31 e0       	ldi	r19, 0x01	; 1
    1000:	30 93 d3 05 	sts	0x05D3, r19	; 0x8005d3 <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1004:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
    1006:	2c c0       	rjmp	.+88     	; 0x1060 <gc_execute_line+0x434>
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1008:	82 e0       	ldi	r24, 0x02	; 2
    100a:	80 93 d3 05 	sts	0x05D3, r24	; 0x8005d3 <gc_block+0x8>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    100e:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
              case 1: break; // Optional stop not supported. Ignore.
              case 2: case 30: gc_block.modal.program_flow = PROGRAM_FLOW_COMPLETED; break; // Program end and reset 
    1010:	27 c0       	rjmp	.+78     	; 0x1060 <gc_execute_line+0x434>
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
            switch(int_value) {
    1012:	04 30       	cpi	r16, 0x04	; 4
    1014:	49 f0       	breq	.+18     	; 0x1028 <gc_execute_line+0x3fc>
    1016:	05 30       	cpi	r16, 0x05	; 5
    1018:	61 f0       	breq	.+24     	; 0x1032 <gc_execute_line+0x406>
    101a:	03 30       	cpi	r16, 0x03	; 3
    101c:	f1 f4       	brne	.+60     	; 0x105a <gc_execute_line+0x42e>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    101e:	81 e0       	ldi	r24, 0x01	; 1
    1020:	80 93 d5 05 	sts	0x05D5, r24	; 0x8005d5 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1024:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
    1026:	1c c0       	rjmp	.+56     	; 0x1060 <gc_execute_line+0x434>
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1028:	82 e0       	ldi	r24, 0x02	; 2
    102a:	80 93 d5 05 	sts	0x05D5, r24	; 0x8005d5 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    102e:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
    1030:	17 c0       	rjmp	.+46     	; 0x1060 <gc_execute_line+0x434>
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1032:	10 92 d5 05 	sts	0x05D5, r1	; 0x8005d5 <gc_block+0xa>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    1036:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
                case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              #endif
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
    1038:	13 c0       	rjmp	.+38     	; 0x1060 <gc_execute_line+0x434>
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
            switch(int_value) {      
    103a:	08 30       	cpi	r16, 0x08	; 8
    103c:	19 f0       	breq	.+6      	; 0x1044 <gc_execute_line+0x418>
    103e:	09 30       	cpi	r16, 0x09	; 9
    1040:	31 f0       	breq	.+12     	; 0x104e <gc_execute_line+0x422>
    1042:	0d c0       	rjmp	.+26     	; 0x105e <gc_execute_line+0x432>
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    1044:	82 e0       	ldi	r24, 0x02	; 2
    1046:	80 93 d4 05 	sts	0x05D4, r24	; 0x8005d4 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    104a:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
    104c:	09 c0       	rjmp	.+18     	; 0x1060 <gc_execute_line+0x434>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    104e:	10 92 d4 05 	sts	0x05D4, r1	; 0x8005d4 <gc_block+0x9>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    1052:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {      
             #ifdef ENABLE_M7
              case 7: gc_block.modal.coolant = COOLANT_MIST_ENABLE; break;
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
    1054:	05 c0       	rjmp	.+10     	; 0x1060 <gc_execute_line+0x434>
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30: 
            word_bit = MODAL_GROUP_M4; 
    1056:	8b e0       	ldi	r24, 0x0B	; 11
    1058:	03 c0       	rjmp	.+6      	; 0x1060 <gc_execute_line+0x434>
            break;
          #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
            case 4: 
          #endif
          case 3: case 5:
            word_bit = MODAL_GROUP_M7; 
    105a:	8c e0       	ldi	r24, 0x0C	; 12
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <gc_execute_line+0x434>
            break;            
         #ifdef ENABLE_M7  
          case 7:
         #endif
          case 8: case 9:
            word_bit = MODAL_GROUP_M8; 
    105e:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1060:	d5 01       	movw	r26, r10
    1062:	02 c0       	rjmp	.+4      	; 0x1068 <gc_execute_line+0x43c>
    1064:	aa 0f       	add	r26, r26
    1066:	bb 1f       	adc	r27, r27
    1068:	8a 95       	dec	r24
    106a:	e2 f7       	brpl	.-8      	; 0x1064 <gc_execute_line+0x438>
    106c:	96 01       	movw	r18, r12
    106e:	2a 23       	and	r18, r26
    1070:	3b 23       	and	r19, r27
    1072:	23 2b       	or	r18, r19
    1074:	11 f0       	breq	.+4      	; 0x107a <gc_execute_line+0x44e>
    1076:	0c 94 43 10 	jmp	0x2086	; 0x2086 <gc_execute_line+0x145a>
        command_words |= bit(word_bit);
    107a:	ca 2a       	or	r12, r26
    107c:	db 2a       	or	r13, r27
        break;
    107e:	b8 c0       	rjmp	.+368    	; 0x11f0 <gc_execute_line+0x5c4>
      default: 
  
        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
    1080:	81 2f       	mov	r24, r17
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	fc 01       	movw	r30, r24
    1086:	e6 54       	subi	r30, 0x46	; 70
    1088:	f1 09       	sbc	r31, r1
    108a:	e5 31       	cpi	r30, 0x15	; 21
    108c:	f1 05       	cpc	r31, r1
    108e:	10 f0       	brcs	.+4      	; 0x1094 <gc_execute_line+0x468>
    1090:	0c 94 45 10 	jmp	0x208a	; 0x208a <gc_execute_line+0x145e>
    1094:	ee 54       	subi	r30, 0x4E	; 78
    1096:	ff 4f       	sbci	r31, 0xFF	; 255
    1098:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
    109c:	20 92 d6 05 	sts	0x05D6, r2	; 0x8005d6 <gc_block+0xb>
    10a0:	30 92 d7 05 	sts	0x05D7, r3	; 0x8005d7 <gc_block+0xc>
    10a4:	40 92 d8 05 	sts	0x05D8, r4	; 0x8005d8 <gc_block+0xd>
    10a8:	50 92 d9 05 	sts	0x05D9, r5	; 0x8005d9 <gc_block+0xe>
    10ac:	80 e0       	ldi	r24, 0x00	; 0
    10ae:	7f c0       	rjmp	.+254    	; 0x11ae <gc_execute_line+0x582>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
    10b0:	20 92 da 05 	sts	0x05DA, r2	; 0x8005da <gc_block+0xf>
    10b4:	30 92 db 05 	sts	0x05DB, r3	; 0x8005db <gc_block+0x10>
    10b8:	40 92 dc 05 	sts	0x05DC, r4	; 0x8005dc <gc_block+0x11>
    10bc:	50 92 dd 05 	sts	0x05DD, r5	; 0x8005dd <gc_block+0x12>
    10c0:	bb a1       	ldd	r27, Y+35	; 0x23
    10c2:	b1 60       	ori	r27, 0x01	; 1
    10c4:	bb a3       	std	Y+35, r27	; 0x23
    10c6:	81 e0       	ldi	r24, 0x01	; 1
    10c8:	72 c0       	rjmp	.+228    	; 0x11ae <gc_execute_line+0x582>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
    10ca:	20 92 de 05 	sts	0x05DE, r2	; 0x8005de <gc_block+0x13>
    10ce:	30 92 df 05 	sts	0x05DF, r3	; 0x8005df <gc_block+0x14>
    10d2:	40 92 e0 05 	sts	0x05E0, r4	; 0x8005e0 <gc_block+0x15>
    10d6:	50 92 e1 05 	sts	0x05E1, r5	; 0x8005e1 <gc_block+0x16>
    10da:	eb a1       	ldd	r30, Y+35	; 0x23
    10dc:	e2 60       	ori	r30, 0x02	; 2
    10de:	eb a3       	std	Y+35, r30	; 0x23
    10e0:	82 e0       	ldi	r24, 0x02	; 2
    10e2:	65 c0       	rjmp	.+202    	; 0x11ae <gc_execute_line+0x582>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
    10e4:	20 92 e2 05 	sts	0x05E2, r2	; 0x8005e2 <gc_block+0x17>
    10e8:	30 92 e3 05 	sts	0x05E3, r3	; 0x8005e3 <gc_block+0x18>
    10ec:	40 92 e4 05 	sts	0x05E4, r4	; 0x8005e4 <gc_block+0x19>
    10f0:	50 92 e5 05 	sts	0x05E5, r5	; 0x8005e5 <gc_block+0x1a>
    10f4:	fb a1       	ldd	r31, Y+35	; 0x23
    10f6:	f4 60       	ori	r31, 0x04	; 4
    10f8:	fb a3       	std	Y+35, r31	; 0x23
    10fa:	83 e0       	ldi	r24, 0x03	; 3
    10fc:	58 c0       	rjmp	.+176    	; 0x11ae <gc_execute_line+0x582>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
    10fe:	00 93 e6 05 	sts	0x05E6, r16	; 0x8005e6 <gc_block+0x1b>
    1102:	84 e0       	ldi	r24, 0x04	; 4
    1104:	54 c0       	rjmp	.+168    	; 0x11ae <gc_execute_line+0x582>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
    1106:	c2 01       	movw	r24, r4
    1108:	b1 01       	movw	r22, r2
    110a:	0e 94 27 3b 	call	0x764e	; 0x764e <__fixsfsi>
    110e:	60 93 e7 05 	sts	0x05E7, r22	; 0x8005e7 <gc_block+0x1c>
    1112:	70 93 e8 05 	sts	0x05E8, r23	; 0x8005e8 <gc_block+0x1d>
    1116:	80 93 e9 05 	sts	0x05E9, r24	; 0x8005e9 <gc_block+0x1e>
    111a:	90 93 ea 05 	sts	0x05EA, r25	; 0x8005ea <gc_block+0x1f>
    111e:	85 e0       	ldi	r24, 0x05	; 5
    1120:	46 c0       	rjmp	.+140    	; 0x11ae <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
    1122:	20 92 eb 05 	sts	0x05EB, r2	; 0x8005eb <gc_block+0x20>
    1126:	30 92 ec 05 	sts	0x05EC, r3	; 0x8005ec <gc_block+0x21>
    112a:	40 92 ed 05 	sts	0x05ED, r4	; 0x8005ed <gc_block+0x22>
    112e:	50 92 ee 05 	sts	0x05EE, r5	; 0x8005ee <gc_block+0x23>
    1132:	86 e0       	ldi	r24, 0x06	; 6
    1134:	3c c0       	rjmp	.+120    	; 0x11ae <gc_execute_line+0x582>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
    1136:	20 92 ef 05 	sts	0x05EF, r2	; 0x8005ef <gc_block+0x24>
    113a:	30 92 f0 05 	sts	0x05F0, r3	; 0x8005f0 <gc_block+0x25>
    113e:	40 92 f1 05 	sts	0x05F1, r4	; 0x8005f1 <gc_block+0x26>
    1142:	50 92 f2 05 	sts	0x05F2, r5	; 0x8005f2 <gc_block+0x27>
    1146:	87 e0       	ldi	r24, 0x07	; 7
    1148:	32 c0       	rjmp	.+100    	; 0x11ae <gc_execute_line+0x582>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
    114a:	20 92 f3 05 	sts	0x05F3, r2	; 0x8005f3 <gc_block+0x28>
    114e:	30 92 f4 05 	sts	0x05F4, r3	; 0x8005f4 <gc_block+0x29>
    1152:	40 92 f5 05 	sts	0x05F5, r4	; 0x8005f5 <gc_block+0x2a>
    1156:	50 92 f6 05 	sts	0x05F6, r5	; 0x8005f6 <gc_block+0x2b>
    115a:	88 e0       	ldi	r24, 0x08	; 8
    115c:	28 c0       	rjmp	.+80     	; 0x11ae <gc_execute_line+0x582>
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
    115e:	20 92 f8 05 	sts	0x05F8, r2	; 0x8005f8 <gc_block+0x2d>
    1162:	30 92 f9 05 	sts	0x05F9, r3	; 0x8005f9 <gc_block+0x2e>
    1166:	40 92 fa 05 	sts	0x05FA, r4	; 0x8005fa <gc_block+0x2f>
    116a:	50 92 fb 05 	sts	0x05FB, r5	; 0x8005fb <gc_block+0x30>
    116e:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1170:	21 60       	ori	r18, 0x01	; 1
    1172:	2e 8f       	std	Y+30, r18	; 0x1e
    1174:	8a e0       	ldi	r24, 0x0A	; 10
    1176:	1b c0       	rjmp	.+54     	; 0x11ae <gc_execute_line+0x582>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
    1178:	20 92 fc 05 	sts	0x05FC, r2	; 0x8005fc <gc_block+0x31>
    117c:	30 92 fd 05 	sts	0x05FD, r3	; 0x8005fd <gc_block+0x32>
    1180:	40 92 fe 05 	sts	0x05FE, r4	; 0x8005fe <gc_block+0x33>
    1184:	50 92 ff 05 	sts	0x05FF, r5	; 0x8005ff <gc_block+0x34>
    1188:	3e 8d       	ldd	r19, Y+30	; 0x1e
    118a:	32 60       	ori	r19, 0x02	; 2
    118c:	3e 8f       	std	Y+30, r19	; 0x1e
    118e:	8b e0       	ldi	r24, 0x0B	; 11
    1190:	0e c0       	rjmp	.+28     	; 0x11ae <gc_execute_line+0x582>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
    1192:	20 92 00 06 	sts	0x0600, r2	; 0x800600 <gc_block+0x35>
    1196:	30 92 01 06 	sts	0x0601, r3	; 0x800601 <gc_block+0x36>
    119a:	40 92 02 06 	sts	0x0602, r4	; 0x800602 <gc_block+0x37>
    119e:	50 92 03 06 	sts	0x0603, r5	; 0x800603 <gc_block+0x38>
    11a2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    11a4:	84 60       	ori	r24, 0x04	; 4
    11a6:	8e 8f       	std	Y+30, r24	; 0x1e
    11a8:	8c e0       	ldi	r24, 0x0C	; 12
    11aa:	01 c0       	rjmp	.+2      	; 0x11ae <gc_execute_line+0x582>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
    11ac:	89 e0       	ldi	r24, 0x09	; 9
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    11ae:	85 01       	movw	r16, r10
    11b0:	08 2e       	mov	r0, r24
    11b2:	02 c0       	rjmp	.+4      	; 0x11b8 <gc_execute_line+0x58c>
    11b4:	00 0f       	add	r16, r16
    11b6:	11 1f       	adc	r17, r17
    11b8:	0a 94       	dec	r0
    11ba:	e2 f7       	brpl	.-8      	; 0x11b4 <gc_execute_line+0x588>
    11bc:	93 01       	movw	r18, r6
    11be:	20 23       	and	r18, r16
    11c0:	31 23       	and	r19, r17
    11c2:	23 2b       	or	r18, r19
    11c4:	09 f0       	breq	.+2      	; 0x11c8 <gc_execute_line+0x59c>
    11c6:	63 c7       	rjmp	.+3782   	; 0x208e <gc_execute_line+0x1462>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
    11c8:	d4 01       	movw	r26, r8
    11ca:	02 c0       	rjmp	.+4      	; 0x11d0 <gc_execute_line+0x5a4>
    11cc:	b5 95       	asr	r27
    11ce:	a7 95       	ror	r26
    11d0:	8a 95       	dec	r24
    11d2:	e2 f7       	brpl	.-8      	; 0x11cc <gc_execute_line+0x5a0>
    11d4:	a0 ff       	sbrs	r26, 0
    11d6:	0a c0       	rjmp	.+20     	; 0x11ec <gc_execute_line+0x5c0>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    11d8:	20 e0       	ldi	r18, 0x00	; 0
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	a9 01       	movw	r20, r18
    11de:	c2 01       	movw	r24, r4
    11e0:	b1 01       	movw	r22, r2
    11e2:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    11e6:	88 23       	and	r24, r24
    11e8:	0c f4       	brge	.+2      	; 0x11ec <gc_execute_line+0x5c0>
    11ea:	53 c7       	rjmp	.+3750   	; 0x2092 <gc_execute_line+0x1466>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    11ec:	60 2a       	or	r6, r16
    11ee:	71 2a       	or	r7, r17
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    11f0:	89 8d       	ldd	r24, Y+25	; 0x19
    11f2:	f7 01       	movw	r30, r14
    11f4:	e8 0f       	add	r30, r24
    11f6:	f1 1d       	adc	r31, r1
    11f8:	10 81       	ld	r17, Z
    11fa:	11 11       	cpse	r17, r1
    11fc:	54 cd       	rjmp	.-1368   	; 0xca6 <gc_execute_line+0x7a>
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  
  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    11fe:	be 8d       	ldd	r27, Y+30	; 0x1e
    1200:	bb 23       	and	r27, r27
    1202:	29 f0       	breq	.+10     	; 0x120e <gc_execute_line+0x5e2>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1204:	ea a1       	ldd	r30, Y+34	; 0x22
    1206:	e1 11       	cpse	r30, r1
    1208:	02 c0       	rjmp	.+4      	; 0x120e <gc_execute_line+0x5e2>
    120a:	f2 e0       	ldi	r31, 0x02	; 2
    120c:	fa a3       	std	Y+34, r31	; 0x22
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    120e:	65 fe       	sbrs	r6, 5
    1210:	0e c0       	rjmp	.+28     	; 0x122e <gc_execute_line+0x602>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1212:	80 91 e7 05 	lds	r24, 0x05E7	; 0x8005e7 <gc_block+0x1c>
    1216:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <gc_block+0x1d>
    121a:	a0 91 e9 05 	lds	r26, 0x05E9	; 0x8005e9 <gc_block+0x1e>
    121e:	b0 91 ea 05 	lds	r27, 0x05EA	; 0x8005ea <gc_block+0x1f>
    1222:	80 38       	cpi	r24, 0x80	; 128
    1224:	96 49       	sbci	r25, 0x96	; 150
    1226:	a8 49       	sbci	r26, 0x98	; 152
    1228:	b1 05       	cpc	r27, r1
    122a:	0c f0       	brlt	.+2      	; 0x122e <gc_execute_line+0x602>
    122c:	34 c7       	rjmp	.+3688   	; 0x2096 <gc_execute_line+0x146a>
  
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.
  
  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    122e:	80 91 cd 05 	lds	r24, 0x05CD	; 0x8005cd <gc_block+0x2>
    1232:	81 30       	cpi	r24, 0x01	; 1
    1234:	31 f4       	brne	.+12     	; 0x1242 <gc_execute_line+0x616>
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
    1236:	3a a1       	ldd	r19, Y+34	; 0x22
    1238:	32 30       	cpi	r19, 0x02	; 2
    123a:	91 f5       	brne	.+100    	; 0x12a0 <gc_execute_line+0x674>
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    123c:	60 fe       	sbrs	r6, 0
    123e:	2d c7       	rjmp	.+3674   	; 0x209a <gc_execute_line+0x146e>
    1240:	2f c0       	rjmp	.+94     	; 0x12a0 <gc_execute_line+0x674>
    // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error 
    // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
    // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
  } else { // = G94
    // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
    if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    1242:	80 91 8d 05 	lds	r24, 0x058D	; 0x80058d <gc_state+0x1>
    1246:	81 11       	cpse	r24, r1
    1248:	2b c0       	rjmp	.+86     	; 0x12a0 <gc_execute_line+0x674>
      if (bit_istrue(value_words,bit(WORD_F))) {
    124a:	60 fe       	sbrs	r6, 0
    124c:	19 c0       	rjmp	.+50     	; 0x1280 <gc_execute_line+0x654>
        if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    124e:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <gc_block+0x3>
    1252:	81 30       	cpi	r24, 0x01	; 1
    1254:	29 f5       	brne	.+74     	; 0x12a0 <gc_execute_line+0x674>
    1256:	0b ec       	ldi	r16, 0xCB	; 203
    1258:	15 e0       	ldi	r17, 0x05	; 5
    125a:	23 e3       	ldi	r18, 0x33	; 51
    125c:	33 e3       	ldi	r19, 0x33	; 51
    125e:	4b ec       	ldi	r20, 0xCB	; 203
    1260:	51 e4       	ldi	r21, 0x41	; 65
    1262:	d8 01       	movw	r26, r16
    1264:	1b 96       	adiw	r26, 0x0b	; 11
    1266:	6d 91       	ld	r22, X+
    1268:	7d 91       	ld	r23, X+
    126a:	8d 91       	ld	r24, X+
    126c:	9c 91       	ld	r25, X
    126e:	1e 97       	sbiw	r26, 0x0e	; 14
    1270:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1274:	f8 01       	movw	r30, r16
    1276:	63 87       	std	Z+11, r22	; 0x0b
    1278:	74 87       	std	Z+12, r23	; 0x0c
    127a:	85 87       	std	Z+13, r24	; 0x0d
    127c:	96 87       	std	Z+14, r25	; 0x0e
    127e:	10 c0       	rjmp	.+32     	; 0x12a0 <gc_execute_line+0x674>
      } else {
        gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    1280:	80 91 9a 05 	lds	r24, 0x059A	; 0x80059a <gc_state+0xe>
    1284:	90 91 9b 05 	lds	r25, 0x059B	; 0x80059b <gc_state+0xf>
    1288:	a0 91 9c 05 	lds	r26, 0x059C	; 0x80059c <gc_state+0x10>
    128c:	b0 91 9d 05 	lds	r27, 0x059D	; 0x80059d <gc_state+0x11>
    1290:	80 93 d6 05 	sts	0x05D6, r24	; 0x8005d6 <gc_block+0xb>
    1294:	90 93 d7 05 	sts	0x05D7, r25	; 0x8005d7 <gc_block+0xc>
    1298:	a0 93 d8 05 	sts	0x05D8, r26	; 0x8005d8 <gc_block+0xd>
    129c:	b0 93 d9 05 	sts	0x05D9, r27	; 0x8005d9 <gc_block+0xe>
    } // Else, switching to G94 from G93, so don't push last state feed rate. Its undefined or the passed F word value.
  } 
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.
  
  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    12a0:	70 fc       	sbrc	r7, 0
    12a2:	10 c0       	rjmp	.+32     	; 0x12c4 <gc_execute_line+0x698>
    12a4:	80 91 96 05 	lds	r24, 0x0596	; 0x800596 <gc_state+0xa>
    12a8:	90 91 97 05 	lds	r25, 0x0597	; 0x800597 <gc_state+0xb>
    12ac:	a0 91 98 05 	lds	r26, 0x0598	; 0x800598 <gc_state+0xc>
    12b0:	b0 91 99 05 	lds	r27, 0x0599	; 0x800599 <gc_state+0xd>
    12b4:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <gc_block+0x28>
    12b8:	90 93 f4 05 	sts	0x05F4, r25	; 0x8005f4 <gc_block+0x29>
    12bc:	a0 93 f5 05 	sts	0x05F5, r26	; 0x8005f5 <gc_block+0x2a>
    12c0:	b0 93 f6 05 	sts	0x05F6, r27	; 0x8005f6 <gc_block+0x2b>
  // [7. Spindle control ]: N/A
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    12c4:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <gc_block>
    12c8:	81 30       	cpi	r24, 0x01	; 1
    12ca:	21 f4       	brne	.+8      	; 0x12d4 <gc_execute_line+0x6a8>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    12cc:	66 fe       	sbrs	r6, 6
    12ce:	e7 c6       	rjmp	.+3534   	; 0x209e <gc_execute_line+0x1472>
    bit_false(value_words,bit(WORD_P));
    12d0:	e8 94       	clt
    12d2:	66 f8       	bld	r6, 6
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    12d4:	80 91 d0 05 	lds	r24, 0x05D0	; 0x8005d0 <gc_block+0x5>
    12d8:	88 23       	and	r24, r24
    12da:	49 f0       	breq	.+18     	; 0x12ee <gc_execute_line+0x6c2>
    12dc:	81 30       	cpi	r24, 0x01	; 1
    12de:	09 f4       	brne	.+2      	; 0x12e2 <gc_execute_line+0x6b6>
    12e0:	4d c7       	rjmp	.+3738   	; 0x217c <gc_execute_line+0x1550>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    12e2:	1e a2       	std	Y+38, r1	; 0x26
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    12e4:	f2 e0       	ldi	r31, 0x02	; 2
    12e6:	fd a3       	std	Y+37, r31	; 0x25
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    12e8:	21 e0       	ldi	r18, 0x01	; 1
    12ea:	2c a3       	std	Y+36, r18	; 0x24
    12ec:	4c c7       	rjmp	.+3736   	; 0x2186 <gc_execute_line+0x155a>
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    12ee:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <gc_block+0x3>
    12f2:	81 30       	cpi	r24, 0x01	; 1
    12f4:	99 f5       	brne	.+102    	; 0x135c <gc_execute_line+0x730>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    12f6:	32 e0       	ldi	r19, 0x02	; 2
    12f8:	3e a3       	std	Y+38, r19	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    12fa:	8d a3       	std	Y+37, r24	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    12fc:	1c a2       	std	Y+36, r1	; 0x24
    12fe:	0f 2e       	mov	r0, r31
    1300:	fb ec       	ldi	r31, 0xCB	; 203
    1302:	af 2e       	mov	r10, r31
    1304:	f5 e0       	ldi	r31, 0x05	; 5
    1306:	bf 2e       	mov	r11, r31
    1308:	f0 2d       	mov	r31, r0
    130a:	00 e0       	ldi	r16, 0x00	; 0
    130c:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    130e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1310:	e9 2e       	mov	r14, r25
    1312:	f1 2c       	mov	r15, r1
    1314:	c7 01       	movw	r24, r14
    1316:	00 2e       	mov	r0, r16
    1318:	02 c0       	rjmp	.+4      	; 0x131e <gc_execute_line+0x6f2>
    131a:	95 95       	asr	r25
    131c:	87 95       	ror	r24
    131e:	0a 94       	dec	r0
    1320:	e2 f7       	brpl	.-8      	; 0x131a <gc_execute_line+0x6ee>
    1322:	80 ff       	sbrs	r24, 0
    1324:	12 c0       	rjmp	.+36     	; 0x134a <gc_execute_line+0x71e>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1326:	23 e3       	ldi	r18, 0x33	; 51
    1328:	33 e3       	ldi	r19, 0x33	; 51
    132a:	4b ec       	ldi	r20, 0xCB	; 203
    132c:	51 e4       	ldi	r21, 0x41	; 65
    132e:	d5 01       	movw	r26, r10
    1330:	9d 96       	adiw	r26, 0x2d	; 45
    1332:	6d 91       	ld	r22, X+
    1334:	7d 91       	ld	r23, X+
    1336:	8d 91       	ld	r24, X+
    1338:	9c 91       	ld	r25, X
    133a:	d0 97       	sbiw	r26, 0x30	; 48
    133c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1340:	f5 01       	movw	r30, r10
    1342:	65 a7       	std	Z+45, r22	; 0x2d
    1344:	76 a7       	std	Z+46, r23	; 0x2e
    1346:	87 a7       	std	Z+47, r24	; 0x2f
    1348:	90 ab       	std	Z+48, r25	; 0x30
    134a:	0f 5f       	subi	r16, 0xFF	; 255
    134c:	1f 4f       	sbci	r17, 0xFF	; 255
    134e:	f4 e0       	ldi	r31, 0x04	; 4
    1350:	af 0e       	add	r10, r31
    1352:	b1 1c       	adc	r11, r1
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1354:	03 30       	cpi	r16, 0x03	; 3
    1356:	11 05       	cpc	r17, r1
    1358:	e9 f6       	brne	.-70     	; 0x1314 <gc_execute_line+0x6e8>
    135a:	05 c0       	rjmp	.+10     	; 0x1366 <gc_execute_line+0x73a>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    135c:	22 e0       	ldi	r18, 0x02	; 2
    135e:	2e a3       	std	Y+38, r18	; 0x26
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1360:	31 e0       	ldi	r19, 0x01	; 1
    1362:	3d a3       	std	Y+37, r19	; 0x25
  }
  
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    1364:	1c a2       	std	Y+36, r1	; 0x24
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are. 
  // [G43.1 Errors]: Motion command in same line. 
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    1366:	8a a1       	ldd	r24, Y+34	; 0x22
    1368:	83 30       	cpi	r24, 0x03	; 3
    136a:	41 f4       	brne	.+16     	; 0x137c <gc_execute_line+0x750>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    136c:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <gc_block+0x6>
    1370:	81 30       	cpi	r24, 0x01	; 1
    1372:	21 f4       	brne	.+8      	; 0x137c <gc_execute_line+0x750>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    1374:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1376:	94 30       	cpi	r25, 0x04	; 4
    1378:	09 f0       	breq	.+2      	; 0x137c <gc_execute_line+0x750>
    137a:	93 c6       	rjmp	.+3366   	; 0x20a2 <gc_execute_line+0x1476>
  // [15. Coordinate system selection ]: *N/A. Error, if cutter radius comp is active.
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
    137c:	8c e0       	ldi	r24, 0x0C	; 12
    137e:	ef ea       	ldi	r30, 0xAF	; 175
    1380:	f5 e0       	ldi	r31, 0x05	; 5
    1382:	de 01       	movw	r26, r28
    1384:	11 96       	adiw	r26, 0x01	; 1
    1386:	01 90       	ld	r0, Z+
    1388:	0d 92       	st	X+, r0
    138a:	8a 95       	dec	r24
    138c:	e1 f7       	brne	.-8      	; 0x1386 <gc_execute_line+0x75a>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    138e:	d1 fe       	sbrs	r13, 1
    1390:	11 c0       	rjmp	.+34     	; 0x13b4 <gc_execute_line+0x788>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1392:	80 91 d2 05 	lds	r24, 0x05D2	; 0x8005d2 <gc_block+0x7>
    1396:	87 30       	cpi	r24, 0x07	; 7
    1398:	08 f0       	brcs	.+2      	; 0x139c <gc_execute_line+0x770>
    139a:	85 c6       	rjmp	.+3338   	; 0x20a6 <gc_execute_line+0x147a>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    139c:	90 91 92 05 	lds	r25, 0x0592	; 0x800592 <gc_state+0x6>
    13a0:	89 17       	cp	r24, r25
    13a2:	41 f0       	breq	.+16     	; 0x13b4 <gc_execute_line+0x788>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    13a4:	be 01       	movw	r22, r28
    13a6:	6f 5f       	subi	r22, 0xFF	; 255
    13a8:	7f 4f       	sbci	r23, 0xFF	; 255
    13aa:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    13ae:	88 23       	and	r24, r24
    13b0:	09 f4       	brne	.+2      	; 0x13b4 <gc_execute_line+0x788>
    13b2:	7b c6       	rjmp	.+3318   	; 0x20aa <gc_execute_line+0x147e>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets. 
  switch (gc_block.non_modal_command) {
    13b4:	50 90 cb 05 	lds	r5, 0x05CB	; 0x8005cb <gc_block>
    13b8:	a2 e0       	ldi	r26, 0x02	; 2
    13ba:	5a 16       	cp	r5, r26
    13bc:	29 f0       	breq	.+10     	; 0x13c8 <gc_execute_line+0x79c>
    13be:	b8 e0       	ldi	r27, 0x08	; 8
    13c0:	5b 16       	cp	r5, r27
    13c2:	09 f4       	brne	.+2      	; 0x13c6 <gc_execute_line+0x79a>
    13c4:	a8 c0       	rjmp	.+336    	; 0x1516 <gc_execute_line+0x8ea>
    13c6:	1c c1       	rjmp	.+568    	; 0x1600 <gc_execute_line+0x9d4>
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    13c8:	ee 8d       	ldd	r30, Y+30	; 0x1e
    13ca:	ee 23       	and	r30, r30
    13cc:	09 f4       	brne	.+2      	; 0x13d0 <gc_execute_line+0x7a4>
    13ce:	6f c6       	rjmp	.+3294   	; 0x20ae <gc_execute_line+0x1482>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    13d0:	c3 01       	movw	r24, r6
    13d2:	80 75       	andi	r24, 0x50	; 80
    13d4:	99 27       	eor	r25, r25
    13d6:	89 2b       	or	r24, r25
    13d8:	09 f4       	brne	.+2      	; 0x13dc <gc_execute_line+0x7b0>
    13da:	6b c6       	rjmp	.+3286   	; 0x20b2 <gc_execute_line+0x1486>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    13dc:	60 91 eb 05 	lds	r22, 0x05EB	; 0x8005eb <gc_block+0x20>
    13e0:	70 91 ec 05 	lds	r23, 0x05EC	; 0x8005ec <gc_block+0x21>
    13e4:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x22>
    13e8:	90 91 ee 05 	lds	r25, 0x05EE	; 0x8005ee <gc_block+0x23>
    13ec:	0e 94 f0 3d 	call	0x7be0	; 0x7be0 <trunc>
    13f0:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    13f4:	67 30       	cpi	r22, 0x07	; 7
    13f6:	08 f0       	brcs	.+2      	; 0x13fa <gc_execute_line+0x7ce>
    13f8:	5e c6       	rjmp	.+3260   	; 0x20b6 <gc_execute_line+0x148a>
      if (gc_block.values.l != 20) {
    13fa:	80 91 e6 05 	lds	r24, 0x05E6	; 0x8005e6 <gc_block+0x1b>
    13fe:	84 31       	cpi	r24, 0x14	; 20
    1400:	29 f0       	breq	.+10     	; 0x140c <gc_execute_line+0x7e0>
        if (gc_block.values.l == 2) {
    1402:	82 30       	cpi	r24, 0x02	; 2
    1404:	09 f0       	breq	.+2      	; 0x1408 <gc_execute_line+0x7dc>
    1406:	59 c6       	rjmp	.+3250   	; 0x20ba <gc_execute_line+0x148e>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1408:	67 fc       	sbrc	r6, 7
    140a:	59 c6       	rjmp	.+3250   	; 0x20be <gc_execute_line+0x1492>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    140c:	ff ea       	ldi	r31, 0xAF	; 175
    140e:	6f 22       	and	r6, r31
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1410:	66 23       	and	r22, r22
    1412:	19 f0       	breq	.+6      	; 0x141a <gc_execute_line+0x7ee>
    1414:	61 50       	subi	r22, 0x01	; 1
    1416:	6f a3       	std	Y+39, r22	; 0x27
    1418:	03 c0       	rjmp	.+6      	; 0x1420 <gc_execute_line+0x7f4>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    141a:	20 91 d2 05 	lds	r18, 0x05D2	; 0x8005d2 <gc_block+0x7>
    141e:	2f a3       	std	Y+39, r18	; 0x27
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1420:	be 01       	movw	r22, r28
    1422:	63 5f       	subi	r22, 0xF3	; 243
    1424:	7f 4f       	sbci	r23, 0xFF	; 255
    1426:	8f a1       	ldd	r24, Y+39	; 0x27
    1428:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    142c:	88 23       	and	r24, r24
    142e:	09 f4       	brne	.+2      	; 0x1432 <gc_execute_line+0x806>
    1430:	48 c6       	rjmp	.+3216   	; 0x20c2 <gc_execute_line+0x1496>
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    1432:	30 90 e6 05 	lds	r3, 0x05E6	; 0x8005e6 <gc_block+0x1b>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    1436:	80 91 c7 05 	lds	r24, 0x05C7	; 0x8005c7 <gc_state+0x3b>
    143a:	90 91 c8 05 	lds	r25, 0x05C8	; 0x8005c8 <gc_state+0x3c>
    143e:	a0 91 c9 05 	lds	r26, 0x05C9	; 0x8005c9 <gc_state+0x3d>
    1442:	b0 91 ca 05 	lds	r27, 0x05CA	; 0x8005ca <gc_state+0x3e>
    1446:	88 a7       	std	Y+40, r24	; 0x28
    1448:	99 a7       	std	Y+41, r25	; 0x29
    144a:	aa a7       	std	Y+42, r26	; 0x2a
    144c:	bb a7       	std	Y+43, r27	; 0x2b
    144e:	8e 01       	movw	r16, r28
    1450:	03 5f       	subi	r16, 0xF3	; 243
    1452:	1f 4f       	sbci	r17, 0xFF	; 255
    1454:	0f 2e       	mov	r0, r31
    1456:	fb ec       	ldi	r31, 0xCB	; 203
    1458:	ef 2e       	mov	r14, r31
    145a:	f5 e0       	ldi	r31, 0x05	; 5
    145c:	ff 2e       	mov	r15, r31
    145e:	f0 2d       	mov	r31, r0
    1460:	0f 2e       	mov	r0, r31
    1462:	fc e8       	ldi	r31, 0x8C	; 140
    1464:	cf 2e       	mov	r12, r31
    1466:	f5 e0       	ldi	r31, 0x05	; 5
    1468:	df 2e       	mov	r13, r31
    146a:	f0 2d       	mov	r31, r0
    146c:	a1 2c       	mov	r10, r1
    146e:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1470:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1472:	89 2e       	mov	r8, r25
    1474:	91 2c       	mov	r9, r1
    1476:	c4 01       	movw	r24, r8
    1478:	0a 2c       	mov	r0, r10
    147a:	02 c0       	rjmp	.+4      	; 0x1480 <gc_execute_line+0x854>
    147c:	95 95       	asr	r25
    147e:	87 95       	ror	r24
    1480:	0a 94       	dec	r0
    1482:	e2 f7       	brpl	.-8      	; 0x147c <gc_execute_line+0x850>
    1484:	80 ff       	sbrs	r24, 0
    1486:	36 c0       	rjmp	.+108    	; 0x14f4 <gc_execute_line+0x8c8>
          if (gc_block.values.l == 20) {
    1488:	a4 e1       	ldi	r26, 0x14	; 20
    148a:	3a 12       	cpse	r3, r26
    148c:	29 c0       	rjmp	.+82     	; 0x14e0 <gc_execute_line+0x8b4>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            parameter_data[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    148e:	f6 01       	movw	r30, r12
    1490:	27 a5       	ldd	r18, Z+47	; 0x2f
    1492:	30 a9       	ldd	r19, Z+48	; 0x30
    1494:	41 a9       	ldd	r20, Z+49	; 0x31
    1496:	52 a9       	ldd	r21, Z+50	; 0x32
    1498:	67 89       	ldd	r22, Z+23	; 0x17
    149a:	70 8d       	ldd	r23, Z+24	; 0x18
    149c:	81 8d       	ldd	r24, Z+25	; 0x19
    149e:	92 8d       	ldd	r25, Z+26	; 0x1a
    14a0:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    14a4:	d7 01       	movw	r26, r14
    14a6:	9d 96       	adiw	r26, 0x2d	; 45
    14a8:	2d 91       	ld	r18, X+
    14aa:	3d 91       	ld	r19, X+
    14ac:	4d 91       	ld	r20, X+
    14ae:	5c 91       	ld	r21, X
    14b0:	d0 97       	sbiw	r26, 0x30	; 48
    14b2:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    14b6:	f8 01       	movw	r30, r16
    14b8:	60 83       	st	Z, r22
    14ba:	71 83       	std	Z+1, r23	; 0x01
    14bc:	82 83       	std	Z+2, r24	; 0x02
    14be:	93 83       	std	Z+3, r25	; 0x03
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { parameter_data[idx] -= gc_state.tool_length_offset; }
    14c0:	f2 e0       	ldi	r31, 0x02	; 2
    14c2:	af 12       	cpse	r10, r31
    14c4:	17 c0       	rjmp	.+46     	; 0x14f4 <gc_execute_line+0x8c8>
    14c6:	28 a5       	ldd	r18, Y+40	; 0x28
    14c8:	39 a5       	ldd	r19, Y+41	; 0x29
    14ca:	4a a5       	ldd	r20, Y+42	; 0x2a
    14cc:	5b a5       	ldd	r21, Y+43	; 0x2b
    14ce:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    14d2:	d8 01       	movw	r26, r16
    14d4:	6d 93       	st	X+, r22
    14d6:	7d 93       	st	X+, r23
    14d8:	8d 93       	st	X+, r24
    14da:	9c 93       	st	X, r25
    14dc:	13 97       	sbiw	r26, 0x03	; 3
    14de:	0a c0       	rjmp	.+20     	; 0x14f4 <gc_execute_line+0x8c8>
          } else {
            // L2: Update coordinate system axis to programmed value.
            parameter_data[idx] = gc_block.values.xyz[idx]; 
    14e0:	f7 01       	movw	r30, r14
    14e2:	85 a5       	ldd	r24, Z+45	; 0x2d
    14e4:	96 a5       	ldd	r25, Z+46	; 0x2e
    14e6:	a7 a5       	ldd	r26, Z+47	; 0x2f
    14e8:	b0 a9       	ldd	r27, Z+48	; 0x30
    14ea:	f8 01       	movw	r30, r16
    14ec:	80 83       	st	Z, r24
    14ee:	91 83       	std	Z+1, r25	; 0x01
    14f0:	a2 83       	std	Z+2, r26	; 0x02
    14f2:	b3 83       	std	Z+3, r27	; 0x03
    14f4:	ff ef       	ldi	r31, 0xFF	; 255
    14f6:	af 1a       	sub	r10, r31
    14f8:	bf 0a       	sbc	r11, r31
    14fa:	0c 5f       	subi	r16, 0xFC	; 252
    14fc:	1f 4f       	sbci	r17, 0xFF	; 255
    14fe:	24 e0       	ldi	r18, 0x04	; 4
    1500:	e2 0e       	add	r14, r18
    1502:	f1 1c       	adc	r15, r1
    1504:	34 e0       	ldi	r19, 0x04	; 4
    1506:	c3 0e       	add	r12, r19
    1508:	d1 1c       	adc	r13, r1
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    
      // Pre-calculate the coordinate data changes. NOTE: Uses parameter_data since coordinate_data may be in use by G54-59.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    150a:	83 e0       	ldi	r24, 0x03	; 3
    150c:	a8 16       	cp	r10, r24
    150e:	b1 04       	cpc	r11, r1
    1510:	09 f0       	breq	.+2      	; 0x1514 <gc_execute_line+0x8e8>
    1512:	b1 cf       	rjmp	.-158    	; 0x1476 <gc_execute_line+0x84a>
    1514:	56 c6       	rjmp	.+3244   	; 0x21c2 <gc_execute_line+0x1596>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1516:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1518:	99 23       	and	r25, r25
    151a:	09 f4       	brne	.+2      	; 0x151e <gc_execute_line+0x8f2>
    151c:	d4 c5       	rjmp	.+2984   	; 0x20c6 <gc_execute_line+0x149a>
    151e:	0f 2e       	mov	r0, r31
    1520:	fc e8       	ldi	r31, 0x8C	; 140
    1522:	cf 2e       	mov	r12, r31
    1524:	f5 e0       	ldi	r31, 0x05	; 5
    1526:	df 2e       	mov	r13, r31
    1528:	f0 2d       	mov	r31, r0
    152a:	de 01       	movw	r26, r28
    152c:	11 96       	adiw	r26, 0x01	; 1
    152e:	5d 01       	movw	r10, r26
    1530:	0f 2e       	mov	r0, r31
    1532:	fb ec       	ldi	r31, 0xCB	; 203
    1534:	ef 2e       	mov	r14, r31
    1536:	f5 e0       	ldi	r31, 0x05	; 5
    1538:	ff 2e       	mov	r15, r31
    153a:	f0 2d       	mov	r31, r0
    153c:	00 e0       	ldi	r16, 0x00	; 0
    153e:	10 e0       	ldi	r17, 0x00	; 0
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    1540:	89 2e       	mov	r8, r25
    1542:	91 2c       	mov	r9, r1
    1544:	c4 01       	movw	r24, r8
    1546:	00 2e       	mov	r0, r16
    1548:	02 c0       	rjmp	.+4      	; 0x154e <gc_execute_line+0x922>
    154a:	95 95       	asr	r25
    154c:	87 95       	ror	r24
    154e:	0a 94       	dec	r0
    1550:	e2 f7       	brpl	.-8      	; 0x154a <gc_execute_line+0x91e>
    1552:	80 ff       	sbrs	r24, 0
    1554:	3a c0       	rjmp	.+116    	; 0x15ca <gc_execute_line+0x99e>
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
    1556:	f5 01       	movw	r30, r10
    1558:	20 81       	ld	r18, Z
    155a:	31 81       	ldd	r19, Z+1	; 0x01
    155c:	42 81       	ldd	r20, Z+2	; 0x02
    155e:	53 81       	ldd	r21, Z+3	; 0x03
    1560:	d6 01       	movw	r26, r12
    1562:	57 96       	adiw	r26, 0x17	; 23
    1564:	6d 91       	ld	r22, X+
    1566:	7d 91       	ld	r23, X+
    1568:	8d 91       	ld	r24, X+
    156a:	9c 91       	ld	r25, X
    156c:	5a 97       	sbiw	r26, 0x1a	; 26
    156e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1572:	f7 01       	movw	r30, r14
    1574:	25 a5       	ldd	r18, Z+45	; 0x2d
    1576:	36 a5       	ldd	r19, Z+46	; 0x2e
    1578:	47 a5       	ldd	r20, Z+47	; 0x2f
    157a:	50 a9       	ldd	r21, Z+48	; 0x30
    157c:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1580:	d7 01       	movw	r26, r14
    1582:	9d 96       	adiw	r26, 0x2d	; 45
    1584:	6d 93       	st	X+, r22
    1586:	7d 93       	st	X+, r23
    1588:	8d 93       	st	X+, r24
    158a:	9c 93       	st	X, r25
    158c:	d0 97       	sbiw	r26, 0x30	; 48
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    158e:	02 30       	cpi	r16, 0x02	; 2
    1590:	31 f5       	brne	.+76     	; 0x15de <gc_execute_line+0x9b2>
    1592:	00 0f       	add	r16, r16
    1594:	11 1f       	adc	r17, r17
    1596:	00 0f       	add	r16, r16
    1598:	11 1f       	adc	r17, r17
    159a:	05 53       	subi	r16, 0x35	; 53
    159c:	1a 4f       	sbci	r17, 0xFA	; 250
    159e:	20 91 c7 05 	lds	r18, 0x05C7	; 0x8005c7 <gc_state+0x3b>
    15a2:	30 91 c8 05 	lds	r19, 0x05C8	; 0x8005c8 <gc_state+0x3c>
    15a6:	40 91 c9 05 	lds	r20, 0x05C9	; 0x8005c9 <gc_state+0x3d>
    15aa:	50 91 ca 05 	lds	r21, 0x05CA	; 0x8005ca <gc_state+0x3e>
    15ae:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    15b2:	f8 01       	movw	r30, r16
    15b4:	65 a7       	std	Z+45, r22	; 0x2d
    15b6:	76 a7       	std	Z+46, r23	; 0x2e
    15b8:	87 a7       	std	Z+47, r24	; 0x2f
    15ba:	90 ab       	std	Z+48, r25	; 0x30
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    15bc:	10 91 cc 05 	lds	r17, 0x05CC	; 0x8005cc <gc_block+0x1>
    15c0:	18 30       	cpi	r17, 0x08	; 8
    15c2:	09 f4       	brne	.+2      	; 0x15c6 <gc_execute_line+0x99a>
    15c4:	f2 c0       	rjmp	.+484    	; 0x17aa <gc_execute_line+0xb7e>
    15c6:	1f a2       	std	Y+39, r1	; 0x27
    15c8:	f7 c0       	rjmp	.+494    	; 0x17b8 <gc_execute_line+0xb8c>
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
          gc_block.values.xyz[idx] = gc_state.position[idx]-coordinate_data[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    15ca:	f6 01       	movw	r30, r12
    15cc:	87 a5       	ldd	r24, Z+47	; 0x2f
    15ce:	90 a9       	ldd	r25, Z+48	; 0x30
    15d0:	a1 a9       	ldd	r26, Z+49	; 0x31
    15d2:	b2 a9       	ldd	r27, Z+50	; 0x32
    15d4:	f7 01       	movw	r30, r14
    15d6:	85 a7       	std	Z+45, r24	; 0x2d
    15d8:	96 a7       	std	Z+46, r25	; 0x2e
    15da:	a7 a7       	std	Z+47, r26	; 0x2f
    15dc:	b0 ab       	std	Z+48, r27	; 0x30
    15de:	0f 5f       	subi	r16, 0xFF	; 255
    15e0:	1f 4f       	sbci	r17, 0xFF	; 255
    15e2:	f4 e0       	ldi	r31, 0x04	; 4
    15e4:	cf 0e       	add	r12, r31
    15e6:	d1 1c       	adc	r13, r1
    15e8:	24 e0       	ldi	r18, 0x04	; 4
    15ea:	a2 0e       	add	r10, r18
    15ec:	b1 1c       	adc	r11, r1
    15ee:	34 e0       	ldi	r19, 0x04	; 4
    15f0:	e3 0e       	add	r14, r19
    15f2:	f1 1c       	adc	r15, r1
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    
      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it. 
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    15f4:	03 30       	cpi	r16, 0x03	; 3
    15f6:	11 05       	cpc	r17, r1
    15f8:	09 f0       	breq	.+2      	; 0x15fc <gc_execute_line+0x9d0>
    15fa:	a4 cf       	rjmp	.-184    	; 0x1544 <gc_execute_line+0x918>

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    15fc:	1f a2       	std	Y+39, r1	; 0x27
    15fe:	e1 c5       	rjmp	.+3010   	; 0x21c2 <gc_execute_line+0x1596>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    1600:	8a a1       	ldd	r24, Y+34	; 0x22
    1602:	83 30       	cpi	r24, 0x03	; 3
    1604:	09 f4       	brne	.+2      	; 0x1608 <gc_execute_line+0x9dc>
    1606:	9b c0       	rjmp	.+310    	; 0x173e <gc_execute_line+0xb12>
        if (axis_words) {
    1608:	9e 8d       	ldd	r25, Y+30	; 0x1e
    160a:	99 23       	and	r25, r25
    160c:	09 f4       	brne	.+2      	; 0x1610 <gc_execute_line+0x9e4>
    160e:	cd c5       	rjmp	.+2970   	; 0x21aa <gc_execute_line+0x157e>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1610:	40 90 cf 05 	lds	r4, 0x05CF	; 0x8005cf <gc_block+0x4>
    1614:	0f 2e       	mov	r0, r31
    1616:	fc e8       	ldi	r31, 0x8C	; 140
    1618:	cf 2e       	mov	r12, r31
    161a:	f5 e0       	ldi	r31, 0x05	; 5
    161c:	df 2e       	mov	r13, r31
    161e:	f0 2d       	mov	r31, r0
    1620:	0f 2e       	mov	r0, r31
    1622:	fb ec       	ldi	r31, 0xCB	; 203
    1624:	ef 2e       	mov	r14, r31
    1626:	f5 e0       	ldi	r31, 0x05	; 5
    1628:	ff 2e       	mov	r15, r31
    162a:	f0 2d       	mov	r31, r0
    162c:	de 01       	movw	r26, r28
    162e:	11 96       	adiw	r26, 0x01	; 1
    1630:	5d 01       	movw	r10, r26
    1632:	00 e0       	ldi	r16, 0x00	; 0
    1634:	10 e0       	ldi	r17, 0x00	; 0
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1636:	29 2e       	mov	r2, r25
    1638:	31 2c       	mov	r3, r1
    163a:	c1 01       	movw	r24, r2
    163c:	00 2e       	mov	r0, r16
    163e:	02 c0       	rjmp	.+4      	; 0x1644 <gc_execute_line+0xa18>
    1640:	95 95       	asr	r25
    1642:	87 95       	ror	r24
    1644:	0a 94       	dec	r0
    1646:	e2 f7       	brpl	.-8      	; 0x1640 <gc_execute_line+0xa14>
    1648:	80 fd       	sbrc	r24, 0
    164a:	0b c0       	rjmp	.+22     	; 0x1662 <gc_execute_line+0xa36>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    164c:	f6 01       	movw	r30, r12
    164e:	87 89       	ldd	r24, Z+23	; 0x17
    1650:	90 8d       	ldd	r25, Z+24	; 0x18
    1652:	a1 8d       	ldd	r26, Z+25	; 0x19
    1654:	b2 8d       	ldd	r27, Z+26	; 0x1a
    1656:	f7 01       	movw	r30, r14
    1658:	85 a7       	std	Z+45, r24	; 0x2d
    165a:	96 a7       	std	Z+46, r25	; 0x2e
    165c:	a7 a7       	std	Z+47, r26	; 0x2f
    165e:	b0 ab       	std	Z+48, r27	; 0x30
    1660:	5e c0       	rjmp	.+188    	; 0x171e <gc_execute_line+0xaf2>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    1662:	f7 e0       	ldi	r31, 0x07	; 7
    1664:	5f 16       	cp	r5, r31
    1666:	09 f4       	brne	.+2      	; 0x166a <gc_execute_line+0xa3e>
    1668:	5a c0       	rjmp	.+180    	; 0x171e <gc_execute_line+0xaf2>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    166a:	41 10       	cpse	r4, r1
    166c:	43 c0       	rjmp	.+134    	; 0x16f4 <gc_execute_line+0xac8>
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
    166e:	d6 01       	movw	r26, r12
    1670:	9f 96       	adiw	r26, 0x2f	; 47
    1672:	2d 91       	ld	r18, X+
    1674:	3d 91       	ld	r19, X+
    1676:	4d 91       	ld	r20, X+
    1678:	5c 91       	ld	r21, X
    167a:	d2 97       	sbiw	r26, 0x32	; 50
    167c:	f5 01       	movw	r30, r10
    167e:	60 81       	ld	r22, Z
    1680:	71 81       	ldd	r23, Z+1	; 0x01
    1682:	82 81       	ldd	r24, Z+2	; 0x02
    1684:	93 81       	ldd	r25, Z+3	; 0x03
    1686:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    168a:	d7 01       	movw	r26, r14
    168c:	9d 96       	adiw	r26, 0x2d	; 45
    168e:	2d 91       	ld	r18, X+
    1690:	3d 91       	ld	r19, X+
    1692:	4d 91       	ld	r20, X+
    1694:	5c 91       	ld	r21, X
    1696:	d0 97       	sbiw	r26, 0x30	; 48
    1698:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    169c:	9b 01       	movw	r18, r22
    169e:	ac 01       	movw	r20, r24
    16a0:	f7 01       	movw	r30, r14
    16a2:	65 a7       	std	Z+45, r22	; 0x2d
    16a4:	76 a7       	std	Z+46, r23	; 0x2e
    16a6:	87 a7       	std	Z+47, r24	; 0x2f
    16a8:	90 ab       	std	Z+48, r25	; 0x30
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    16aa:	02 30       	cpi	r16, 0x02	; 2
    16ac:	c1 f5       	brne	.+112    	; 0x171e <gc_execute_line+0xaf2>
    16ae:	00 0f       	add	r16, r16
    16b0:	11 1f       	adc	r17, r17
    16b2:	00 0f       	add	r16, r16
    16b4:	11 1f       	adc	r17, r17
    16b6:	05 53       	subi	r16, 0x35	; 53
    16b8:	1a 4f       	sbci	r17, 0xFA	; 250
    16ba:	60 91 c7 05 	lds	r22, 0x05C7	; 0x8005c7 <gc_state+0x3b>
    16be:	70 91 c8 05 	lds	r23, 0x05C8	; 0x8005c8 <gc_state+0x3c>
    16c2:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <gc_state+0x3d>
    16c6:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <gc_state+0x3e>
    16ca:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    16ce:	d8 01       	movw	r26, r16
    16d0:	9d 96       	adiw	r26, 0x2d	; 45
    16d2:	6d 93       	st	X+, r22
    16d4:	7d 93       	st	X+, r23
    16d6:	8d 93       	st	X+, r24
    16d8:	9c 93       	st	X, r25
    16da:	d0 97       	sbiw	r26, 0x30	; 48
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    16dc:	b5 e0       	ldi	r27, 0x05	; 5
    16de:	5b 16       	cp	r5, r27
    16e0:	09 f4       	brne	.+2      	; 0x16e4 <gc_execute_line+0xab8>
    16e2:	46 c0       	rjmp	.+140    	; 0x1770 <gc_execute_line+0xb44>
    16e4:	e7 e0       	ldi	r30, 0x07	; 7
    16e6:	5e 16       	cp	r5, r30
    16e8:	09 f4       	brne	.+2      	; 0x16ec <gc_execute_line+0xac0>
    16ea:	50 c0       	rjmp	.+160    	; 0x178c <gc_execute_line+0xb60>
    16ec:	f3 e0       	ldi	r31, 0x03	; 3
    16ee:	5f 12       	cpse	r5, r31
    16f0:	52 c0       	rjmp	.+164    	; 0x1796 <gc_execute_line+0xb6a>
    16f2:	34 c0       	rjmp	.+104    	; 0x175c <gc_execute_line+0xb30>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
                  gc_block.values.xyz[idx] += coordinate_data[idx] + gc_state.coord_offset[idx];
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    16f4:	d6 01       	movw	r26, r12
    16f6:	57 96       	adiw	r26, 0x17	; 23
    16f8:	2d 91       	ld	r18, X+
    16fa:	3d 91       	ld	r19, X+
    16fc:	4d 91       	ld	r20, X+
    16fe:	5c 91       	ld	r21, X
    1700:	5a 97       	sbiw	r26, 0x1a	; 26
    1702:	f7 01       	movw	r30, r14
    1704:	65 a5       	ldd	r22, Z+45	; 0x2d
    1706:	76 a5       	ldd	r23, Z+46	; 0x2e
    1708:	87 a5       	ldd	r24, Z+47	; 0x2f
    170a:	90 a9       	ldd	r25, Z+48	; 0x30
    170c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    1710:	d7 01       	movw	r26, r14
    1712:	9d 96       	adiw	r26, 0x2d	; 45
    1714:	6d 93       	st	X+, r22
    1716:	7d 93       	st	X+, r23
    1718:	8d 93       	st	X+, r24
    171a:	9c 93       	st	X, r25
    171c:	d0 97       	sbiw	r26, 0x30	; 48
    171e:	0f 5f       	subi	r16, 0xFF	; 255
    1720:	1f 4f       	sbci	r17, 0xFF	; 255
    1722:	b4 e0       	ldi	r27, 0x04	; 4
    1724:	cb 0e       	add	r12, r27
    1726:	d1 1c       	adc	r13, r1
    1728:	e4 e0       	ldi	r30, 0x04	; 4
    172a:	ee 0e       	add	r14, r30
    172c:	f1 1c       	adc	r15, r1
    172e:	f4 e0       	ldi	r31, 0x04	; 4
    1730:	af 0e       	add	r10, r31
    1732:	b1 1c       	adc	r11, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1734:	03 30       	cpi	r16, 0x03	; 3
    1736:	11 05       	cpc	r17, r1
    1738:	09 f0       	breq	.+2      	; 0x173c <gc_execute_line+0xb10>
    173a:	7f cf       	rjmp	.-258    	; 0x163a <gc_execute_line+0xa0e>
    173c:	2a c5       	rjmp	.+2644   	; 0x2192 <gc_execute_line+0x1566>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    173e:	25 e0       	ldi	r18, 0x05	; 5
    1740:	52 16       	cp	r5, r18
    1742:	b1 f0       	breq	.+44     	; 0x1770 <gc_execute_line+0xb44>
    1744:	37 e0       	ldi	r19, 0x07	; 7
    1746:	53 16       	cp	r5, r19
    1748:	09 f1       	breq	.+66     	; 0x178c <gc_execute_line+0xb60>
    174a:	83 e0       	ldi	r24, 0x03	; 3
    174c:	58 12       	cpse	r5, r24
    174e:	23 c0       	rjmp	.+70     	; 0x1796 <gc_execute_line+0xb6a>
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    1750:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1752:	91 11       	cpse	r25, r1
    1754:	03 c0       	rjmp	.+6      	; 0x175c <gc_execute_line+0xb30>
    1756:	1a a2       	std	Y+34, r1	; 0x22
    1758:	01 c0       	rjmp	.+2      	; 0x175c <gc_execute_line+0xb30>
    175a:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    175c:	be 01       	movw	r22, r28
    175e:	63 5f       	subi	r22, 0xF3	; 243
    1760:	7f 4f       	sbci	r23, 0xFF	; 255
    1762:	86 e0       	ldi	r24, 0x06	; 6
    1764:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    1768:	88 23       	and	r24, r24
    176a:	09 f4       	brne	.+2      	; 0x176e <gc_execute_line+0xb42>
    176c:	ae c4       	rjmp	.+2396   	; 0x20ca <gc_execute_line+0x149e>
    176e:	13 c0       	rjmp	.+38     	; 0x1796 <gc_execute_line+0xb6a>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
    1770:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1772:	a1 11       	cpse	r26, r1
    1774:	01 c0       	rjmp	.+2      	; 0x1778 <gc_execute_line+0xb4c>
    1776:	1a a2       	std	Y+34, r1	; 0x22
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1778:	be 01       	movw	r22, r28
    177a:	63 5f       	subi	r22, 0xF3	; 243
    177c:	7f 4f       	sbci	r23, 0xFF	; 255
    177e:	87 e0       	ldi	r24, 0x07	; 7
    1780:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    1784:	88 23       	and	r24, r24
    1786:	09 f4       	brne	.+2      	; 0x178a <gc_execute_line+0xb5e>
    1788:	a2 c4       	rjmp	.+2372   	; 0x20ce <gc_execute_line+0x14a2>
    178a:	05 c0       	rjmp	.+10     	; 0x1796 <gc_execute_line+0xb6a>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    178c:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <gc_block+0x1>
    1790:	82 30       	cpi	r24, 0x02	; 2
    1792:	08 f0       	brcs	.+2      	; 0x1796 <gc_execute_line+0xb6a>
    1794:	9e c4       	rjmp	.+2364   	; 0x20d2 <gc_execute_line+0x14a6>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1796:	10 91 cc 05 	lds	r17, 0x05CC	; 0x8005cc <gc_block+0x1>
    179a:	18 30       	cpi	r17, 0x08	; 8
    179c:	61 f4       	brne	.+24     	; 0x17b6 <gc_execute_line+0xb8a>
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    179e:	be 8d       	ldd	r27, Y+30	; 0x1e
    17a0:	bb 23       	and	r27, r27
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <gc_execute_line+0xb7a>
    17a4:	2f c2       	rjmp	.+1118   	; 0x1c04 <gc_execute_line+0xfd8>
    17a6:	1f a2       	std	Y+39, r1	; 0x27
    17a8:	01 c0       	rjmp	.+2      	; 0x17ac <gc_execute_line+0xb80>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    17aa:	1f a2       	std	Y+39, r1	; 0x27
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
    17ac:	ea a1       	ldd	r30, Y+34	; 0x22
    17ae:	e1 30       	cpi	r30, 0x01	; 1
    17b0:	09 f0       	breq	.+2      	; 0x17b4 <gc_execute_line+0xb88>
    17b2:	91 c4       	rjmp	.+2338   	; 0x20d6 <gc_execute_line+0x14aa>
    17b4:	30 c2       	rjmp	.+1120   	; 0x1c16 <gc_execute_line+0xfea>
    17b6:	1f a2       	std	Y+39, r1	; 0x27
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    }

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or 
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    17b8:	fa a1       	ldd	r31, Y+34	; 0x22
    17ba:	f2 30       	cpi	r31, 0x02	; 2
    17bc:	09 f0       	breq	.+2      	; 0x17c0 <gc_execute_line+0xb94>
    17be:	23 c2       	rjmp	.+1094   	; 0x1c06 <gc_execute_line+0xfda>
  
    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    17c0:	11 11       	cpse	r17, r1
    17c2:	05 c0       	rjmp	.+10     	; 0x17ce <gc_execute_line+0xba2>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    17c4:	2e 8d       	ldd	r18, Y+30	; 0x1e
    17c6:	22 23       	and	r18, r18
    17c8:	09 f4       	brne	.+2      	; 0x17cc <gc_execute_line+0xba0>
    17ca:	01 c5       	rjmp	.+2562   	; 0x21ce <gc_execute_line+0x15a2>
    17cc:	24 c2       	rjmp	.+1096   	; 0x1c16 <gc_execute_line+0xfea>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    17ce:	20 e0       	ldi	r18, 0x00	; 0
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	a9 01       	movw	r20, r18
    17d4:	60 91 d6 05 	lds	r22, 0x05D6	; 0x8005d6 <gc_block+0xb>
    17d8:	70 91 d7 05 	lds	r23, 0x05D7	; 0x8005d7 <gc_block+0xc>
    17dc:	80 91 d8 05 	lds	r24, 0x05D8	; 0x8005d8 <gc_block+0xd>
    17e0:	90 91 d9 05 	lds	r25, 0x05D9	; 0x8005d9 <gc_block+0xe>
    17e4:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    17e8:	88 23       	and	r24, r24
    17ea:	09 f4       	brne	.+2      	; 0x17ee <gc_execute_line+0xbc2>
    17ec:	76 c4       	rjmp	.+2284   	; 0x20da <gc_execute_line+0x14ae>
     
      switch (gc_block.modal.motion) {
    17ee:	14 30       	cpi	r17, 0x04	; 4
    17f0:	28 f4       	brcc	.+10     	; 0x17fc <gc_execute_line+0xbd0>
    17f2:	12 30       	cpi	r17, 0x02	; 2
    17f4:	60 f4       	brcc	.+24     	; 0x180e <gc_execute_line+0xbe2>
    17f6:	11 30       	cpi	r17, 0x01	; 1
    17f8:	29 f0       	breq	.+10     	; 0x1804 <gc_execute_line+0xbd8>
    17fa:	05 c2       	rjmp	.+1034   	; 0x1c06 <gc_execute_line+0xfda>
    17fc:	18 30       	cpi	r17, 0x08	; 8
    17fe:	08 f4       	brcc	.+2      	; 0x1802 <gc_execute_line+0xbd6>
    1800:	f4 c1       	rjmp	.+1000   	; 0x1bea <gc_execute_line+0xfbe>
    1802:	01 c2       	rjmp	.+1026   	; 0x1c06 <gc_execute_line+0xfda>
        case MOTION_MODE_LINEAR: 
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1804:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1806:	33 23       	and	r19, r19
    1808:	09 f4       	brne	.+2      	; 0x180c <gc_execute_line+0xbe0>
    180a:	e1 c4       	rjmp	.+2498   	; 0x21ce <gc_execute_line+0x15a2>
    180c:	04 c2       	rjmp	.+1032   	; 0x1c16 <gc_execute_line+0xfea>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    180e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1810:	88 23       	and	r24, r24
    1812:	09 f4       	brne	.+2      	; 0x1816 <gc_execute_line+0xbea>
    1814:	64 c4       	rjmp	.+2248   	; 0x20de <gc_execute_line+0x14b2>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1816:	9c a1       	ldd	r25, Y+36	; 0x24
    1818:	a9 2e       	mov	r10, r25
    181a:	b1 2c       	mov	r11, r1
    181c:	ad a1       	ldd	r26, Y+37	; 0x25
    181e:	8a 2e       	mov	r8, r26
    1820:	91 2c       	mov	r9, r1
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	8c 01       	movw	r16, r24
    1828:	0c a0       	ldd	r0, Y+36	; 0x24
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <gc_execute_line+0xc04>
    182c:	00 0f       	add	r16, r16
    182e:	11 1f       	adc	r17, r17
    1830:	0a 94       	dec	r0
    1832:	e2 f7       	brpl	.-8      	; 0x182c <gc_execute_line+0xc00>
    1834:	02 c0       	rjmp	.+4      	; 0x183a <gc_execute_line+0xc0e>
    1836:	88 0f       	add	r24, r24
    1838:	99 1f       	adc	r25, r25
    183a:	aa 95       	dec	r26
    183c:	e2 f7       	brpl	.-8      	; 0x1836 <gc_execute_line+0xc0a>
    183e:	08 2b       	or	r16, r24
    1840:	19 2b       	or	r17, r25
    1842:	be 8d       	ldd	r27, Y+30	; 0x1e
    1844:	8b 2f       	mov	r24, r27
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	80 23       	and	r24, r16
    184a:	91 23       	and	r25, r17
    184c:	89 2b       	or	r24, r25
    184e:	09 f4       	brne	.+2      	; 0x1852 <gc_execute_line+0xc26>
    1850:	48 c4       	rjmp	.+2192   	; 0x20e2 <gc_execute_line+0x14b6>
        
          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    1852:	c5 01       	movw	r24, r10
    1854:	88 0f       	add	r24, r24
    1856:	99 1f       	adc	r25, r25
    1858:	88 0f       	add	r24, r24
    185a:	99 1f       	adc	r25, r25
    185c:	fc 01       	movw	r30, r24
    185e:	e5 53       	subi	r30, 0x35	; 53
    1860:	fa 4f       	sbci	r31, 0xFA	; 250
    1862:	dc 01       	movw	r26, r24
    1864:	a4 57       	subi	r26, 0x74	; 116
    1866:	ba 4f       	sbci	r27, 0xFA	; 250
    1868:	57 96       	adiw	r26, 0x17	; 23
    186a:	2d 91       	ld	r18, X+
    186c:	3d 91       	ld	r19, X+
    186e:	4d 91       	ld	r20, X+
    1870:	5c 91       	ld	r21, X
    1872:	5a 97       	sbiw	r26, 0x1a	; 26
    1874:	65 a5       	ldd	r22, Z+45	; 0x2d
    1876:	76 a5       	ldd	r23, Z+46	; 0x2e
    1878:	87 a5       	ldd	r24, Z+47	; 0x2f
    187a:	90 a9       	ldd	r25, Z+48	; 0x30
    187c:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1880:	6e 8f       	std	Y+30, r22	; 0x1e
    1882:	7f 8f       	std	Y+31, r23	; 0x1f
    1884:	88 a3       	std	Y+32, r24	; 0x20
    1886:	99 a3       	std	Y+33, r25	; 0x21
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    1888:	c4 01       	movw	r24, r8
    188a:	88 0f       	add	r24, r24
    188c:	99 1f       	adc	r25, r25
    188e:	88 0f       	add	r24, r24
    1890:	99 1f       	adc	r25, r25
    1892:	fc 01       	movw	r30, r24
    1894:	e5 53       	subi	r30, 0x35	; 53
    1896:	fa 4f       	sbci	r31, 0xFA	; 250
    1898:	dc 01       	movw	r26, r24
    189a:	a4 57       	subi	r26, 0x74	; 116
    189c:	ba 4f       	sbci	r27, 0xFA	; 250
    189e:	57 96       	adiw	r26, 0x17	; 23
    18a0:	2d 91       	ld	r18, X+
    18a2:	3d 91       	ld	r19, X+
    18a4:	4d 91       	ld	r20, X+
    18a6:	5c 91       	ld	r21, X
    18a8:	5a 97       	sbiw	r26, 0x1a	; 26
    18aa:	65 a5       	ldd	r22, Z+45	; 0x2d
    18ac:	76 a5       	ldd	r23, Z+46	; 0x2e
    18ae:	87 a5       	ldd	r24, Z+47	; 0x2f
    18b0:	90 a9       	ldd	r25, Z+48	; 0x30
    18b2:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    18b6:	68 a7       	std	Y+40, r22	; 0x28
    18b8:	79 a7       	std	Y+41, r23	; 0x29
    18ba:	8a a7       	std	Y+42, r24	; 0x2a
    18bc:	9b a7       	std	Y+43, r25	; 0x2b

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
    18be:	67 fe       	sbrs	r6, 7
    18c0:	e6 c0       	rjmp	.+460    	; 0x1a8e <gc_execute_line+0xe62>
            bit_false(value_words,bit(WORD_R));
    18c2:	e8 94       	clt
    18c4:	67 f8       	bld	r6, 7
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    18c6:	68 ef       	ldi	r22, 0xF8	; 248
    18c8:	75 e0       	ldi	r23, 0x05	; 5
    18ca:	83 ea       	ldi	r24, 0xA3	; 163
    18cc:	95 e0       	ldi	r25, 0x05	; 5
    18ce:	0e 94 d5 05 	call	0xbaa	; 0xbaa <gc_check_same_position>
    18d2:	81 11       	cpse	r24, r1
    18d4:	08 c4       	rjmp	.+2064   	; 0x20e6 <gc_execute_line+0x14ba>
          
            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    18d6:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <gc_block+0x3>
    18da:	81 30       	cpi	r24, 0x01	; 1
    18dc:	a1 f4       	brne	.+40     	; 0x1906 <gc_execute_line+0xcda>
    18de:	0b ec       	ldi	r16, 0xCB	; 203
    18e0:	15 e0       	ldi	r17, 0x05	; 5
    18e2:	23 e3       	ldi	r18, 0x33	; 51
    18e4:	33 e3       	ldi	r19, 0x33	; 51
    18e6:	4b ec       	ldi	r20, 0xCB	; 203
    18e8:	51 e4       	ldi	r21, 0x41	; 65
    18ea:	f8 01       	movw	r30, r16
    18ec:	64 a1       	ldd	r22, Z+36	; 0x24
    18ee:	75 a1       	ldd	r23, Z+37	; 0x25
    18f0:	86 a1       	ldd	r24, Z+38	; 0x26
    18f2:	97 a1       	ldd	r25, Z+39	; 0x27
    18f4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    18f8:	d8 01       	movw	r26, r16
    18fa:	94 96       	adiw	r26, 0x24	; 36
    18fc:	6d 93       	st	X+, r22
    18fe:	7d 93       	st	X+, r23
    1900:	8d 93       	st	X+, r24
    1902:	9c 93       	st	X, r25
    1904:	97 97       	sbiw	r26, 0x27	; 39
                j = (y + (x * h_x2_div_d))/2       
            */      

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1906:	c0 90 ef 05 	lds	r12, 0x05EF	; 0x8005ef <gc_block+0x24>
    190a:	d0 90 f0 05 	lds	r13, 0x05F0	; 0x8005f0 <gc_block+0x25>
    190e:	e0 90 f1 05 	lds	r14, 0x05F1	; 0x8005f1 <gc_block+0x26>
    1912:	f0 90 f2 05 	lds	r15, 0x05F2	; 0x8005f2 <gc_block+0x27>
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	30 e0       	ldi	r19, 0x00	; 0
    191a:	40 e8       	ldi	r20, 0x80	; 128
    191c:	50 e4       	ldi	r21, 0x40	; 64
    191e:	c7 01       	movw	r24, r14
    1920:	b6 01       	movw	r22, r12
    1922:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1926:	a7 01       	movw	r20, r14
    1928:	96 01       	movw	r18, r12
    192a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    192e:	6b 01       	movw	r12, r22
    1930:	7c 01       	movw	r14, r24
    1932:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1934:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1936:	48 a1       	ldd	r20, Y+32	; 0x20
    1938:	59 a1       	ldd	r21, Y+33	; 0x21
    193a:	ca 01       	movw	r24, r20
    193c:	b9 01       	movw	r22, r18
    193e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1942:	9b 01       	movw	r18, r22
    1944:	ac 01       	movw	r20, r24
    1946:	c7 01       	movw	r24, r14
    1948:	b6 01       	movw	r22, r12
    194a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    194e:	6b 01       	movw	r12, r22
    1950:	7c 01       	movw	r14, r24
    1952:	28 a5       	ldd	r18, Y+40	; 0x28
    1954:	39 a5       	ldd	r19, Y+41	; 0x29
    1956:	4a a5       	ldd	r20, Y+42	; 0x2a
    1958:	5b a5       	ldd	r21, Y+43	; 0x2b
    195a:	ca 01       	movw	r24, r20
    195c:	b9 01       	movw	r22, r18
    195e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1962:	9b 01       	movw	r18, r22
    1964:	ac 01       	movw	r20, r24
    1966:	c7 01       	movw	r24, r14
    1968:	b6 01       	movw	r22, r12
    196a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    196e:	6b 01       	movw	r12, r22
    1970:	7c 01       	movw	r14, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    1972:	20 e0       	ldi	r18, 0x00	; 0
    1974:	30 e0       	ldi	r19, 0x00	; 0
    1976:	a9 01       	movw	r20, r18
    1978:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    197c:	88 23       	and	r24, r24
    197e:	0c f4       	brge	.+2      	; 0x1982 <gc_execute_line+0xd56>
    1980:	b4 c3       	rjmp	.+1896   	; 0x20ea <gc_execute_line+0x14be>
    
            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    1982:	c7 01       	movw	r24, r14
    1984:	b6 01       	movw	r22, r12
    1986:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    198a:	6b 01       	movw	r12, r22
    198c:	7c 01       	movw	r14, r24
    198e:	28 a5       	ldd	r18, Y+40	; 0x28
    1990:	39 a5       	ldd	r19, Y+41	; 0x29
    1992:	4a a5       	ldd	r20, Y+42	; 0x2a
    1994:	5b a5       	ldd	r21, Y+43	; 0x2b
    1996:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1998:	7f 8d       	ldd	r23, Y+31	; 0x1f
    199a:	88 a1       	ldd	r24, Y+32	; 0x20
    199c:	99 a1       	ldd	r25, Y+33	; 0x21
    199e:	0e 94 47 19 	call	0x328e	; 0x328e <hypot_f>
    19a2:	9b 01       	movw	r18, r22
    19a4:	ac 01       	movw	r20, r24
    19a6:	c7 01       	movw	r24, r14
    19a8:	b6 01       	movw	r22, r12
    19aa:	90 58       	subi	r25, 0x80	; 128
    19ac:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    19b0:	6b 01       	movw	r12, r22
    19b2:	7c 01       	movw	r14, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }  
    19b4:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <gc_block+0x1>
    19b8:	83 30       	cpi	r24, 0x03	; 3
    19ba:	21 f4       	brne	.+8      	; 0x19c4 <gc_execute_line+0xd98>
    19bc:	f7 fa       	bst	r15, 7
    19be:	f0 94       	com	r15
    19c0:	f7 f8       	bld	r15, 7
    19c2:	f0 94       	com	r15
            */  
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!), 
            // even though it is advised against ever generating such circles in a single line of g-code. By 
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) { 
    19c4:	20 90 ef 05 	lds	r2, 0x05EF	; 0x8005ef <gc_block+0x24>
    19c8:	30 90 f0 05 	lds	r3, 0x05F0	; 0x8005f0 <gc_block+0x25>
    19cc:	40 90 f1 05 	lds	r4, 0x05F1	; 0x8005f1 <gc_block+0x26>
    19d0:	50 90 f2 05 	lds	r5, 0x05F2	; 0x8005f2 <gc_block+0x27>
    19d4:	20 e0       	ldi	r18, 0x00	; 0
    19d6:	30 e0       	ldi	r19, 0x00	; 0
    19d8:	a9 01       	movw	r20, r18
    19da:	c2 01       	movw	r24, r4
    19dc:	b1 01       	movw	r22, r2
    19de:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    19e2:	88 23       	and	r24, r24
    19e4:	7c f4       	brge	.+30     	; 0x1a04 <gc_execute_line+0xdd8>
                h_x2_div_d = -h_x2_div_d; 
    19e6:	f7 fa       	bst	r15, 7
    19e8:	f0 94       	com	r15
    19ea:	f7 f8       	bld	r15, 7
    19ec:	f0 94       	com	r15
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    19ee:	d2 01       	movw	r26, r4
    19f0:	c1 01       	movw	r24, r2
    19f2:	b0 58       	subi	r27, 0x80	; 128
    19f4:	80 93 ef 05 	sts	0x05EF, r24	; 0x8005ef <gc_block+0x24>
    19f8:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <gc_block+0x25>
    19fc:	a0 93 f1 05 	sts	0x05F1, r26	; 0x8005f1 <gc_block+0x26>
    1a00:	b0 93 f2 05 	sts	0x05F2, r27	; 0x8005f2 <gc_block+0x27>
            }        
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1a04:	85 01       	movw	r16, r10
    1a06:	00 0f       	add	r16, r16
    1a08:	11 1f       	adc	r17, r17
    1a0a:	00 0f       	add	r16, r16
    1a0c:	11 1f       	adc	r17, r17
    1a0e:	01 53       	subi	r16, 0x31	; 49
    1a10:	1a 4f       	sbci	r17, 0xFA	; 250
    1a12:	28 a5       	ldd	r18, Y+40	; 0x28
    1a14:	39 a5       	ldd	r19, Y+41	; 0x29
    1a16:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a18:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a1a:	c7 01       	movw	r24, r14
    1a1c:	b6 01       	movw	r22, r12
    1a1e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1a22:	9b 01       	movw	r18, r22
    1a24:	ac 01       	movw	r20, r24
    1a26:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1a28:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1a2a:	88 a1       	ldd	r24, Y+32	; 0x20
    1a2c:	99 a1       	ldd	r25, Y+33	; 0x21
    1a2e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1a32:	20 e0       	ldi	r18, 0x00	; 0
    1a34:	30 e0       	ldi	r19, 0x00	; 0
    1a36:	40 e0       	ldi	r20, 0x00	; 0
    1a38:	5f e3       	ldi	r21, 0x3F	; 63
    1a3a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1a3e:	f8 01       	movw	r30, r16
    1a40:	63 87       	std	Z+11, r22	; 0x0b
    1a42:	74 87       	std	Z+12, r23	; 0x0c
    1a44:	85 87       	std	Z+13, r24	; 0x0d
    1a46:	96 87       	std	Z+14, r25	; 0x0e
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    1a48:	84 01       	movw	r16, r8
    1a4a:	00 0f       	add	r16, r16
    1a4c:	11 1f       	adc	r17, r17
    1a4e:	00 0f       	add	r16, r16
    1a50:	11 1f       	adc	r17, r17
    1a52:	01 53       	subi	r16, 0x31	; 49
    1a54:	1a 4f       	sbci	r17, 0xFA	; 250
    1a56:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1a58:	3f 8d       	ldd	r19, Y+31	; 0x1f
    1a5a:	48 a1       	ldd	r20, Y+32	; 0x20
    1a5c:	59 a1       	ldd	r21, Y+33	; 0x21
    1a5e:	c7 01       	movw	r24, r14
    1a60:	b6 01       	movw	r22, r12
    1a62:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1a66:	28 a5       	ldd	r18, Y+40	; 0x28
    1a68:	39 a5       	ldd	r19, Y+41	; 0x29
    1a6a:	4a a5       	ldd	r20, Y+42	; 0x2a
    1a6c:	5b a5       	ldd	r21, Y+43	; 0x2b
    1a6e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    1a72:	20 e0       	ldi	r18, 0x00	; 0
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	40 e0       	ldi	r20, 0x00	; 0
    1a78:	5f e3       	ldi	r21, 0x3F	; 63
    1a7a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1a7e:	d8 01       	movw	r26, r16
    1a80:	1b 96       	adiw	r26, 0x0b	; 11
    1a82:	6d 93       	st	X+, r22
    1a84:	7d 93       	st	X+, r23
    1a86:	8d 93       	st	X+, r24
    1a88:	9c 93       	st	X, r25
    1a8a:	1e 97       	sbiw	r26, 0x0e	; 14
    1a8c:	c4 c0       	rjmp	.+392    	; 0x1c16 <gc_execute_line+0xfea>
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    1a8e:	bb a1       	ldd	r27, Y+35	; 0x23
    1a90:	cb 2e       	mov	r12, r27
    1a92:	d1 2c       	mov	r13, r1
    1a94:	0c 21       	and	r16, r12
    1a96:	1d 21       	and	r17, r13
    1a98:	01 2b       	or	r16, r17
    1a9a:	09 f4       	brne	.+2      	; 0x1a9e <gc_execute_line+0xe72>
    1a9c:	28 c3       	rjmp	.+1616   	; 0x20ee <gc_execute_line+0x14c2>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
    1a9e:	e1 ef       	ldi	r30, 0xF1	; 241
    1aa0:	6e 22       	and	r6, r30
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    1aa2:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <gc_block+0x3>
    1aa6:	81 30       	cpi	r24, 0x01	; 1
    1aa8:	41 f5       	brne	.+80     	; 0x1afa <gc_execute_line+0xece>
    1aaa:	0b ec       	ldi	r16, 0xCB	; 203
    1aac:	15 e0       	ldi	r17, 0x05	; 5
    1aae:	e1 2c       	mov	r14, r1
    1ab0:	f1 2c       	mov	r15, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    1ab2:	c6 01       	movw	r24, r12
    1ab4:	0e 2c       	mov	r0, r14
    1ab6:	02 c0       	rjmp	.+4      	; 0x1abc <gc_execute_line+0xe90>
    1ab8:	95 95       	asr	r25
    1aba:	87 95       	ror	r24
    1abc:	0a 94       	dec	r0
    1abe:	e2 f7       	brpl	.-8      	; 0x1ab8 <gc_execute_line+0xe8c>
    1ac0:	80 ff       	sbrs	r24, 0
    1ac2:	12 c0       	rjmp	.+36     	; 0x1ae8 <gc_execute_line+0xebc>
    1ac4:	23 e3       	ldi	r18, 0x33	; 51
    1ac6:	33 e3       	ldi	r19, 0x33	; 51
    1ac8:	4b ec       	ldi	r20, 0xCB	; 203
    1aca:	51 e4       	ldi	r21, 0x41	; 65
    1acc:	d8 01       	movw	r26, r16
    1ace:	1f 96       	adiw	r26, 0x0f	; 15
    1ad0:	6d 91       	ld	r22, X+
    1ad2:	7d 91       	ld	r23, X+
    1ad4:	8d 91       	ld	r24, X+
    1ad6:	9c 91       	ld	r25, X
    1ad8:	52 97       	sbiw	r26, 0x12	; 18
    1ada:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1ade:	f8 01       	movw	r30, r16
    1ae0:	67 87       	std	Z+15, r22	; 0x0f
    1ae2:	70 8b       	std	Z+16, r23	; 0x10
    1ae4:	81 8b       	std	Z+17, r24	; 0x11
    1ae6:	92 8b       	std	Z+18, r25	; 0x12
    1ae8:	ff ef       	ldi	r31, 0xFF	; 255
    1aea:	ef 1a       	sub	r14, r31
    1aec:	ff 0a       	sbc	r15, r31
    1aee:	0c 5f       	subi	r16, 0xFC	; 252
    1af0:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));  
          
            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1af2:	23 e0       	ldi	r18, 0x03	; 3
    1af4:	e2 16       	cp	r14, r18
    1af6:	f1 04       	cpc	r15, r1
    1af8:	e1 f6       	brne	.-72     	; 0x1ab2 <gc_execute_line+0xe86>
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1afa:	c4 01       	movw	r24, r8
    1afc:	88 0f       	add	r24, r24
    1afe:	99 1f       	adc	r25, r25
    1b00:	88 0f       	add	r24, r24
    1b02:	99 1f       	adc	r25, r25
    1b04:	dc 01       	movw	r26, r24
    1b06:	a1 53       	subi	r26, 0x31	; 49
    1b08:	ba 4f       	sbci	r27, 0xFA	; 250
    1b0a:	7d 01       	movw	r14, r26
            float target_r = hypot_f(x,y); 
    1b0c:	1b 96       	adiw	r26, 0x0b	; 11
    1b0e:	2d 91       	ld	r18, X+
    1b10:	3d 91       	ld	r19, X+
    1b12:	4d 91       	ld	r20, X+
    1b14:	5c 91       	ld	r21, X
    1b16:	1e 97       	sbiw	r26, 0x0e	; 14
    1b18:	68 a5       	ldd	r22, Y+40	; 0x28
    1b1a:	79 a5       	ldd	r23, Y+41	; 0x29
    1b1c:	8a a5       	ldd	r24, Y+42	; 0x2a
    1b1e:	9b a5       	ldd	r25, Y+43	; 0x2b
    1b20:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1b24:	1b 01       	movw	r2, r22
    1b26:	2c 01       	movw	r4, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }         

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    1b28:	85 01       	movw	r16, r10
    1b2a:	00 0f       	add	r16, r16
    1b2c:	11 1f       	adc	r17, r17
    1b2e:	00 0f       	add	r16, r16
    1b30:	11 1f       	adc	r17, r17
    1b32:	01 53       	subi	r16, 0x31	; 49
    1b34:	1a 4f       	sbci	r17, 0xFA	; 250
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y); 
    1b36:	f8 01       	movw	r30, r16
    1b38:	23 85       	ldd	r18, Z+11	; 0x0b
    1b3a:	34 85       	ldd	r19, Z+12	; 0x0c
    1b3c:	45 85       	ldd	r20, Z+13	; 0x0d
    1b3e:	56 85       	ldd	r21, Z+14	; 0x0e
    1b40:	6e 8d       	ldd	r22, Y+30	; 0x1e
    1b42:	7f 8d       	ldd	r23, Y+31	; 0x1f
    1b44:	88 a1       	ldd	r24, Y+32	; 0x20
    1b46:	99 a1       	ldd	r25, Y+33	; 0x21
    1b48:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1b4c:	a2 01       	movw	r20, r4
    1b4e:	91 01       	movw	r18, r2
    1b50:	0e 94 47 19 	call	0x328e	; 0x328e <hypot_f>
    1b54:	4b 01       	movw	r8, r22
    1b56:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
    1b58:	d7 01       	movw	r26, r14
    1b5a:	1b 96       	adiw	r26, 0x0b	; 11
    1b5c:	2d 91       	ld	r18, X+
    1b5e:	3d 91       	ld	r19, X+
    1b60:	4d 91       	ld	r20, X+
    1b62:	5c 91       	ld	r21, X
    1b64:	1e 97       	sbiw	r26, 0x0e	; 14
    1b66:	f8 01       	movw	r30, r16
    1b68:	63 85       	ldd	r22, Z+11	; 0x0b
    1b6a:	74 85       	ldd	r23, Z+12	; 0x0c
    1b6c:	85 85       	ldd	r24, Z+13	; 0x0d
    1b6e:	96 85       	ldd	r25, Z+14	; 0x0e
    1b70:	0e 94 47 19 	call	0x328e	; 0x328e <hypot_f>
    1b74:	6b 01       	movw	r12, r22
    1b76:	7c 01       	movw	r14, r24
    1b78:	60 93 ef 05 	sts	0x05EF, r22	; 0x8005ef <gc_block+0x24>
    1b7c:	70 93 f0 05 	sts	0x05F0, r23	; 0x8005f0 <gc_block+0x25>
    1b80:	80 93 f1 05 	sts	0x05F1, r24	; 0x8005f1 <gc_block+0x26>
    1b84:	90 93 f2 05 	sts	0x05F2, r25	; 0x8005f2 <gc_block+0x27>
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    1b88:	9b 01       	movw	r18, r22
    1b8a:	ac 01       	movw	r20, r24
    1b8c:	c5 01       	movw	r24, r10
    1b8e:	b4 01       	movw	r22, r8
    1b90:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    1b94:	4b 01       	movw	r8, r22
    1b96:	5c 01       	movw	r10, r24
    1b98:	e8 94       	clt
    1b9a:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) { 
    1b9c:	2a e0       	ldi	r18, 0x0A	; 10
    1b9e:	37 ed       	ldi	r19, 0xD7	; 215
    1ba0:	43 ea       	ldi	r20, 0xA3	; 163
    1ba2:	5b e3       	ldi	r21, 0x3B	; 59
    1ba4:	c5 01       	movw	r24, r10
    1ba6:	b4 01       	movw	r22, r8
    1ba8:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    1bac:	18 16       	cp	r1, r24
    1bae:	9c f5       	brge	.+102    	; 0x1c16 <gc_execute_line+0xfea>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1bb0:	20 e0       	ldi	r18, 0x00	; 0
    1bb2:	30 e0       	ldi	r19, 0x00	; 0
    1bb4:	40 e0       	ldi	r20, 0x00	; 0
    1bb6:	5f e3       	ldi	r21, 0x3F	; 63
    1bb8:	c5 01       	movw	r24, r10
    1bba:	b4 01       	movw	r22, r8
    1bbc:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    1bc0:	18 16       	cp	r1, r24
    1bc2:	0c f4       	brge	.+2      	; 0x1bc6 <gc_execute_line+0xf9a>
    1bc4:	96 c2       	rjmp	.+1324   	; 0x20f2 <gc_execute_line+0x14c6>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1bc6:	2f e6       	ldi	r18, 0x6F	; 111
    1bc8:	32 e1       	ldi	r19, 0x12	; 18
    1bca:	43 e8       	ldi	r20, 0x83	; 131
    1bcc:	5a e3       	ldi	r21, 0x3A	; 58
    1bce:	c7 01       	movw	r24, r14
    1bd0:	b6 01       	movw	r22, r12
    1bd2:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    1bd6:	9b 01       	movw	r18, r22
    1bd8:	ac 01       	movw	r20, r24
    1bda:	c5 01       	movw	r24, r10
    1bdc:	b4 01       	movw	r22, r8
    1bde:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    1be2:	18 16       	cp	r1, r24
    1be4:	0c f4       	brge	.+2      	; 0x1be8 <gc_execute_line+0xfbc>
    1be6:	87 c2       	rjmp	.+1294   	; 0x20f6 <gc_execute_line+0x14ca>
    1be8:	16 c0       	rjmp	.+44     	; 0x1c16 <gc_execute_line+0xfea>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1bea:	fe 8d       	ldd	r31, Y+30	; 0x1e
    1bec:	ff 23       	and	r31, r31
    1bee:	09 f4       	brne	.+2      	; 0x1bf2 <gc_execute_line+0xfc6>
    1bf0:	84 c2       	rjmp	.+1288   	; 0x20fa <gc_execute_line+0x14ce>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1bf2:	68 ef       	ldi	r22, 0xF8	; 248
    1bf4:	75 e0       	ldi	r23, 0x05	; 5
    1bf6:	83 ea       	ldi	r24, 0xA3	; 163
    1bf8:	95 e0       	ldi	r25, 0x05	; 5
    1bfa:	0e 94 d5 05 	call	0xbaa	; 0xbaa <gc_check_same_position>
    1bfe:	81 11       	cpse	r24, r1
    1c00:	7e c2       	rjmp	.+1276   	; 0x20fe <gc_execute_line+0x14d2>
    1c02:	09 c0       	rjmp	.+18     	; 0x1c16 <gc_execute_line+0xfea>
    1c04:	1f a2       	std	Y+39, r1	; 0x27
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1c06:	2a a1       	ldd	r18, Y+34	; 0x22
    1c08:	21 11       	cpse	r18, r1
    1c0a:	05 c0       	rjmp	.+10     	; 0x1c16 <gc_execute_line+0xfea>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    1c0c:	3e ed       	ldi	r19, 0xDE	; 222
    1c0e:	63 22       	and	r6, r19
    1c10:	3c ef       	ldi	r19, 0xFC	; 252
    1c12:	73 22       	and	r7, r19
    1c14:	04 c0       	rjmp	.+8      	; 0x1c1e <gc_execute_line+0xff2>
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
    1c16:	8e ed       	ldi	r24, 0xDE	; 222
    1c18:	68 22       	and	r6, r24
    1c1a:	80 ee       	ldi	r24, 0xE0	; 224
    1c1c:	78 22       	and	r7, r24
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1c1e:	67 28       	or	r6, r7
    1c20:	09 f0       	breq	.+2      	; 0x1c24 <gc_execute_line+0xff8>
    1c22:	6f c2       	rjmp	.+1246   	; 0x2102 <gc_execute_line+0x14d6>
     Assumes that all error-checking has been completed and no failure modes exist. We just
     need to update the state and execute the block according to the order-of-execution.
  */ 
  
  // [0. Non-specific/common error-checks and miscellaneous setup]: 
  gc_state.line_number = gc_block.values.n;
    1c24:	ec e8       	ldi	r30, 0x8C	; 140
    1c26:	f5 e0       	ldi	r31, 0x05	; 5
    1c28:	ab ec       	ldi	r26, 0xCB	; 203
    1c2a:	b5 e0       	ldi	r27, 0x05	; 5
    1c2c:	5c 96       	adiw	r26, 0x1c	; 28
    1c2e:	4d 91       	ld	r20, X+
    1c30:	5d 91       	ld	r21, X+
    1c32:	6d 91       	ld	r22, X+
    1c34:	7c 91       	ld	r23, X
    1c36:	5f 97       	sbiw	r26, 0x1f	; 31
    1c38:	43 8b       	std	Z+19, r20	; 0x13
    1c3a:	54 8b       	std	Z+20, r21	; 0x14
    1c3c:	65 8b       	std	Z+21, r22	; 0x15
    1c3e:	76 8b       	std	Z+22, r23	; 0x16
  
  // [1. Comments feedback ]:  NOT SUPPORTED
  
  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1c40:	12 96       	adiw	r26, 0x02	; 2
    1c42:	8c 91       	ld	r24, X
    1c44:	12 97       	sbiw	r26, 0x02	; 2
    1c46:	81 83       	std	Z+1, r24	; 0x01
  
  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1c48:	1b 96       	adiw	r26, 0x0b	; 11
    1c4a:	4d 91       	ld	r20, X+
    1c4c:	5d 91       	ld	r21, X+
    1c4e:	6d 91       	ld	r22, X+
    1c50:	7c 91       	ld	r23, X
    1c52:	1e 97       	sbiw	r26, 0x0e	; 14
    1c54:	46 87       	std	Z+14, r20	; 0x0e
    1c56:	57 87       	std	Z+15, r21	; 0x0f
    1c58:	60 8b       	std	Z+16, r22	; 0x10
    1c5a:	71 8b       	std	Z+17, r23	; 0x11

  // [4. Set spindle speed ]:
  if (gc_state.spindle_speed != gc_block.values.s) { 
    1c5c:	98 96       	adiw	r26, 0x28	; 40
    1c5e:	cd 90       	ld	r12, X+
    1c60:	dd 90       	ld	r13, X+
    1c62:	ed 90       	ld	r14, X+
    1c64:	fc 90       	ld	r15, X
    1c66:	9b 97       	sbiw	r26, 0x2b	; 43
    1c68:	a7 01       	movw	r20, r14
    1c6a:	96 01       	movw	r18, r12
    1c6c:	62 85       	ldd	r22, Z+10	; 0x0a
    1c6e:	73 85       	ldd	r23, Z+11	; 0x0b
    1c70:	84 85       	ldd	r24, Z+12	; 0x0c
    1c72:	95 85       	ldd	r25, Z+13	; 0x0d
    1c74:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    1c78:	88 23       	and	r24, r24
    1c7a:	c1 f0       	breq	.+48     	; 0x1cac <gc_execute_line+0x1080>
    // Update running spindle only if not in check mode and not already enabled.
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { spindle_run(gc_state.modal.spindle, gc_block.values.s); }
    1c7c:	80 91 95 05 	lds	r24, 0x0595	; 0x800595 <gc_state+0x9>
    1c80:	88 23       	and	r24, r24
    1c82:	21 f0       	breq	.+8      	; 0x1c8c <gc_execute_line+0x1060>
    1c84:	b7 01       	movw	r22, r14
    1c86:	a6 01       	movw	r20, r12
    1c88:	0e 94 2c 2c 	call	0x5858	; 0x5858 <spindle_run>
    gc_state.spindle_speed = gc_block.values.s; 
    1c8c:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x28>
    1c90:	90 91 f4 05 	lds	r25, 0x05F4	; 0x8005f4 <gc_block+0x29>
    1c94:	a0 91 f5 05 	lds	r26, 0x05F5	; 0x8005f5 <gc_block+0x2a>
    1c98:	b0 91 f6 05 	lds	r27, 0x05F6	; 0x8005f6 <gc_block+0x2b>
    1c9c:	80 93 96 05 	sts	0x0596, r24	; 0x800596 <gc_state+0xa>
    1ca0:	90 93 97 05 	sts	0x0597, r25	; 0x800597 <gc_state+0xb>
    1ca4:	a0 93 98 05 	sts	0x0598, r26	; 0x800598 <gc_state+0xc>
    1ca8:	b0 93 99 05 	sts	0x0599, r27	; 0x800599 <gc_state+0xd>
  }
    
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1cac:	ec e8       	ldi	r30, 0x8C	; 140
    1cae:	f5 e0       	ldi	r31, 0x05	; 5
    1cb0:	ab ec       	ldi	r26, 0xCB	; 203
    1cb2:	b5 e0       	ldi	r27, 0x05	; 5
    1cb4:	9c 96       	adiw	r26, 0x2c	; 44
    1cb6:	8c 91       	ld	r24, X
    1cb8:	9c 97       	sbiw	r26, 0x2c	; 44
    1cba:	82 8b       	std	Z+18, r24	; 0x12

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1cbc:	1a 96       	adiw	r26, 0x0a	; 10
    1cbe:	8c 91       	ld	r24, X
    1cc0:	91 85       	ldd	r25, Z+9	; 0x09
    1cc2:	98 17       	cp	r25, r24
    1cc4:	59 f0       	breq	.+22     	; 0x1cdc <gc_execute_line+0x10b0>
    // Update spindle control and apply spindle speed when enabling it in this block.    
    spindle_run(gc_block.modal.spindle, gc_state.spindle_speed);
    1cc6:	8f 01       	movw	r16, r30
    1cc8:	42 85       	ldd	r20, Z+10	; 0x0a
    1cca:	53 85       	ldd	r21, Z+11	; 0x0b
    1ccc:	64 85       	ldd	r22, Z+12	; 0x0c
    1cce:	75 85       	ldd	r23, Z+13	; 0x0d
    1cd0:	0e 94 2c 2c 	call	0x5858	; 0x5858 <spindle_run>
    gc_state.modal.spindle = gc_block.modal.spindle;    
    1cd4:	80 91 d5 05 	lds	r24, 0x05D5	; 0x8005d5 <gc_block+0xa>
    1cd8:	f8 01       	movw	r30, r16
    1cda:	81 87       	std	Z+9, r24	; 0x09
  }

  // [8. Coolant control ]:  
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1cdc:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <gc_block+0x9>
    1ce0:	90 91 94 05 	lds	r25, 0x0594	; 0x800594 <gc_state+0x8>
    1ce4:	98 17       	cp	r25, r24
    1ce6:	31 f0       	breq	.+12     	; 0x1cf4 <gc_execute_line+0x10c8>
    coolant_run(gc_block.modal.coolant);
    1ce8:	0e 94 11 05 	call	0xa22	; 0xa22 <coolant_run>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1cec:	80 91 d4 05 	lds	r24, 0x05D4	; 0x8005d4 <gc_block+0x9>
    1cf0:	80 93 94 05 	sts	0x0594, r24	; 0x800594 <gc_state+0x8>
  }
  
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1cf4:	80 91 cb 05 	lds	r24, 0x05CB	; 0x8005cb <gc_block>
    1cf8:	81 30       	cpi	r24, 0x01	; 1
    1cfa:	51 f4       	brne	.+20     	; 0x1d10 <gc_execute_line+0x10e4>
    1cfc:	60 91 eb 05 	lds	r22, 0x05EB	; 0x8005eb <gc_block+0x20>
    1d00:	70 91 ec 05 	lds	r23, 0x05EC	; 0x8005ec <gc_block+0x21>
    1d04:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x22>
    1d08:	90 91 ee 05 	lds	r25, 0x05EE	; 0x8005ee <gc_block+0x23>
    1d0c:	0e 94 4f 17 	call	0x2e9e	; 0x2e9e <mc_dwell>
  
  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;  
    1d10:	ec e8       	ldi	r30, 0x8C	; 140
    1d12:	f5 e0       	ldi	r31, 0x05	; 5
    1d14:	ab ec       	ldi	r26, 0xCB	; 203
    1d16:	b5 e0       	ldi	r27, 0x05	; 5
    1d18:	15 96       	adiw	r26, 0x05	; 5
    1d1a:	8c 91       	ld	r24, X
    1d1c:	15 97       	sbiw	r26, 0x05	; 5
    1d1e:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1d20:	13 96       	adiw	r26, 0x03	; 3
    1d22:	8c 91       	ld	r24, X
    1d24:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array. 
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1d26:	fa a1       	ldd	r31, Y+34	; 0x22
    1d28:	f3 30       	cpi	r31, 0x03	; 3
    1d2a:	f9 f4       	brne	.+62     	; 0x1d6a <gc_execute_line+0x113e>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1d2c:	80 91 d1 05 	lds	r24, 0x05D1	; 0x8005d1 <gc_block+0x6>
    1d30:	80 93 91 05 	sts	0x0591, r24	; 0x800591 <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) { // G43.1
    1d34:	81 30       	cpi	r24, 0x01	; 1
    1d36:	89 f4       	brne	.+34     	; 0x1d5a <gc_execute_line+0x112e>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    1d38:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <gc_block+0x35>
    1d3c:	90 91 01 06 	lds	r25, 0x0601	; 0x800601 <gc_block+0x36>
    1d40:	a0 91 02 06 	lds	r26, 0x0602	; 0x800602 <gc_block+0x37>
    1d44:	b0 91 03 06 	lds	r27, 0x0603	; 0x800603 <gc_block+0x38>
    1d48:	80 93 c7 05 	sts	0x05C7, r24	; 0x8005c7 <gc_state+0x3b>
    1d4c:	90 93 c8 05 	sts	0x05C8, r25	; 0x8005c8 <gc_state+0x3c>
    1d50:	a0 93 c9 05 	sts	0x05C9, r26	; 0x8005c9 <gc_state+0x3d>
    1d54:	b0 93 ca 05 	sts	0x05CA, r27	; 0x8005ca <gc_state+0x3e>
    1d58:	08 c0       	rjmp	.+16     	; 0x1d6a <gc_execute_line+0x113e>
    } else { // G49
      gc_state.tool_length_offset = 0.0;
    1d5a:	10 92 c7 05 	sts	0x05C7, r1	; 0x8005c7 <gc_state+0x3b>
    1d5e:	10 92 c8 05 	sts	0x05C8, r1	; 0x8005c8 <gc_state+0x3c>
    1d62:	10 92 c9 05 	sts	0x05C9, r1	; 0x8005c9 <gc_state+0x3d>
    1d66:	10 92 ca 05 	sts	0x05CA, r1	; 0x8005ca <gc_state+0x3e>
    }
  }
  
  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1d6a:	80 91 d2 05 	lds	r24, 0x05D2	; 0x8005d2 <gc_block+0x7>
    1d6e:	90 91 92 05 	lds	r25, 0x0592	; 0x800592 <gc_state+0x6>
    1d72:	98 17       	cp	r25, r24
    1d74:	59 f0       	breq	.+22     	; 0x1d8c <gc_execute_line+0x1160>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    1d76:	80 93 92 05 	sts	0x0592, r24	; 0x800592 <gc_state+0x6>
    memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    1d7a:	8c e0       	ldi	r24, 0x0C	; 12
    1d7c:	fe 01       	movw	r30, r28
    1d7e:	31 96       	adiw	r30, 0x01	; 1
    1d80:	af ea       	ldi	r26, 0xAF	; 175
    1d82:	b5 e0       	ldi	r27, 0x05	; 5
    1d84:	01 90       	ld	r0, Z+
    1d86:	0d 92       	st	X+, r0
    1d88:	8a 95       	dec	r24
    1d8a:	e1 f7       	brne	.-8      	; 0x1d84 <gc_execute_line+0x1158>
  
  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.
  
  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    1d8c:	eb ec       	ldi	r30, 0xCB	; 203
    1d8e:	f5 e0       	ldi	r31, 0x05	; 5
    1d90:	84 81       	ldd	r24, Z+4	; 0x04
    1d92:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <gc_state+0x3>
  
  // [18. Set retract mode ]: NOT SUPPORTED
    
  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    1d96:	80 81       	ld	r24, Z
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	32 97       	sbiw	r30, 0x02	; 2
    1d9e:	e8 30       	cpi	r30, 0x08	; 8
    1da0:	f1 05       	cpc	r31, r1
    1da2:	08 f0       	brcs	.+2      	; 0x1da6 <gc_execute_line+0x117a>
    1da4:	55 c0       	rjmp	.+170    	; 0x1e50 <gc_execute_line+0x1224>
    1da6:	e9 53       	subi	r30, 0x39	; 57
    1da8:	ff 4f       	sbci	r31, 0xFF	; 255
    1daa:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
    case NON_MODAL_SET_COORDINATE_DATA:    
      settings_write_coord_data(coord_select,parameter_data);
    1dae:	be 01       	movw	r22, r28
    1db0:	63 5f       	subi	r22, 0xF3	; 243
    1db2:	7f 4f       	sbci	r23, 0xFF	; 255
    1db4:	8f a1       	ldd	r24, Y+39	; 0x27
    1db6:	0e 94 05 29 	call	0x520a	; 0x520a <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) { memcpy(gc_state.coord_system,parameter_data,sizeof(parameter_data)); }
    1dba:	80 91 92 05 	lds	r24, 0x0592	; 0x800592 <gc_state+0x6>
    1dbe:	2f a1       	ldd	r18, Y+39	; 0x27
    1dc0:	82 13       	cpse	r24, r18
    1dc2:	46 c0       	rjmp	.+140    	; 0x1e50 <gc_execute_line+0x1224>
    1dc4:	8c e0       	ldi	r24, 0x0C	; 12
    1dc6:	fe 01       	movw	r30, r28
    1dc8:	3d 96       	adiw	r30, 0x0d	; 13
    1dca:	af ea       	ldi	r26, 0xAF	; 175
    1dcc:	b5 e0       	ldi	r27, 0x05	; 5
    1dce:	01 90       	ld	r0, Z+
    1dd0:	0d 92       	st	X+, r0
    1dd2:	8a 95       	dec	r24
    1dd4:	e1 f7       	brne	.-8      	; 0x1dce <gc_execute_line+0x11a2>
    1dd6:	3c c0       	rjmp	.+120    	; 0x1e50 <gc_execute_line+0x1224>
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1: 
      // Move to intermediate position before going home. Obeys current coordinate system and offsets 
      // and absolute and incremental modes.
      if (axis_command) {
    1dd8:	3a a1       	ldd	r19, Y+34	; 0x22
    1dda:	33 23       	and	r19, r19
    1ddc:	49 f0       	breq	.+18     	; 0x1df0 <gc_execute_line+0x11c4>
        #ifdef USE_LINE_NUMBERS
          mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
        #else
          mc_line(gc_block.values.xyz, -1.0, false);
    1dde:	20 e0       	ldi	r18, 0x00	; 0
    1de0:	40 e0       	ldi	r20, 0x00	; 0
    1de2:	50 e0       	ldi	r21, 0x00	; 0
    1de4:	60 e8       	ldi	r22, 0x80	; 128
    1de6:	7f eb       	ldi	r23, 0xBF	; 191
    1de8:	88 ef       	ldi	r24, 0xF8	; 248
    1dea:	95 e0       	ldi	r25, 0x05	; 5
    1dec:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
        #endif
      }
      #ifdef USE_LINE_NUMBERS
        mc_line(parameter_data, -1.0, false, gc_state.line_number); 
      #else
        mc_line(parameter_data, -1.0, false); 
    1df0:	20 e0       	ldi	r18, 0x00	; 0
    1df2:	40 e0       	ldi	r20, 0x00	; 0
    1df4:	50 e0       	ldi	r21, 0x00	; 0
    1df6:	60 e8       	ldi	r22, 0x80	; 128
    1df8:	7f eb       	ldi	r23, 0xBF	; 191
    1dfa:	ce 01       	movw	r24, r28
    1dfc:	0d 96       	adiw	r24, 0x0d	; 13
    1dfe:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
      #endif
      memcpy(gc_state.position, parameter_data, sizeof(parameter_data));
    1e02:	8c e0       	ldi	r24, 0x0C	; 12
    1e04:	fe 01       	movw	r30, r28
    1e06:	3d 96       	adiw	r30, 0x0d	; 13
    1e08:	a3 ea       	ldi	r26, 0xA3	; 163
    1e0a:	b5 e0       	ldi	r27, 0x05	; 5
    1e0c:	01 90       	ld	r0, Z+
    1e0e:	0d 92       	st	X+, r0
    1e10:	8a 95       	dec	r24
    1e12:	e1 f7       	brne	.-8      	; 0x1e0c <gc_execute_line+0x11e0>
      break;
    1e14:	1d c0       	rjmp	.+58     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_0: 
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    1e16:	63 ea       	ldi	r22, 0xA3	; 163
    1e18:	75 e0       	ldi	r23, 0x05	; 5
    1e1a:	86 e0       	ldi	r24, 0x06	; 6
    1e1c:	0e 94 05 29 	call	0x520a	; 0x520a <settings_write_coord_data>
      break;
    1e20:	17 c0       	rjmp	.+46     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    1e22:	63 ea       	ldi	r22, 0xA3	; 163
    1e24:	75 e0       	ldi	r23, 0x05	; 5
    1e26:	87 e0       	ldi	r24, 0x07	; 7
    1e28:	0e 94 05 29 	call	0x520a	; 0x520a <settings_write_coord_data>
      break;
    1e2c:	11 c0       	rjmp	.+34     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    1e2e:	8c e0       	ldi	r24, 0x0C	; 12
    1e30:	e8 ef       	ldi	r30, 0xF8	; 248
    1e32:	f5 e0       	ldi	r31, 0x05	; 5
    1e34:	ab eb       	ldi	r26, 0xBB	; 187
    1e36:	b5 e0       	ldi	r27, 0x05	; 5
    1e38:	01 90       	ld	r0, Z+
    1e3a:	0d 92       	st	X+, r0
    1e3c:	8a 95       	dec	r24
    1e3e:	e1 f7       	brne	.-8      	; 0x1e38 <gc_execute_line+0x120c>
      break;
    1e40:	07 c0       	rjmp	.+14     	; 0x1e50 <gc_execute_line+0x1224>
    case NON_MODAL_RESET_COORDINATE_OFFSET: 
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    1e42:	8c e0       	ldi	r24, 0x0C	; 12
    1e44:	eb eb       	ldi	r30, 0xBB	; 187
    1e46:	f5 e0       	ldi	r31, 0x05	; 5
    1e48:	df 01       	movw	r26, r30
    1e4a:	1d 92       	st	X+, r1
    1e4c:	8a 95       	dec	r24
    1e4e:	e9 f7       	brne	.-6      	; 0x1e4a <gc_execute_line+0x121e>

  
  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes. 
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    1e50:	80 91 cc 05 	lds	r24, 0x05CC	; 0x8005cc <gc_block+0x1>
    1e54:	80 93 8c 05 	sts	0x058C, r24	; 0x80058c <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    1e58:	88 30       	cpi	r24, 0x08	; 8
    1e5a:	09 f4       	brne	.+2      	; 0x1e5e <gc_execute_line+0x1232>
    1e5c:	a9 c0       	rjmp	.+338    	; 0x1fb0 <gc_execute_line+0x1384>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1e5e:	ba a1       	ldd	r27, Y+34	; 0x22
    1e60:	b2 30       	cpi	r27, 0x02	; 2
    1e62:	09 f0       	breq	.+2      	; 0x1e66 <gc_execute_line+0x123a>
    1e64:	a5 c0       	rjmp	.+330    	; 0x1fb0 <gc_execute_line+0x1384>
      switch (gc_state.modal.motion) {
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	88 30       	cpi	r24, 0x08	; 8
    1e6a:	91 05       	cpc	r25, r1
    1e6c:	08 f0       	brcs	.+2      	; 0x1e70 <gc_execute_line+0x1244>
    1e6e:	97 c0       	rjmp	.+302    	; 0x1f9e <gc_execute_line+0x1372>
    1e70:	fc 01       	movw	r30, r24
    1e72:	e1 53       	subi	r30, 0x31	; 49
    1e74:	ff 4f       	sbci	r31, 0xFF	; 255
    1e76:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
        case MOTION_MODE_SEEK:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, -1.0, false, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, -1.0, false);
    1e7a:	20 e0       	ldi	r18, 0x00	; 0
    1e7c:	40 e0       	ldi	r20, 0x00	; 0
    1e7e:	50 e0       	ldi	r21, 0x00	; 0
    1e80:	60 e8       	ldi	r22, 0x80	; 128
    1e82:	7f eb       	ldi	r23, 0xBF	; 191
    1e84:	88 ef       	ldi	r24, 0xF8	; 248
    1e86:	95 e0       	ldi	r25, 0x05	; 5
    1e88:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
          #endif
          break;
    1e8c:	88 c0       	rjmp	.+272    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_LINEAR:
          #ifdef USE_LINE_NUMBERS
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, gc_state.line_number);
          #else
            mc_line(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate);
    1e8e:	ec e8       	ldi	r30, 0x8C	; 140
    1e90:	f5 e0       	ldi	r31, 0x05	; 5
    1e92:	46 85       	ldd	r20, Z+14	; 0x0e
    1e94:	57 85       	ldd	r21, Z+15	; 0x0f
    1e96:	60 89       	ldd	r22, Z+16	; 0x10
    1e98:	71 89       	ldd	r23, Z+17	; 0x11
    1e9a:	21 81       	ldd	r18, Z+1	; 0x01
    1e9c:	88 ef       	ldi	r24, 0xF8	; 248
    1e9e:	95 e0       	ldi	r25, 0x05	; 5
    1ea0:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
          #endif
          break;
    1ea4:	7c c0       	rjmp	.+248    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_CW_ARC: 
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1ea6:	ec e8       	ldi	r30, 0x8C	; 140
    1ea8:	f5 e0       	ldi	r31, 0x05	; 5
    1eaa:	c6 84       	ldd	r12, Z+14	; 0x0e
    1eac:	d7 84       	ldd	r13, Z+15	; 0x0f
    1eae:	e0 88       	ldd	r14, Z+16	; 0x10
    1eb0:	f1 88       	ldd	r15, Z+17	; 0x11
    1eb2:	00 91 ef 05 	lds	r16, 0x05EF	; 0x8005ef <gc_block+0x24>
    1eb6:	10 91 f0 05 	lds	r17, 0x05F0	; 0x8005f0 <gc_block+0x25>
    1eba:	20 91 f1 05 	lds	r18, 0x05F1	; 0x8005f1 <gc_block+0x26>
    1ebe:	30 91 f2 05 	lds	r19, 0x05F2	; 0x8005f2 <gc_block+0x27>
    1ec2:	81 e0       	ldi	r24, 0x01	; 1
    1ec4:	8f 93       	push	r24
    1ec6:	8e a1       	ldd	r24, Y+38	; 0x26
    1ec8:	8f 93       	push	r24
    1eca:	9d a1       	ldd	r25, Y+37	; 0x25
    1ecc:	9f 93       	push	r25
    1ece:	8c a0       	ldd	r8, Y+36	; 0x24
    1ed0:	a1 80       	ldd	r10, Z+1	; 0x01
    1ed2:	4a ed       	ldi	r20, 0xDA	; 218
    1ed4:	55 e0       	ldi	r21, 0x05	; 5
    1ed6:	68 ef       	ldi	r22, 0xF8	; 248
    1ed8:	75 e0       	ldi	r23, 0x05	; 5
    1eda:	83 ea       	ldi	r24, 0xA3	; 163
    1edc:	95 e0       	ldi	r25, 0x05	; 5
    1ede:	0e 94 6d 14 	call	0x28da	; 0x28da <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, true); 
          #endif
          break;        
    1ee2:	0f 90       	pop	r0
    1ee4:	0f 90       	pop	r0
    1ee6:	0f 90       	pop	r0
    1ee8:	5a c0       	rjmp	.+180    	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_CCW_ARC:
          #ifdef USE_LINE_NUMBERS
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false, gc_state.line_number);  
          #else
            mc_arc(gc_state.position, gc_block.values.xyz, gc_block.values.ijk, gc_block.values.r, 
    1eea:	ec e8       	ldi	r30, 0x8C	; 140
    1eec:	f5 e0       	ldi	r31, 0x05	; 5
    1eee:	c6 84       	ldd	r12, Z+14	; 0x0e
    1ef0:	d7 84       	ldd	r13, Z+15	; 0x0f
    1ef2:	e0 88       	ldd	r14, Z+16	; 0x10
    1ef4:	f1 88       	ldd	r15, Z+17	; 0x11
    1ef6:	00 91 ef 05 	lds	r16, 0x05EF	; 0x8005ef <gc_block+0x24>
    1efa:	10 91 f0 05 	lds	r17, 0x05F0	; 0x8005f0 <gc_block+0x25>
    1efe:	20 91 f1 05 	lds	r18, 0x05F1	; 0x8005f1 <gc_block+0x26>
    1f02:	30 91 f2 05 	lds	r19, 0x05F2	; 0x8005f2 <gc_block+0x27>
    1f06:	1f 92       	push	r1
    1f08:	ae a1       	ldd	r26, Y+38	; 0x26
    1f0a:	af 93       	push	r26
    1f0c:	bd a1       	ldd	r27, Y+37	; 0x25
    1f0e:	bf 93       	push	r27
    1f10:	8c a0       	ldd	r8, Y+36	; 0x24
    1f12:	a1 80       	ldd	r10, Z+1	; 0x01
    1f14:	4a ed       	ldi	r20, 0xDA	; 218
    1f16:	55 e0       	ldi	r21, 0x05	; 5
    1f18:	68 ef       	ldi	r22, 0xF8	; 248
    1f1a:	75 e0       	ldi	r23, 0x05	; 5
    1f1c:	83 ea       	ldi	r24, 0xA3	; 163
    1f1e:	95 e0       	ldi	r25, 0x05	; 5
    1f20:	0e 94 6d 14 	call	0x28da	; 0x28da <mc_arc>
              gc_state.feed_rate, gc_state.modal.feed_rate, axis_0, axis_1, axis_linear, false); 
          #endif
          break;
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	39 c0       	rjmp	.+114    	; 0x1f9e <gc_execute_line+0x1372>
          // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
          // upon a successful probing cycle, the machine position and the returned value should be the same.
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, false);
    1f2c:	ec e8       	ldi	r30, 0x8C	; 140
    1f2e:	f5 e0       	ldi	r31, 0x05	; 5
    1f30:	46 85       	ldd	r20, Z+14	; 0x0e
    1f32:	57 85       	ldd	r21, Z+15	; 0x0f
    1f34:	60 89       	ldd	r22, Z+16	; 0x10
    1f36:	71 89       	ldd	r23, Z+17	; 0x11
    1f38:	e1 2c       	mov	r14, r1
    1f3a:	00 e0       	ldi	r16, 0x00	; 0
    1f3c:	21 81       	ldd	r18, Z+1	; 0x01
    1f3e:	88 ef       	ldi	r24, 0xF8	; 248
    1f40:	95 e0       	ldi	r25, 0x05	; 5
    1f42:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <mc_probe_cycle>
          #endif
          break;
    1f46:	2b c0       	rjmp	.+86     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, false, true);
    1f48:	ec e8       	ldi	r30, 0x8C	; 140
    1f4a:	f5 e0       	ldi	r31, 0x05	; 5
    1f4c:	46 85       	ldd	r20, Z+14	; 0x0e
    1f4e:	57 85       	ldd	r21, Z+15	; 0x0f
    1f50:	60 89       	ldd	r22, Z+16	; 0x10
    1f52:	71 89       	ldd	r23, Z+17	; 0x11
    1f54:	ee 24       	eor	r14, r14
    1f56:	e3 94       	inc	r14
    1f58:	00 e0       	ldi	r16, 0x00	; 0
    1f5a:	21 81       	ldd	r18, Z+1	; 0x01
    1f5c:	88 ef       	ldi	r24, 0xF8	; 248
    1f5e:	95 e0       	ldi	r25, 0x05	; 5
    1f60:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <mc_probe_cycle>
          #endif
          break;
    1f64:	1c c0       	rjmp	.+56     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false, gc_state.line_number);
          #else
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, false);
    1f66:	ec e8       	ldi	r30, 0x8C	; 140
    1f68:	f5 e0       	ldi	r31, 0x05	; 5
    1f6a:	46 85       	ldd	r20, Z+14	; 0x0e
    1f6c:	57 85       	ldd	r21, Z+15	; 0x0f
    1f6e:	60 89       	ldd	r22, Z+16	; 0x10
    1f70:	71 89       	ldd	r23, Z+17	; 0x11
    1f72:	e1 2c       	mov	r14, r1
    1f74:	01 e0       	ldi	r16, 0x01	; 1
    1f76:	21 81       	ldd	r18, Z+1	; 0x01
    1f78:	88 ef       	ldi	r24, 0xF8	; 248
    1f7a:	95 e0       	ldi	r25, 0x05	; 5
    1f7c:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <mc_probe_cycle>
          #endif
          break;
    1f80:	0e c0       	rjmp	.+28     	; 0x1f9e <gc_execute_line+0x1372>
        case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          #ifdef USE_LINE_NUMBERS
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true, gc_state.line_number);
          #else        
            mc_probe_cycle(gc_block.values.xyz, gc_state.feed_rate, gc_state.modal.feed_rate, true, true);
    1f82:	ec e8       	ldi	r30, 0x8C	; 140
    1f84:	f5 e0       	ldi	r31, 0x05	; 5
    1f86:	46 85       	ldd	r20, Z+14	; 0x0e
    1f88:	57 85       	ldd	r21, Z+15	; 0x0f
    1f8a:	60 89       	ldd	r22, Z+16	; 0x10
    1f8c:	71 89       	ldd	r23, Z+17	; 0x11
    1f8e:	ee 24       	eor	r14, r14
    1f90:	e3 94       	inc	r14
    1f92:	01 e0       	ldi	r16, 0x01	; 1
    1f94:	21 81       	ldd	r18, Z+1	; 0x01
    1f96:	88 ef       	ldi	r24, 0xF8	; 248
    1f98:	95 e0       	ldi	r25, 0x05	; 5
    1f9a:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <mc_probe_cycle>
      }
    
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    1f9e:	8c e0       	ldi	r24, 0x0C	; 12
    1fa0:	e8 ef       	ldi	r30, 0xF8	; 248
    1fa2:	f5 e0       	ldi	r31, 0x05	; 5
    1fa4:	a3 ea       	ldi	r26, 0xA3	; 163
    1fa6:	b5 e0       	ldi	r27, 0x05	; 5
    1fa8:	01 90       	ld	r0, Z+
    1faa:	0d 92       	st	X+, r0
    1fac:	8a 95       	dec	r24
    1fae:	e1 f7       	brne	.-8      	; 0x1fa8 <gc_execute_line+0x137c>
  }
  
  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may 
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    1fb0:	80 91 d3 05 	lds	r24, 0x05D3	; 0x8005d3 <gc_block+0x8>
    1fb4:	80 93 93 05 	sts	0x0593, r24	; 0x800593 <gc_state+0x7>
  if (gc_state.modal.program_flow) { 
    1fb8:	88 23       	and	r24, r24
    1fba:	09 f4       	brne	.+2      	; 0x1fbe <gc_execute_line+0x1392>
    1fbc:	0e c1       	rjmp	.+540    	; 0x21da <gc_execute_line+0x15ae>
	protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    1fbe:	0e 94 3b 22 	call	0x4476	; 0x4476 <protocol_buffer_synchronize>
	if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    1fc2:	80 91 93 05 	lds	r24, 0x0593	; 0x800593 <gc_state+0x7>
    1fc6:	81 30       	cpi	r24, 0x01	; 1
    1fc8:	79 f4       	brne	.+30     	; 0x1fe8 <gc_execute_line+0x13bc>
	  if (sys.state != STATE_CHECK_MODE) {
    1fca:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    1fce:	82 30       	cpi	r24, 0x02	; 2
    1fd0:	91 f1       	breq	.+100    	; 0x2036 <gc_execute_line+0x140a>
		bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); // Use feed hold for program pause.
    1fd2:	9f b7       	in	r25, 0x3f	; 63
    1fd4:	f8 94       	cli
    1fd6:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    1fda:	88 60       	ori	r24, 0x08	; 8
    1fdc:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    1fe0:	9f bf       	out	0x3f, r25	; 63
		protocol_execute_realtime(); // Execute suspend.
    1fe2:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    1fe6:	27 c0       	rjmp	.+78     	; 0x2036 <gc_execute_line+0x140a>
	} else { // == PROGRAM_FLOW_COMPLETED
	  // Upon program complete, only a subset of g-codes reset to certain defaults, according to 
	  // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
	  // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
	  // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
	  gc_state.modal.motion = MOTION_MODE_LINEAR;
    1fe8:	ec e8       	ldi	r30, 0x8C	; 140
    1fea:	f5 e0       	ldi	r31, 0x05	; 5
    1fec:	81 e0       	ldi	r24, 0x01	; 1
    1fee:	80 83       	st	Z, r24
	  gc_state.modal.plane_select = PLANE_SELECT_XY;
    1ff0:	14 82       	std	Z+4, r1	; 0x04
	  gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    1ff2:	13 82       	std	Z+3, r1	; 0x03
	  gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    1ff4:	11 82       	std	Z+1, r1	; 0x01
	  // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
	  gc_state.modal.coord_select = 0; // G54
    1ff6:	16 82       	std	Z+6, r1	; 0x06
	  gc_state.modal.spindle = SPINDLE_DISABLE;
    1ff8:	11 86       	std	Z+9, r1	; 0x09
	  gc_state.modal.coolant = COOLANT_DISABLE;
    1ffa:	10 86       	std	Z+8, r1	; 0x08
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
    1ffc:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    2000:	82 30       	cpi	r24, 0x02	; 2
    2002:	b1 f0       	breq	.+44     	; 0x2030 <gc_execute_line+0x1404>
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2004:	be 01       	movw	r22, r28
    2006:	6f 5f       	subi	r22, 0xFF	; 255
    2008:	7f 4f       	sbci	r23, 0xFF	; 255
    200a:	80 e0       	ldi	r24, 0x00	; 0
    200c:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    2010:	88 23       	and	r24, r24
    2012:	09 f4       	brne	.+2      	; 0x2016 <gc_execute_line+0x13ea>
    2014:	78 c0       	rjmp	.+240    	; 0x2106 <gc_execute_line+0x14da>
		memcpy(gc_state.coord_system,coordinate_data,sizeof(coordinate_data));
    2016:	8c e0       	ldi	r24, 0x0C	; 12
    2018:	fe 01       	movw	r30, r28
    201a:	31 96       	adiw	r30, 0x01	; 1
    201c:	af ea       	ldi	r26, 0xAF	; 175
    201e:	b5 e0       	ldi	r27, 0x05	; 5
    2020:	01 90       	ld	r0, Z+
    2022:	0d 92       	st	X+, r0
    2024:	8a 95       	dec	r24
    2026:	e1 f7       	brne	.-8      	; 0x2020 <gc_execute_line+0x13f4>
		spindle_stop();
    2028:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
		coolant_stop();		
    202c:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
	  }
	  
	  report_feedback_message(MESSAGE_PROGRAM_END);
    2030:	87 e0       	ldi	r24, 0x07	; 7
    2032:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
	}
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    2036:	10 92 93 05 	sts	0x0593, r1	; 0x800593 <gc_state+0x7>
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
    203a:	80 e0       	ldi	r24, 0x00	; 0
    203c:	ce c0       	rjmp	.+412    	; 0x21da <gc_execute_line+0x15ae>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    
    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	cc c0       	rjmp	.+408    	; 0x21da <gc_execute_line+0x15ae>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    2042:	82 e0       	ldi	r24, 0x02	; 2
    2044:	ca c0       	rjmp	.+404    	; 0x21da <gc_execute_line+0x15ae>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    2046:	84 e1       	ldi	r24, 0x14	; 20
    2048:	c8 c0       	rjmp	.+400    	; 0x21da <gc_execute_line+0x15ae>
        switch(int_value) {
          case 10: case 28: case 30: case 92: 
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    204a:	88 e1       	ldi	r24, 0x18	; 24
    204c:	c6 c0       	rjmp	.+396    	; 0x21da <gc_execute_line+0x15ae>
              case 10: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_DATA; break; // G10
              case 28:
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_0; break;  // G28
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_0; break; // G28.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G28.x command]
    204e:	84 e1       	ldi	r24, 0x14	; 20
    2050:	c4 c0       	rjmp	.+392    	; 0x21da <gc_execute_line+0x15ae>
                break;
              case 30: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_GO_HOME_1; break;  // G30
                  case 10: gc_block.non_modal_command = NON_MODAL_SET_HOME_1; break; // G30.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G30.x command]
    2052:	84 e1       	ldi	r24, 0x14	; 20
    2054:	c2 c0       	rjmp	.+388    	; 0x21da <gc_execute_line+0x15ae>
              case 53: gc_block.non_modal_command = NON_MODAL_ABSOLUTE_OVERRIDE; break; // G53
              case 92: 
                switch(mantissa) {
                  case 0: gc_block.non_modal_command = NON_MODAL_SET_COORDINATE_OFFSET; break; // G92
                  case 10: gc_block.non_modal_command = NON_MODAL_RESET_COORDINATE_OFFSET; break; // G92.1
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G92.x command]
    2056:	84 e1       	ldi	r24, 0x14	; 20
    2058:	c0 c0       	rjmp	.+384    	; 0x21da <gc_execute_line+0x15ae>
            }
            break;
          case 0: case 1: case 2: case 3: case 38: 
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    205a:	88 e1       	ldi	r24, 0x18	; 24
    205c:	be c0       	rjmp	.+380    	; 0x21da <gc_execute_line+0x15ae>
                switch(mantissa) {
                  case 20: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD; break; // G38.2
                  case 30: gc_block.modal.motion = MOTION_MODE_PROBE_TOWARD_NO_ERROR; break; // G38.3
                  case 40: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY; break; // G38.4
                  case 50: gc_block.modal.motion = MOTION_MODE_PROBE_AWAY_NO_ERROR; break; // G38.5
                  default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    205e:	84 e1       	ldi	r24, 0x14	; 20
    2060:	bc c0       	rjmp	.+376    	; 0x21da <gc_execute_line+0x15ae>
              word_bit = MODAL_GROUP_G3; 
              if (int_value == 90) { gc_block.modal.distance = DISTANCE_MODE_ABSOLUTE; } // G90
              else { gc_block.modal.distance = DISTANCE_MODE_INCREMENTAL; } // G91
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    2062:	84 e1       	ldi	r24, 0x14	; 20
    2064:	ba c0       	rjmp	.+372    	; 0x21da <gc_execute_line+0x15ae>
    2066:	84 e1       	ldi	r24, 0x14	; 20
    2068:	b8 c0       	rjmp	.+368    	; 0x21da <gc_execute_line+0x15ae>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not. 
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    206a:	88 e1       	ldi	r24, 0x18	; 24
    206c:	b6 c0       	rjmp	.+364    	; 0x21da <gc_execute_line+0x15ae>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL; 
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    206e:	84 e1       	ldi	r24, 0x14	; 20
    2070:	b4 c0       	rjmp	.+360    	; 0x21da <gc_execute_line+0x15ae>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value-54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    2072:	84 e1       	ldi	r24, 0x14	; 20
    2074:	b2 c0       	rjmp	.+356    	; 0x21da <gc_execute_line+0x15ae>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    2076:	87 e1       	ldi	r24, 0x17	; 23
    2078:	b0 c0       	rjmp	.+352    	; 0x21da <gc_execute_line+0x15ae>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    207a:	85 e1       	ldi	r24, 0x15	; 21
    207c:	ae c0       	rjmp	.+348    	; 0x21da <gc_execute_line+0x15ae>
        break;
        
      case 'M':
      
        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    207e:	87 e1       	ldi	r24, 0x17	; 23
    2080:	ac c0       	rjmp	.+344    	; 0x21da <gc_execute_line+0x15ae>
             #endif
              case 8: gc_block.modal.coolant = COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break;
            }
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    2082:	84 e1       	ldi	r24, 0x14	; 20
    2084:	aa c0       	rjmp	.+340    	; 0x21da <gc_execute_line+0x15ae>
        }
      
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    2086:	85 e1       	ldi	r24, 0x15	; 21
    2088:	a8 c0       	rjmp	.+336    	; 0x21da <gc_execute_line+0x15ae>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; break; // gc.values.t = int_value;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    208a:	84 e1       	ldi	r24, 0x14	; 20
    208c:	a6 c0       	rjmp	.+332    	; 0x21da <gc_execute_line+0x15ae>
        } 
        
        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    208e:	89 e1       	ldi	r24, 0x19	; 25
    2090:	a4 c0       	rjmp	.+328    	; 0x21da <gc_execute_line+0x15ae>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    2092:	84 e0       	ldi	r24, 0x04	; 4
    2094:	a2 c0       	rjmp	.+324    	; 0x21da <gc_execute_line+0x15ae>
  }
  
  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    2096:	8b e1       	ldi	r24, 0x1B	; 27
    2098:	a0 c0       	rjmp	.+320    	; 0x21da <gc_execute_line+0x15ae>
  //   is not defined after switching to G94 from G93.
  if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
    if (axis_command == AXIS_COMMAND_MOTION_MODE) { 
      if ((gc_block.modal.motion != MOTION_MODE_NONE) || (gc_block.modal.motion != MOTION_MODE_SEEK)) {
        if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    209a:	86 e1       	ldi	r24, 0x16	; 22
    209c:	9e c0       	rjmp	.+316    	; 0x21da <gc_execute_line+0x15ae>
  // [8. Coolant control ]: N/A
  // [9. Enable/disable feed rate or spindle overrides ]: NOT SUPPORTED.
  
  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    209e:	8c e1       	ldi	r24, 0x1C	; 28
    20a0:	9c c0       	rjmp	.+312    	; 0x21da <gc_execute_line+0x15ae>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid 
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    20a2:	85 e2       	ldi	r24, 0x25	; 37
    20a4:	9a c0       	rjmp	.+308    	; 0x21da <gc_execute_line+0x15ae>
  // is active. The read pauses the processor temporarily and may cause a rare crash. For 
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  memcpy(coordinate_data,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    20a6:	8d e1       	ldi	r24, 0x1D	; 29
    20a8:	98 c0       	rjmp	.+304    	; 0x21da <gc_execute_line+0x15ae>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    20aa:	87 e0       	ldi	r24, 0x07	; 7
    20ac:	96 c0       	rjmp	.+300    	; 0x21da <gc_execute_line+0x15ae>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:  
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    20ae:	8a e1       	ldi	r24, 0x1A	; 26
    20b0:	94 c0       	rjmp	.+296    	; 0x21da <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    20b2:	8c e1       	ldi	r24, 0x1C	; 28
    20b4:	92 c0       	rjmp	.+292    	; 0x21da <gc_execute_line+0x15ae>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    20b6:	8d e1       	ldi	r24, 0x1D	; 29
    20b8:	90 c0       	rjmp	.+288    	; 0x21da <gc_execute_line+0x15ae>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    20ba:	84 e1       	ldi	r24, 0x14	; 20
    20bc:	8e c0       	rjmp	.+284    	; 0x21da <gc_execute_line+0x15ae>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    20be:	84 e1       	ldi	r24, 0x14	; 20
    20c0:	8c c0       	rjmp	.+280    	; 0x21da <gc_execute_line+0x15ae>
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
      
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      if (!settings_read_coord_data(coord_select,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    20c2:	87 e0       	ldi	r24, 0x07	; 7
    20c4:	8a c0       	rjmp	.+276    	; 0x21da <gc_execute_line+0x15ae>
        }
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20c6:	8a e1       	ldi	r24, 0x1A	; 26
    20c8:	88 c0       	rjmp	.+272    	; 0x21da <gc_execute_line+0x15ae>
      switch (gc_block.non_modal_command) {        
        case NON_MODAL_GO_HOME_0: 
          // [G28 Errors]: Cutter compensation is enabled. 
          // Retreive G28 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G28,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20ca:	87 e0       	ldi	r24, 0x07	; 7
    20cc:	86 c0       	rjmp	.+268    	; 0x21da <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_GO_HOME_1:
          // [G30 Errors]: Cutter compensation is enabled. 
          // Retreive G30 go-home position data (in machine coordinates) from EEPROM
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; } // Set to none if no intermediate motion.
          if (!settings_read_coord_data(SETTING_INDEX_G30,parameter_data)) { FAIL(STATUS_SETTING_READ_FAIL); }
    20ce:	87 e0       	ldi	r24, 0x07	; 7
    20d0:	84 c0       	rjmp	.+264    	; 0x21da <gc_execute_line+0x15ae>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    20d2:	8e e1       	ldi	r24, 0x1E	; 30
    20d4:	82 c0       	rjmp	.+260    	; 0x21da <gc_execute_line+0x15ae>
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word exist and are not used by a non-modal command.
    if ((axis_words) && (axis_command != AXIS_COMMAND_NON_MODAL)) { 
      FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); // [No axis words allowed]
    20d6:	8f e1       	ldi	r24, 0x1F	; 31
    20d8:	80 c0       	rjmp	.+256    	; 0x21da <gc_execute_line+0x15ae>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {      
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    20da:	86 e1       	ldi	r24, 0x16	; 22
    20dc:	7e c0       	rjmp	.+252    	; 0x21da <gc_execute_line+0x15ae>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current 
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).   
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.        
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.
        
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20de:	8a e1       	ldi	r24, 0x1A	; 26
    20e0:	7c c0       	rjmp	.+248    	; 0x21da <gc_execute_line+0x15ae>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    20e2:	80 e2       	ldi	r24, 0x20	; 32
    20e4:	7a c0       	rjmp	.+244    	; 0x21da <gc_execute_line+0x15ae>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode  
            bit_false(value_words,bit(WORD_R));
            if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20e6:	81 e2       	ldi	r24, 0x21	; 33
    20e8:	78 c0       	rjmp	.+240    	; 0x21da <gc_execute_line+0x15ae>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    20ea:	82 e2       	ldi	r24, 0x22	; 34
    20ec:	76 c0       	rjmp	.+236    	; 0x21da <gc_execute_line+0x15ae>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
          
          } else { // Arc Center Format Offset Mode  
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    20ee:	83 e2       	ldi	r24, 0x23	; 35
    20f0:	74 c0       	rjmp	.+232    	; 0x21da <gc_execute_line+0x15ae>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]); 
            
            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) { 
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    20f2:	81 e2       	ldi	r24, 0x21	; 33
    20f4:	72 c0       	rjmp	.+228    	; 0x21da <gc_execute_line+0x15ae>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    20f6:	81 e2       	ldi	r24, 0x21	; 33
    20f8:	70 c0       	rjmp	.+224    	; 0x21da <gc_execute_line+0x15ae>
        case MOTION_MODE_PROBE_AWAY: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to 
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    20fa:	8a e1       	ldi	r24, 0x1A	; 26
    20fc:	6e c0       	rjmp	.+220    	; 0x21da <gc_execute_line+0x15ae>
          if (gc_check_same_position(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    20fe:	81 e2       	ldi	r24, 0x21	; 33
    2100:	6c c0       	rjmp	.+216    	; 0x21da <gc_execute_line+0x15ae>

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words. 
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    2102:	84 e2       	ldi	r24, 0x24	; 36
    2104:	6a c0       	rjmp	.+212    	; 0x21da <gc_execute_line+0x15ae>
	  gc_state.modal.coolant = COOLANT_DISABLE;
	  // gc_state.modal.override = OVERRIDE_DISABLE; // Not supported.
	  
	  // Execute coordinate change and spindle/coolant stop.
	  if (sys.state != STATE_CHECK_MODE) {
		if (!(settings_read_coord_data(gc_state.modal.coord_select,coordinate_data))) { FAIL(STATUS_SETTING_READ_FAIL); } 
    2106:	87 e0       	ldi	r24, 0x07	; 7
    2108:	68 c0       	rjmp	.+208    	; 0x21da <gc_execute_line+0x15ae>
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }      
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    210a:	87 e1       	ldi	r24, 0x17	; 23
    210c:	66 c0       	rjmp	.+204    	; 0x21da <gc_execute_line+0x15ae>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53: 
            word_bit = MODAL_GROUP_G0; 
            switch(int_value) {
    210e:	0c 31       	cpi	r16, 0x1C	; 28
    2110:	11 f4       	brne	.+4      	; 0x2116 <gc_execute_line+0x14ea>
    2112:	0c 94 c7 06 	jmp	0xd8e	; 0xd8e <gc_execute_line+0x162>
    2116:	50 f4       	brcc	.+20     	; 0x212c <gc_execute_line+0x1500>
    2118:	04 30       	cpi	r16, 0x04	; 4
    211a:	11 f4       	brne	.+4      	; 0x2120 <gc_execute_line+0x14f4>
    211c:	0c 94 b7 06 	jmp	0xd6e	; 0xd6e <gc_execute_line+0x142>
    2120:	0a 30       	cpi	r16, 0x0A	; 10
    2122:	11 f0       	breq	.+4      	; 0x2128 <gc_execute_line+0x14fc>
    2124:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <gc_execute_line+0x37e>
    2128:	0c 94 bf 06 	jmp	0xd7e	; 0xd7e <gc_execute_line+0x152>
    212c:	05 33       	cpi	r16, 0x35	; 53
    212e:	11 f4       	brne	.+4      	; 0x2134 <gc_execute_line+0x1508>
    2130:	0c 94 f3 06 	jmp	0xde6	; 0xde6 <gc_execute_line+0x1ba>
    2134:	0c 35       	cpi	r16, 0x5C	; 92
    2136:	11 f4       	brne	.+4      	; 0x213c <gc_execute_line+0x1510>
    2138:	0c 94 fb 06 	jmp	0xdf6	; 0xdf6 <gc_execute_line+0x1ca>
    213c:	0e 31       	cpi	r16, 0x1E	; 30
    213e:	11 f0       	breq	.+4      	; 0x2144 <gc_execute_line+0x1518>
    2140:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <gc_execute_line+0x37e>
    2144:	0c 94 dd 06 	jmp	0xdba	; 0xdba <gc_execute_line+0x18e>
    2148:	0c 31       	cpi	r16, 0x1C	; 28
    214a:	11 f4       	brne	.+4      	; 0x2150 <gc_execute_line+0x1524>
    214c:	0c 94 c9 06 	jmp	0xd92	; 0xd92 <gc_execute_line+0x166>
    2150:	48 f4       	brcc	.+18     	; 0x2164 <gc_execute_line+0x1538>
    2152:	04 30       	cpi	r16, 0x04	; 4
    2154:	11 f4       	brne	.+4      	; 0x215a <gc_execute_line+0x152e>
    2156:	0c 94 b9 06 	jmp	0xd72	; 0xd72 <gc_execute_line+0x146>
    215a:	0a 30       	cpi	r16, 0x0A	; 10
    215c:	11 f4       	brne	.+4      	; 0x2162 <gc_execute_line+0x1536>
    215e:	0c 94 c1 06 	jmp	0xd82	; 0xd82 <gc_execute_line+0x156>
    2162:	d3 cf       	rjmp	.-90     	; 0x210a <gc_execute_line+0x14de>
    2164:	05 33       	cpi	r16, 0x35	; 53
    2166:	11 f4       	brne	.+4      	; 0x216c <gc_execute_line+0x1540>
    2168:	0c 94 f5 06 	jmp	0xdea	; 0xdea <gc_execute_line+0x1be>
    216c:	0c 35       	cpi	r16, 0x5C	; 92
    216e:	11 f4       	brne	.+4      	; 0x2174 <gc_execute_line+0x1548>
    2170:	0c 94 fd 06 	jmp	0xdfa	; 0xdfa <gc_execute_line+0x1ce>
    2174:	0e 31       	cpi	r16, 0x1E	; 30
    2176:	49 f6       	brne	.-110    	; 0x210a <gc_execute_line+0x14de>
    2178:	0c 94 df 06 	jmp	0xdbe	; 0xdbe <gc_execute_line+0x192>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    217c:	e1 e0       	ldi	r30, 0x01	; 1
    217e:	ee a3       	std	Y+38, r30	; 0x26
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    2180:	1d a2       	std	Y+37, r1	; 0x25
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    2182:	f2 e0       	ldi	r31, 0x02	; 2
    2184:	fc a3       	std	Y+36, r31	; 0x24
  }   
            
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2186:	80 91 ce 05 	lds	r24, 0x05CE	; 0x8005ce <gc_block+0x3>
    218a:	81 30       	cpi	r24, 0x01	; 1
    218c:	09 f0       	breq	.+2      	; 0x2190 <gc_execute_line+0x1564>
    218e:	eb c8       	rjmp	.-3626   	; 0x1366 <gc_execute_line+0x73a>
    2190:	b6 c8       	rjmp	.-3732   	; 0x12fe <gc_execute_line+0x6d2>
          }
        }
      }
          
      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {        
    2192:	25 e0       	ldi	r18, 0x05	; 5
    2194:	52 16       	cp	r5, r18
    2196:	09 f4       	brne	.+2      	; 0x219a <gc_execute_line+0x156e>
    2198:	eb ca       	rjmp	.-2602   	; 0x1770 <gc_execute_line+0xb44>
    219a:	37 e0       	ldi	r19, 0x07	; 7
    219c:	53 16       	cp	r5, r19
    219e:	09 f4       	brne	.+2      	; 0x21a2 <gc_execute_line+0x1576>
    21a0:	f5 ca       	rjmp	.-2582   	; 0x178c <gc_execute_line+0xb60>
    21a2:	83 e0       	ldi	r24, 0x03	; 3
    21a4:	58 12       	cpse	r5, r24
    21a6:	f7 ca       	rjmp	.-2578   	; 0x1796 <gc_execute_line+0xb6a>
    21a8:	d9 ca       	rjmp	.-2638   	; 0x175c <gc_execute_line+0xb30>
    21aa:	95 e0       	ldi	r25, 0x05	; 5
    21ac:	59 16       	cp	r5, r25
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <gc_execute_line+0x1586>
    21b0:	df ca       	rjmp	.-2626   	; 0x1770 <gc_execute_line+0xb44>
    21b2:	a7 e0       	ldi	r26, 0x07	; 7
    21b4:	5a 16       	cp	r5, r26
    21b6:	09 f4       	brne	.+2      	; 0x21ba <gc_execute_line+0x158e>
    21b8:	e9 ca       	rjmp	.-2606   	; 0x178c <gc_execute_line+0xb60>
    21ba:	b3 e0       	ldi	r27, 0x03	; 3
    21bc:	5b 12       	cpse	r5, r27
    21be:	eb ca       	rjmp	.-2602   	; 0x1796 <gc_execute_line+0xb6a>
    21c0:	cc ca       	rjmp	.-2664   	; 0x175a <gc_execute_line+0xb2e>
          break;
      }
  }
      
  // [20. Motion modes ]: 
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    21c2:	10 91 cc 05 	lds	r17, 0x05CC	; 0x8005cc <gc_block+0x1>
    21c6:	18 30       	cpi	r17, 0x08	; 8
    21c8:	09 f0       	breq	.+2      	; 0x21cc <gc_execute_line+0x15a0>
    21ca:	f6 ca       	rjmp	.-2580   	; 0x17b8 <gc_execute_line+0xb8c>
    21cc:	ef ca       	rjmp	.-2594   	; 0x17ac <gc_execute_line+0xb80>
  
  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.  
  bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words. 
    21ce:	ee ed       	ldi	r30, 0xDE	; 222
    21d0:	6e 22       	and	r6, r30
    21d2:	ec ef       	ldi	r30, 0xFC	; 252
    21d4:	7e 22       	and	r7, r30
    21d6:	1a a2       	std	Y+34, r1	; 0x22
    21d8:	22 cd       	rjmp	.-1468   	; 0x1c1e <gc_execute_line+0xff2>
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
  }
    
  // TODO: % to denote start of program.
  return(STATUS_OK);
}
    21da:	ab 96       	adiw	r28, 0x2b	; 43
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	de bf       	out	0x3e, r29	; 62
    21e2:	0f be       	out	0x3f, r0	; 63
    21e4:	cd bf       	out	0x3d, r28	; 61
    21e6:	df 91       	pop	r29
    21e8:	cf 91       	pop	r28
    21ea:	1f 91       	pop	r17
    21ec:	0f 91       	pop	r16
    21ee:	ff 90       	pop	r15
    21f0:	ef 90       	pop	r14
    21f2:	df 90       	pop	r13
    21f4:	cf 90       	pop	r12
    21f6:	bf 90       	pop	r11
    21f8:	af 90       	pop	r10
    21fa:	9f 90       	pop	r9
    21fc:	8f 90       	pop	r8
    21fe:	7f 90       	pop	r7
    2200:	6f 90       	pop	r6
    2202:	5f 90       	pop	r5
    2204:	4f 90       	pop	r4
    2206:	3f 90       	pop	r3
    2208:	2f 90       	pop	r2
    220a:	08 95       	ret

0000220c <limits_disable>:


// Disables hard limits.
void limits_disable()
{
  LIMIT_PCMSK &= ~LIMIT_MASK;  // Disable specific pins of the Pin Change Interrupt
    220c:	eb e6       	ldi	r30, 0x6B	; 107
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	80 81       	ld	r24, Z
    2212:	89 7e       	andi	r24, 0xE9	; 233
    2214:	80 83       	st	Z, r24
  PCICR &= ~(1 << LIMIT_INT);  // Disable Pin Change Interrupt
    2216:	e8 e6       	ldi	r30, 0x68	; 104
    2218:	f0 e0       	ldi	r31, 0x00	; 0
    221a:	80 81       	ld	r24, Z
    221c:	8e 7f       	andi	r24, 0xFE	; 254
    221e:	80 83       	st	Z, r24
    2220:	08 95       	ret

00002222 <limits_init>:
  #define HOMING_AXIS_LOCATE_SCALAR  5.0 // Must be > 1 to ensure limit switch is cleared.
#endif

void limits_init() 
{
  LIMIT_DDR &= ~(LIMIT_MASK); // Set as input pins
    2222:	84 b1       	in	r24, 0x04	; 4
    2224:	89 7e       	andi	r24, 0xE9	; 233
    2226:	84 b9       	out	0x04, r24	; 4

  #ifdef DISABLE_LIMIT_PIN_PULL_UP
    LIMIT_PORT &= ~(LIMIT_MASK); // Normal low operation. Requires external pull-down.
  #else
    LIMIT_PORT |= (LIMIT_MASK);  // Enable internal pull-up resistors. Normal high operation.
    2228:	85 b1       	in	r24, 0x05	; 5
    222a:	86 61       	ori	r24, 0x16	; 22
    222c:	85 b9       	out	0x05, r24	; 5
  #endif

  if (bit_istrue(settings.flags,BITFLAG_HARD_LIMIT_ENABLE)) {
    222e:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    2232:	83 ff       	sbrs	r24, 3
    2234:	0b c0       	rjmp	.+22     	; 0x224c <limits_init+0x2a>
    LIMIT_PCMSK |= LIMIT_MASK; // Enable specific pins of the Pin Change Interrupt
    2236:	eb e6       	ldi	r30, 0x6B	; 107
    2238:	f0 e0       	ldi	r31, 0x00	; 0
    223a:	80 81       	ld	r24, Z
    223c:	86 61       	ori	r24, 0x16	; 22
    223e:	80 83       	st	Z, r24
    PCICR |= (1 << LIMIT_INT); // Enable Pin Change Interrupt
    2240:	e8 e6       	ldi	r30, 0x68	; 104
    2242:	f0 e0       	ldi	r31, 0x00	; 0
    2244:	80 81       	ld	r24, Z
    2246:	81 60       	ori	r24, 0x01	; 1
    2248:	80 83       	st	Z, r24
    224a:	08 95       	ret
  } else {
    limits_disable(); 
    224c:	0e 94 06 11 	call	0x220c	; 0x220c <limits_disable>
    2250:	08 95       	ret

00002252 <limits_get_state>:

// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
    2252:	ef 92       	push	r14
    2254:	ff 92       	push	r15
    2256:	0f 93       	push	r16
    2258:	1f 93       	push	r17
    225a:	cf 93       	push	r28
    225c:	df 93       	push	r29
  uint8_t limit_state = 0;
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
    225e:	13 b1       	in	r17, 0x03	; 3
    2260:	16 71       	andi	r17, 0x16	; 22
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
    2262:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    2266:	86 fd       	sbrc	r24, 6
    2268:	1b c0       	rjmp	.+54     	; 0x22a0 <limits_get_state+0x4e>
    226a:	86 e1       	ldi	r24, 0x16	; 22
    226c:	18 27       	eor	r17, r24
    226e:	18 c0       	rjmp	.+48     	; 0x22a0 <limits_get_state+0x4e>
  if (pin) {  
    2270:	c0 e0       	ldi	r28, 0x00	; 0
    2272:	d0 e0       	ldi	r29, 0x00	; 0
    2274:	00 e0       	ldi	r16, 0x00	; 0
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    2276:	ee 24       	eor	r14, r14
    2278:	e3 94       	inc	r14
    227a:	f1 2c       	mov	r15, r1
    227c:	8c 2f       	mov	r24, r28
    227e:	0e 94 ba 2b 	call	0x5774	; 0x5774 <get_limit_pin_mask>
    2282:	81 23       	and	r24, r17
    2284:	41 f0       	breq	.+16     	; 0x2296 <limits_get_state+0x44>
    2286:	c7 01       	movw	r24, r14
    2288:	0c 2e       	mov	r0, r28
    228a:	02 c0       	rjmp	.+4      	; 0x2290 <limits_get_state+0x3e>
    228c:	88 0f       	add	r24, r24
    228e:	99 1f       	adc	r25, r25
    2290:	0a 94       	dec	r0
    2292:	e2 f7       	brpl	.-8      	; 0x228c <limits_get_state+0x3a>
    2294:	08 2b       	or	r16, r24
    2296:	21 96       	adiw	r28, 0x01	; 1
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    uint8_t idx;
    for (idx=0; idx<N_AXIS; idx++) {
    2298:	c3 30       	cpi	r28, 0x03	; 3
    229a:	d1 05       	cpc	r29, r1
    229c:	79 f7       	brne	.-34     	; 0x227c <limits_get_state+0x2a>
    229e:	03 c0       	rjmp	.+6      	; 0x22a6 <limits_get_state+0x54>
  uint8_t pin = (LIMIT_PIN & LIMIT_MASK);
  #ifdef INVERT_LIMIT_PIN_MASK
    pin ^= INVERT_LIMIT_PIN_MASK;
  #endif
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_LIMIT_PINS)) { pin ^= LIMIT_MASK; }
  if (pin) {  
    22a0:	11 11       	cpse	r17, r1
    22a2:	e6 cf       	rjmp	.-52     	; 0x2270 <limits_get_state+0x1e>
// Returns limit state as a bit-wise uint8 variable. Each bit indicates an axis limit, where 
// triggered is 1 and not triggered is 0. Invert mask is applied. Axes are defined by their
// number in bit position, i.e. Z_AXIS is (1<<2) or bit 2, and Y_AXIS is (1<<1) or bit 1.
uint8_t limits_get_state()
{
  uint8_t limit_state = 0;
    22a4:	00 e0       	ldi	r16, 0x00	; 0
    for (idx=0; idx<N_AXIS; idx++) {
      if (pin & get_limit_pin_mask(idx)) { limit_state |= (1 << idx); }
    }
  }
  return(limit_state);
}
    22a6:	80 2f       	mov	r24, r16
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	0f 91       	pop	r16
    22b0:	ff 90       	pop	r15
    22b2:	ef 90       	pop	r14
    22b4:	08 95       	ret

000022b6 <__vector_3>:
// homing cycles and will not respond correctly. Upon user request or need, there may be a
// special pinout for an e-stop, but it is generally recommended to just directly connect
// your e-stop switch to the Arduino reset pin, since it is the most correct way to do this.
#ifndef ENABLE_SOFTWARE_DEBOUNCE
  ISR(LIMIT_INT_vect) // DEFAULT: Limit pin change interrupt process. 
  {
    22b6:	1f 92       	push	r1
    22b8:	0f 92       	push	r0
    22ba:	0f b6       	in	r0, 0x3f	; 63
    22bc:	0f 92       	push	r0
    22be:	11 24       	eor	r1, r1
    22c0:	2f 93       	push	r18
    22c2:	3f 93       	push	r19
    22c4:	4f 93       	push	r20
    22c6:	5f 93       	push	r21
    22c8:	6f 93       	push	r22
    22ca:	7f 93       	push	r23
    22cc:	8f 93       	push	r24
    22ce:	9f 93       	push	r25
    22d0:	af 93       	push	r26
    22d2:	bf 93       	push	r27
    22d4:	ef 93       	push	r30
    22d6:	ff 93       	push	r31
    // Ignore limit switches if already in an alarm state or in-process of executing an alarm.
    // When in the alarm state, Grbl should have been reset or will force a reset, so any pending 
    // moves in the planner and serial buffers are all cleared and newly sent blocks will be 
    // locked out until a homing cycle or a kill lock command. Allows the user to disable the hard
    // limit setting if their limits are constantly triggering after a reset and move their axes.
    if (sys.state != STATE_ALARM) { 
    22d8:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    22dc:	81 30       	cpi	r24, 0x01	; 1
    22de:	71 f0       	breq	.+28     	; 0x22fc <__vector_3+0x46>
      if (!(sys_rt_exec_alarm)) {
    22e0:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    22e4:	81 11       	cpse	r24, r1
    22e6:	0a c0       	rjmp	.+20     	; 0x22fc <__vector_3+0x46>
          if (limits_get_state()) {
            mc_reset(); // Initiate system kill.
            bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
          }
        #else
          mc_reset(); // Initiate system kill.
    22e8:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
          bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate hard limit critical event
    22ec:	9f b7       	in	r25, 0x3f	; 63
    22ee:	f8 94       	cli
    22f0:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    22f4:	83 60       	ori	r24, 0x03	; 3
    22f6:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    22fa:	9f bf       	out	0x3f, r25	; 63
        #endif
      }
    }
  }  
    22fc:	ff 91       	pop	r31
    22fe:	ef 91       	pop	r30
    2300:	bf 91       	pop	r27
    2302:	af 91       	pop	r26
    2304:	9f 91       	pop	r25
    2306:	8f 91       	pop	r24
    2308:	7f 91       	pop	r23
    230a:	6f 91       	pop	r22
    230c:	5f 91       	pop	r21
    230e:	4f 91       	pop	r20
    2310:	3f 91       	pop	r19
    2312:	2f 91       	pop	r18
    2314:	0f 90       	pop	r0
    2316:	0f be       	out	0x3f, r0	; 63
    2318:	0f 90       	pop	r0
    231a:	1f 90       	pop	r1
    231c:	18 95       	reti

0000231e <limits_go_home>:
// mask, which prevents the stepper algorithm from executing step pulses. Homing motions typically 
// circumvent the processes for executing motions in normal operation.
// NOTE: Only the abort realtime command can interrupt this process.
// TODO: Move limit pin-specific calls to a general function for portability.
void limits_go_home(uint8_t cycle_mask) 
{
    231e:	2f 92       	push	r2
    2320:	3f 92       	push	r3
    2322:	4f 92       	push	r4
    2324:	5f 92       	push	r5
    2326:	6f 92       	push	r6
    2328:	7f 92       	push	r7
    232a:	8f 92       	push	r8
    232c:	9f 92       	push	r9
    232e:	af 92       	push	r10
    2330:	bf 92       	push	r11
    2332:	cf 92       	push	r12
    2334:	df 92       	push	r13
    2336:	ef 92       	push	r14
    2338:	ff 92       	push	r15
    233a:	0f 93       	push	r16
    233c:	1f 93       	push	r17
    233e:	cf 93       	push	r28
    2340:	df 93       	push	r29
    2342:	cd b7       	in	r28, 0x3d	; 61
    2344:	de b7       	in	r29, 0x3e	; 62
    2346:	6a 97       	sbiw	r28, 0x1a	; 26
    2348:	0f b6       	in	r0, 0x3f	; 63
    234a:	f8 94       	cli
    234c:	de bf       	out	0x3e, r29	; 62
    234e:	0f be       	out	0x3f, r0	; 63
    2350:	cd bf       	out	0x3d, r28	; 61
  if (sys.abort) { return; } // Block if system reset has been issued.
    2352:	90 91 04 06 	lds	r25, 0x0604	; 0x800604 <sys>
    2356:	91 11       	cpse	r25, r1
    2358:	c9 c1       	rjmp	.+914    	; 0x26ec <limits_go_home+0x3ce>
    235a:	88 8f       	std	Y+24, r24	; 0x18
    235c:	23 ee       	ldi	r18, 0xE3	; 227
    235e:	36 e0       	ldi	r19, 0x06	; 6
    2360:	3f 8b       	std	Y+23, r19	; 0x17
    2362:	2e 8b       	std	Y+22, r18	; 0x16
    2364:	79 01       	movw	r14, r18
    2366:	ce 01       	movw	r24, r28
    2368:	01 96       	adiw	r24, 0x01	; 1
    236a:	5c 01       	movw	r10, r24
    236c:	00 e0       	ldi	r16, 0x00	; 0
    236e:	10 e0       	ldi	r17, 0x00	; 0
    2370:	41 2c       	mov	r4, r1
    2372:	51 2c       	mov	r5, r1
    2374:	32 01       	movw	r6, r4
    step_pin[idx] = get_step_pin_mask(idx);
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    2376:	98 8d       	ldd	r25, Y+24	; 0x18
    2378:	c9 2e       	mov	r12, r25
    237a:	d1 2c       	mov	r13, r1
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    // Initialize step pin masks
    step_pin[idx] = get_step_pin_mask(idx);
    237c:	80 2f       	mov	r24, r16
    237e:	0e 94 a6 2b 	call	0x574c	; 0x574c <get_step_pin_mask>
    2382:	d5 01       	movw	r26, r10
    2384:	8d 93       	st	X+, r24
    2386:	5d 01       	movw	r10, r26
    #ifdef COREXY    
      if ((idx==A_MOTOR)||(idx==B_MOTOR)) { step_pin[idx] = (get_step_pin_mask(X_AXIS)|get_step_pin_mask(Y_AXIS)); } 
    #endif

    if (bit_istrue(cycle_mask,bit(idx))) { 
    2388:	d9 8a       	std	Y+17, r13	; 0x11
    238a:	c8 8a       	std	Y+16, r12	; 0x10
    238c:	c6 01       	movw	r24, r12
    238e:	00 2e       	mov	r0, r16
    2390:	02 c0       	rjmp	.+4      	; 0x2396 <limits_go_home+0x78>
    2392:	95 95       	asr	r25
    2394:	87 95       	ror	r24
    2396:	0a 94       	dec	r0
    2398:	e2 f7       	brpl	.-8      	; 0x2392 <limits_go_home+0x74>
    239a:	80 ff       	sbrs	r24, 0
    239c:	19 c0       	rjmp	.+50     	; 0x23d0 <limits_go_home+0xb2>
      // Set target based on max_travel setting. Ensure homing switches engaged with search scalar.
      // NOTE: settings.max_travel[] is stored as a negative value.
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    239e:	20 e0       	ldi	r18, 0x00	; 0
    23a0:	30 e0       	ldi	r19, 0x00	; 0
    23a2:	40 ec       	ldi	r20, 0xC0	; 192
    23a4:	5f eb       	ldi	r21, 0xBF	; 191
    23a6:	f7 01       	movw	r30, r14
    23a8:	64 a1       	ldd	r22, Z+36	; 0x24
    23aa:	75 a1       	ldd	r23, Z+37	; 0x25
    23ac:	86 a1       	ldd	r24, Z+38	; 0x26
    23ae:	97 a1       	ldd	r25, Z+39	; 0x27
    23b0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    23b4:	86 2e       	mov	r8, r22
    23b6:	97 2e       	mov	r9, r23
    23b8:	28 2e       	mov	r2, r24
    23ba:	39 2e       	mov	r3, r25
    23bc:	a3 01       	movw	r20, r6
    23be:	92 01       	movw	r18, r4
    23c0:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    23c4:	88 23       	and	r24, r24
    23c6:	24 f0       	brlt	.+8      	; 0x23d0 <limits_go_home+0xb2>
    23c8:	48 2c       	mov	r4, r8
    23ca:	59 2c       	mov	r5, r9
    23cc:	62 2c       	mov	r6, r2
    23ce:	73 2c       	mov	r7, r3
    23d0:	0f 5f       	subi	r16, 0xFF	; 255
    23d2:	1f 4f       	sbci	r17, 0xFF	; 255
    23d4:	f4 e0       	ldi	r31, 0x04	; 4
    23d6:	ef 0e       	add	r14, r31
    23d8:	f1 1c       	adc	r15, r1
  uint8_t n_cycle = (2*N_HOMING_LOCATE_CYCLE+1);
  uint8_t step_pin[N_AXIS];
  float target[N_AXIS];
  float max_travel = 0.0;
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {  
    23da:	03 30       	cpi	r16, 0x03	; 3
    23dc:	11 05       	cpc	r17, r1
    23de:	71 f6       	brne	.-100    	; 0x237c <limits_go_home+0x5e>
    23e0:	28 88       	ldd	r2, Y+16	; 0x10
    23e2:	39 88       	ldd	r3, Y+17	; 0x11
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
  float homing_rate = settings.homing_seek_rate;
    23e4:	80 91 26 07 	lds	r24, 0x0726	; 0x800726 <settings+0x43>
    23e8:	90 91 27 07 	lds	r25, 0x0727	; 0x800727 <settings+0x44>
    23ec:	a0 91 28 07 	lds	r26, 0x0728	; 0x800728 <settings+0x45>
    23f0:	b0 91 29 07 	lds	r27, 0x0729	; 0x800729 <settings+0x46>
    23f4:	8a 8b       	std	Y+18, r24	; 0x12
    23f6:	9b 8b       	std	Y+19, r25	; 0x13
    23f8:	ac 8b       	std	Y+20, r26	; 0x14
    23fa:	bd 8b       	std	Y+21, r27	; 0x15
    23fc:	94 e0       	ldi	r25, 0x04	; 4
    23fe:	98 8b       	std	Y+16, r25	; 0x10
      max_travel = max(max_travel,(-HOMING_AXIS_SEARCH_SCALAR)*settings.max_travel[idx]);
    }
  }

  // Set search mode with approach at seek rate to quickly engage the specified cycle_mask limit switches.
  bool approach = true;
    2400:	01 e0       	ldi	r16, 0x01	; 1
  float homing_rate = settings.homing_seek_rate;

  uint8_t limit_state, axislock, n_active_axis;
  do {

    system_convert_array_steps_to_mpos(target,sys.position);
    2402:	68 e0       	ldi	r22, 0x08	; 8
    2404:	76 e0       	ldi	r23, 0x06	; 6
    2406:	ce 01       	movw	r24, r28
    2408:	04 96       	adiw	r24, 0x04	; 4
    240a:	0e 94 97 38 	call	0x712e	; 0x712e <system_convert_array_steps_to_mpos>
        #else
          sys.position[idx] = 0;
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    240e:	80 91 21 07 	lds	r24, 0x0721	; 0x800721 <settings+0x3e>
    2412:	e8 2e       	mov	r14, r24
    2414:	f1 2c       	mov	r15, r1
    2416:	ae 01       	movw	r20, r28
    2418:	4c 5f       	subi	r20, 0xFC	; 252
    241a:	5f 4f       	sbci	r21, 0xFF	; 255
    241c:	0f 2e       	mov	r0, r31
    241e:	f4 e0       	ldi	r31, 0x04	; 4
    2420:	cf 2e       	mov	r12, r31
    2422:	f6 e0       	ldi	r31, 0x06	; 6
    2424:	df 2e       	mov	r13, r31
    2426:	f0 2d       	mov	r31, r0
    2428:	f6 01       	movw	r30, r12
    242a:	de 01       	movw	r26, r28
    242c:	11 96       	adiw	r26, 0x01	; 1
    242e:	80 e0       	ldi	r24, 0x00	; 0
    2430:	90 e0       	ldi	r25, 0x00	; 0

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    2432:	60 e0       	ldi	r22, 0x00	; 0
  do {

    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    2434:	10 e0       	ldi	r17, 0x00	; 0
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
          if (approach) { target[idx] = -max_travel; }
          else { target[idx] = max_travel; }
        } else { 
          if (approach) { target[idx] = max_travel; }
          else { target[idx] = -max_travel; }
    2436:	53 01       	movw	r10, r6
    2438:	42 01       	movw	r8, r4
    243a:	b7 fa       	bst	r11, 7
    243c:	b0 94       	com	r11
    243e:	b7 f8       	bld	r11, 7
    2440:	b0 94       	com	r11
    2442:	ba 8f       	std	Y+26, r27	; 0x1a
    2444:	a9 8f       	std	Y+25, r26	; 0x19
    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
      // Set target location for active axes and setup computation for homing rate.
      if (bit_istrue(cycle_mask,bit(idx))) {
    2446:	91 01       	movw	r18, r2
    2448:	08 2e       	mov	r0, r24
    244a:	02 c0       	rjmp	.+4      	; 0x2450 <limits_go_home+0x132>
    244c:	35 95       	asr	r19
    244e:	27 95       	ror	r18
    2450:	0a 94       	dec	r0
    2452:	e2 f7       	brpl	.-8      	; 0x244c <limits_go_home+0x12e>
    2454:	20 ff       	sbrs	r18, 0
    2456:	31 c0       	rjmp	.+98     	; 0x24ba <limits_go_home+0x19c>
        n_active_axis++;
    2458:	6f 5f       	subi	r22, 0xFF	; 255
            sys.position[A_MOTOR] = sys.position[B_MOTOR] = axis_position;
          } else { 
            sys.position[Z_AXIS] = 0; 
          }
        #else
          sys.position[idx] = 0;
    245a:	14 82       	std	Z+4, r1	; 0x04
    245c:	15 82       	std	Z+5, r1	; 0x05
    245e:	16 82       	std	Z+6, r1	; 0x06
    2460:	17 82       	std	Z+7, r1	; 0x07
        #endif
        // Set target direction based on cycle mask and homing cycle approach state.
        // NOTE: This happens to compile smaller than any other implementation tried.
        if (bit_istrue(settings.homing_dir_mask,bit(idx))) {
    2462:	97 01       	movw	r18, r14
    2464:	08 2e       	mov	r0, r24
    2466:	02 c0       	rjmp	.+4      	; 0x246c <limits_go_home+0x14e>
    2468:	35 95       	asr	r19
    246a:	27 95       	ror	r18
    246c:	0a 94       	dec	r0
    246e:	e2 f7       	brpl	.-8      	; 0x2468 <limits_go_home+0x14a>
    2470:	20 ff       	sbrs	r18, 0
    2472:	10 c0       	rjmp	.+32     	; 0x2494 <limits_go_home+0x176>
          if (approach) { target[idx] = -max_travel; }
    2474:	00 23       	and	r16, r16
    2476:	39 f0       	breq	.+14     	; 0x2486 <limits_go_home+0x168>
    2478:	da 01       	movw	r26, r20
    247a:	8d 92       	st	X+, r8
    247c:	9d 92       	st	X+, r9
    247e:	ad 92       	st	X+, r10
    2480:	bc 92       	st	X, r11
    2482:	13 97       	sbiw	r26, 0x03	; 3
    2484:	16 c0       	rjmp	.+44     	; 0x24b2 <limits_go_home+0x194>
          else { target[idx] = max_travel; }
    2486:	da 01       	movw	r26, r20
    2488:	4d 92       	st	X+, r4
    248a:	5d 92       	st	X+, r5
    248c:	6d 92       	st	X+, r6
    248e:	7c 92       	st	X, r7
    2490:	13 97       	sbiw	r26, 0x03	; 3
    2492:	0f c0       	rjmp	.+30     	; 0x24b2 <limits_go_home+0x194>
        } else { 
          if (approach) { target[idx] = max_travel; }
    2494:	00 23       	and	r16, r16
    2496:	39 f0       	breq	.+14     	; 0x24a6 <limits_go_home+0x188>
    2498:	da 01       	movw	r26, r20
    249a:	4d 92       	st	X+, r4
    249c:	5d 92       	st	X+, r5
    249e:	6d 92       	st	X+, r6
    24a0:	7c 92       	st	X, r7
    24a2:	13 97       	sbiw	r26, 0x03	; 3
    24a4:	06 c0       	rjmp	.+12     	; 0x24b2 <limits_go_home+0x194>
          else { target[idx] = -max_travel; }
    24a6:	da 01       	movw	r26, r20
    24a8:	8d 92       	st	X+, r8
    24aa:	9d 92       	st	X+, r9
    24ac:	ad 92       	st	X+, r10
    24ae:	bc 92       	st	X, r11
    24b0:	13 97       	sbiw	r26, 0x03	; 3
        }        
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
    24b2:	a9 8d       	ldd	r26, Y+25	; 0x19
    24b4:	ba 8d       	ldd	r27, Y+26	; 0x1a
    24b6:	2c 91       	ld	r18, X
    24b8:	12 2b       	or	r17, r18
    24ba:	01 96       	adiw	r24, 0x01	; 1
    24bc:	29 8d       	ldd	r18, Y+25	; 0x19
    24be:	3a 8d       	ldd	r19, Y+26	; 0x1a
    24c0:	2f 5f       	subi	r18, 0xFF	; 255
    24c2:	3f 4f       	sbci	r19, 0xFF	; 255
    24c4:	3a 8f       	std	Y+26, r19	; 0x1a
    24c6:	29 8f       	std	Y+25, r18	; 0x19
    24c8:	4c 5f       	subi	r20, 0xFC	; 252
    24ca:	5f 4f       	sbci	r21, 0xFF	; 255
    24cc:	34 96       	adiw	r30, 0x04	; 4
    system_convert_array_steps_to_mpos(target,sys.position);

    // Initialize and declare variables needed for homing routine.
    axislock = 0;
    n_active_axis = 0;
    for (idx=0; idx<N_AXIS; idx++) {
    24ce:	83 30       	cpi	r24, 0x03	; 3
    24d0:	91 05       	cpc	r25, r1
    24d2:	09 f0       	breq	.+2      	; 0x24d6 <limits_go_home+0x1b8>
    24d4:	b8 cf       	rjmp	.-144    	; 0x2446 <limits_go_home+0x128>
        // Apply axislock to the step port pins active in this cycle.
        axislock |= step_pin[idx];
      }

    }
    homing_rate *= sqrt(n_active_axis); // [sqrt(N_AXIS)] Adjust so individual axes all move at homing rate.
    24d6:	46 2e       	mov	r4, r22
    24d8:	51 2c       	mov	r5, r1
    24da:	61 2c       	mov	r6, r1
    24dc:	71 2c       	mov	r7, r1
    24de:	c3 01       	movw	r24, r6
    24e0:	b2 01       	movw	r22, r4
    24e2:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    24e6:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    24ea:	9b 01       	movw	r18, r22
    24ec:	ac 01       	movw	r20, r24
    24ee:	6a 89       	ldd	r22, Y+18	; 0x12
    24f0:	7b 89       	ldd	r23, Y+19	; 0x13
    24f2:	8c 89       	ldd	r24, Y+20	; 0x14
    24f4:	9d 89       	ldd	r25, Y+21	; 0x15
    24f6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    24fa:	4b 01       	movw	r8, r22
    24fc:	5c 01       	movw	r10, r24
    sys.homing_axis_lock = axislock;
    24fe:	10 93 21 06 	sts	0x0621, r17	; 0x800621 <sys+0x1d>

    plan_sync_position(); // Sync planner position to current machine position.
    2502:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <plan_sync_position>
    
    // Perform homing cycle. Planner buffer should be empty, as required to initiate the homing cycle.
    #ifdef USE_LINE_NUMBERS
      plan_buffer_line(target, homing_rate, false, HOMING_CYCLE_LINE_NUMBER); // Bypass mc_line(). Directly plan homing motion.
    #else
      plan_buffer_line(target, homing_rate, false); // Bypass mc_line(). Directly plan homing motion.
    2506:	20 e0       	ldi	r18, 0x00	; 0
    2508:	b5 01       	movw	r22, r10
    250a:	a4 01       	movw	r20, r8
    250c:	ce 01       	movw	r24, r28
    250e:	04 96       	adiw	r24, 0x04	; 4
    2510:	0e 94 38 1b 	call	0x3670	; 0x3670 <plan_buffer_line>
    #endif
    
    st_prep_buffer(); // Prep and fill segment buffer from newly planned block.
    2514:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <st_prep_buffer>
    st_wake_up(); // Initiate motion
    2518:	0e 94 45 2c 	call	0x588a	; 0x588a <st_wake_up>
    do {
      if (approach) {
    251c:	00 23       	and	r16, r16
    251e:	f1 f0       	breq	.+60     	; 0x255c <limits_go_home+0x23e>
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
    2520:	0e 94 29 11 	call	0x2252	; 0x2252 <limits_get_state>
    2524:	fe 01       	movw	r30, r28
    2526:	31 96       	adiw	r30, 0x01	; 1
    2528:	20 e0       	ldi	r18, 0x00	; 0
    252a:	30 e0       	ldi	r19, 0x00	; 0
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
            if (limit_state & (1 << idx)) { 
    252c:	68 2f       	mov	r22, r24
    252e:	70 e0       	ldi	r23, 0x00	; 0
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
          if (axislock & step_pin[idx]) {
    2530:	81 91       	ld	r24, Z+
    2532:	98 2f       	mov	r25, r24
    2534:	91 23       	and	r25, r17
    2536:	59 f0       	breq	.+22     	; 0x254e <limits_go_home+0x230>
            if (limit_state & (1 << idx)) { 
    2538:	ab 01       	movw	r20, r22
    253a:	02 2e       	mov	r0, r18
    253c:	02 c0       	rjmp	.+4      	; 0x2542 <limits_go_home+0x224>
    253e:	55 95       	asr	r21
    2540:	47 95       	ror	r20
    2542:	0a 94       	dec	r0
    2544:	e2 f7       	brpl	.-8      	; 0x253e <limits_go_home+0x220>
    2546:	40 ff       	sbrs	r20, 0
    2548:	02 c0       	rjmp	.+4      	; 0x254e <limits_go_home+0x230>
              #ifdef COREXY
                if (idx==Z_AXIS) { axislock &= ~(step_pin[Z_AXIS]); }
                else { axislock &= ~(step_pin[A_MOTOR]|step_pin[B_MOTOR]); }
              #else
                axislock &= ~(step_pin[idx]); 
    254a:	80 95       	com	r24
    254c:	18 23       	and	r17, r24
    254e:	2f 5f       	subi	r18, 0xFF	; 255
    2550:	3f 4f       	sbci	r19, 0xFF	; 255
    st_wake_up(); // Initiate motion
    do {
      if (approach) {
        // Check limit state. Lock out cycle axes when they change.
        limit_state = limits_get_state();
        for (idx=0; idx<N_AXIS; idx++) {
    2552:	23 30       	cpi	r18, 0x03	; 3
    2554:	31 05       	cpc	r19, r1
    2556:	61 f7       	brne	.-40     	; 0x2530 <limits_go_home+0x212>
                axislock &= ~(step_pin[idx]); 
              #endif
            }
          }
        }
        sys.homing_axis_lock = axislock;
    2558:	10 93 21 06 	sts	0x0621, r17	; 0x800621 <sys+0x1d>
      }

      st_prep_buffer(); // Check and prep segment buffer. NOTE: Should take no longer than 200us.
    255c:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <st_prep_buffer>

      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
    2560:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    2564:	84 73       	andi	r24, 0x34	; 52
    2566:	c9 f0       	breq	.+50     	; 0x259a <limits_go_home+0x27c>
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
    2568:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    256c:	80 73       	andi	r24, 0x30	; 48
    256e:	39 f4       	brne	.+14     	; 0x257e <limits_go_home+0x260>
    2570:	01 11       	cpse	r16, r1
    2572:	b7 c0       	rjmp	.+366    	; 0x26e2 <limits_go_home+0x3c4>
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
    2574:	0e 94 29 11 	call	0x2252	; 0x2252 <limits_get_state>
    2578:	38 8d       	ldd	r19, Y+24	; 0x18
    257a:	83 23       	and	r24, r19
    257c:	29 f0       	breq	.+10     	; 0x2588 <limits_go_home+0x26a>
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
          mc_reset(); // Stop motors, if they are running.
    257e:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
          protocol_execute_realtime();
    2582:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
          return;
    2586:	b2 c0       	rjmp	.+356    	; 0x26ec <limits_go_home+0x3ce>
        } else {
          // Pull-off motion complete. Disable CYCLE_STOP from executing.
          bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    2588:	9f b7       	in	r25, 0x3f	; 63
    258a:	f8 94       	cli
    258c:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    2590:	8b 7f       	andi	r24, 0xFB	; 251
    2592:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    2596:	9f bf       	out	0x3f, r25	; 63
          break;
    2598:	04 c0       	rjmp	.+8      	; 0x25a2 <limits_go_home+0x284>
        } 
      }

    } while (STEP_MASK & axislock);
    259a:	81 2f       	mov	r24, r17
    259c:	8c 71       	andi	r24, 0x1C	; 28
    259e:	09 f0       	breq	.+2      	; 0x25a2 <limits_go_home+0x284>
    25a0:	bd cf       	rjmp	.-134    	; 0x251c <limits_go_home+0x1fe>

    st_reset(); // Immediately force kill steppers and reset step segment buffer.
    25a2:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <st_reset>
    plan_reset(); // Reset planner buffer to zero planner current position and to clear previous motions.
    25a6:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <plan_reset>

    delay_ms(settings.homing_debounce_delay); // Delay to allow transient dynamics to dissipate.
    25aa:	aa e2       	ldi	r26, 0x2A	; 42
    25ac:	b7 e0       	ldi	r27, 0x07	; 7
    25ae:	8d 91       	ld	r24, X+
    25b0:	9c 91       	ld	r25, X
    25b2:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>

    // Reverse direction and reset homing rate for locate cycle(s).
    approach = !approach;
    25b6:	b1 e0       	ldi	r27, 0x01	; 1
    25b8:	0b 27       	eor	r16, r27

    // After first cycle, homing enters locating phase. Shorten search to pull-off distance.
    if (approach) { 
    25ba:	d1 f0       	breq	.+52     	; 0x25f0 <limits_go_home+0x2d2>
      max_travel = settings.homing_pulloff*HOMING_AXIS_LOCATE_SCALAR; 
    25bc:	20 e0       	ldi	r18, 0x00	; 0
    25be:	30 e0       	ldi	r19, 0x00	; 0
    25c0:	40 ea       	ldi	r20, 0xA0	; 160
    25c2:	50 e4       	ldi	r21, 0x40	; 64
    25c4:	ec e2       	ldi	r30, 0x2C	; 44
    25c6:	f7 e0       	ldi	r31, 0x07	; 7
    25c8:	60 81       	ld	r22, Z
    25ca:	71 81       	ldd	r23, Z+1	; 0x01
    25cc:	82 81       	ldd	r24, Z+2	; 0x02
    25ce:	93 81       	ldd	r25, Z+3	; 0x03
    25d0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    25d4:	2b 01       	movw	r4, r22
    25d6:	3c 01       	movw	r6, r24
      homing_rate = settings.homing_feed_rate;
    25d8:	a2 e2       	ldi	r26, 0x22	; 34
    25da:	b7 e0       	ldi	r27, 0x07	; 7
    25dc:	8d 91       	ld	r24, X+
    25de:	9d 91       	ld	r25, X+
    25e0:	0d 90       	ld	r0, X+
    25e2:	bc 91       	ld	r27, X
    25e4:	a0 2d       	mov	r26, r0
    25e6:	8a 8b       	std	Y+18, r24	; 0x12
    25e8:	9b 8b       	std	Y+19, r25	; 0x13
    25ea:	ac 8b       	std	Y+20, r26	; 0x14
    25ec:	bd 8b       	std	Y+21, r27	; 0x15
    25ee:	11 c0       	rjmp	.+34     	; 0x2612 <limits_go_home+0x2f4>
    } else {
      max_travel = settings.homing_pulloff;    
    25f0:	ec e2       	ldi	r30, 0x2C	; 44
    25f2:	f7 e0       	ldi	r31, 0x07	; 7
    25f4:	40 80       	ld	r4, Z
    25f6:	51 80       	ldd	r5, Z+1	; 0x01
    25f8:	62 80       	ldd	r6, Z+2	; 0x02
    25fa:	73 80       	ldd	r7, Z+3	; 0x03
      homing_rate = settings.homing_seek_rate;
    25fc:	a6 e2       	ldi	r26, 0x26	; 38
    25fe:	b7 e0       	ldi	r27, 0x07	; 7
    2600:	8d 91       	ld	r24, X+
    2602:	9d 91       	ld	r25, X+
    2604:	0d 90       	ld	r0, X+
    2606:	bc 91       	ld	r27, X
    2608:	a0 2d       	mov	r26, r0
    260a:	8a 8b       	std	Y+18, r24	; 0x12
    260c:	9b 8b       	std	Y+19, r25	; 0x13
    260e:	ac 8b       	std	Y+20, r26	; 0x14
    2610:	bd 8b       	std	Y+21, r27	; 0x15
    2612:	b8 89       	ldd	r27, Y+16	; 0x10
    2614:	b1 50       	subi	r27, 0x01	; 1
    2616:	b8 8b       	std	Y+16, r27	; 0x10
    }
    
  } while (n_cycle-- > 0);
    2618:	b1 11       	cpse	r27, r1
    261a:	f3 ce       	rjmp	.-538    	; 0x2402 <limits_go_home+0xe4>
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    261c:	e0 90 21 07 	lds	r14, 0x0721	; 0x800721 <settings+0x3e>
    2620:	f1 2c       	mov	r15, r1
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    2622:	80 90 2c 07 	lds	r8, 0x072C	; 0x80072c <settings+0x49>
    2626:	90 90 2d 07 	lds	r9, 0x072D	; 0x80072d <settings+0x4a>
    262a:	a0 90 2e 07 	lds	r10, 0x072E	; 0x80072e <settings+0x4b>
    262e:	b0 90 2f 07 	lds	r11, 0x072F	; 0x80072f <settings+0x4c>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    2632:	24 01       	movw	r4, r8
    2634:	35 01       	movw	r6, r10
    2636:	77 fa       	bst	r7, 7
    2638:	70 94       	com	r7
    263a:	77 f8       	bld	r7, 7
    263c:	70 94       	com	r7
    263e:	00 e0       	ldi	r16, 0x00	; 0
    2640:	10 e0       	ldi	r17, 0x00	; 0
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    // NOTE: settings.max_travel[] is stored as a negative value.
    if (cycle_mask & bit(idx)) {
    2642:	c1 01       	movw	r24, r2
    2644:	00 2e       	mov	r0, r16
    2646:	02 c0       	rjmp	.+4      	; 0x264c <limits_go_home+0x32e>
    2648:	95 95       	asr	r25
    264a:	87 95       	ror	r24
    264c:	0a 94       	dec	r0
    264e:	e2 f7       	brpl	.-8      	; 0x2648 <limits_go_home+0x32a>
    2650:	80 ff       	sbrs	r24, 0
    2652:	36 c0       	rjmp	.+108    	; 0x26c0 <limits_go_home+0x3a2>
      #ifdef HOMING_FORCE_SET_ORIGIN
        set_axis_position = 0;
      #else 
        if ( bit_istrue(settings.homing_dir_mask,bit(idx)) ) {
    2654:	c7 01       	movw	r24, r14
    2656:	00 2e       	mov	r0, r16
    2658:	02 c0       	rjmp	.+4      	; 0x265e <limits_go_home+0x340>
    265a:	95 95       	asr	r25
    265c:	87 95       	ror	r24
    265e:	0a 94       	dec	r0
    2660:	e2 f7       	brpl	.-8      	; 0x265a <limits_go_home+0x33c>
    2662:	80 ff       	sbrs	r24, 0
    2664:	15 c0       	rjmp	.+42     	; 0x2690 <limits_go_home+0x372>
          set_axis_position = lround((settings.max_travel[idx]+settings.homing_pulloff)*settings.steps_per_mm[idx]);
    2666:	ee 89       	ldd	r30, Y+22	; 0x16
    2668:	ff 89       	ldd	r31, Y+23	; 0x17
    266a:	24 a1       	ldd	r18, Z+36	; 0x24
    266c:	35 a1       	ldd	r19, Z+37	; 0x25
    266e:	46 a1       	ldd	r20, Z+38	; 0x26
    2670:	57 a1       	ldd	r21, Z+39	; 0x27
    2672:	c5 01       	movw	r24, r10
    2674:	b4 01       	movw	r22, r8
    2676:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    267a:	ae 89       	ldd	r26, Y+22	; 0x16
    267c:	bf 89       	ldd	r27, Y+23	; 0x17
    267e:	2d 91       	ld	r18, X+
    2680:	3d 91       	ld	r19, X+
    2682:	4d 91       	ld	r20, X+
    2684:	5c 91       	ld	r21, X
    2686:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    268a:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <lround>
    268e:	0c c0       	rjmp	.+24     	; 0x26a8 <limits_go_home+0x38a>
        } else {
          set_axis_position = lround(-settings.homing_pulloff*settings.steps_per_mm[idx]);
    2690:	ee 89       	ldd	r30, Y+22	; 0x16
    2692:	ff 89       	ldd	r31, Y+23	; 0x17
    2694:	20 81       	ld	r18, Z
    2696:	31 81       	ldd	r19, Z+1	; 0x01
    2698:	42 81       	ldd	r20, Z+2	; 0x02
    269a:	53 81       	ldd	r21, Z+3	; 0x03
    269c:	c3 01       	movw	r24, r6
    269e:	b2 01       	movw	r22, r4
    26a0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    26a4:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <lround>
          sys.position[B_MOTOR] = off_axis_position - set_axis_position;
        } else {
          sys.position[idx] = set_axis_position;
        }        
      #else 
        sys.position[idx] = set_axis_position;
    26a8:	d6 01       	movw	r26, r12
    26aa:	14 96       	adiw	r26, 0x04	; 4
    26ac:	6c 93       	st	X, r22
    26ae:	14 97       	sbiw	r26, 0x04	; 4
    26b0:	15 96       	adiw	r26, 0x05	; 5
    26b2:	7c 93       	st	X, r23
    26b4:	15 97       	sbiw	r26, 0x05	; 5
    26b6:	16 96       	adiw	r26, 0x06	; 6
    26b8:	8c 93       	st	X, r24
    26ba:	16 97       	sbiw	r26, 0x06	; 6
    26bc:	17 96       	adiw	r26, 0x07	; 7
    26be:	9c 93       	st	X, r25
    26c0:	0f 5f       	subi	r16, 0xFF	; 255
    26c2:	1f 4f       	sbci	r17, 0xFF	; 255
    26c4:	b4 e0       	ldi	r27, 0x04	; 4
    26c6:	cb 0e       	add	r12, r27
    26c8:	d1 1c       	adc	r13, r1
    26ca:	ee 89       	ldd	r30, Y+22	; 0x16
    26cc:	ff 89       	ldd	r31, Y+23	; 0x17
    26ce:	34 96       	adiw	r30, 0x04	; 4
    26d0:	ff 8b       	std	Y+23, r31	; 0x17
    26d2:	ee 8b       	std	Y+22, r30	; 0x16
  // set up pull-off maneuver from axes limit switches that have been homed. This provides
  // some initial clearance off the switches and should also help prevent them from falsely
  // triggering when hard limits are enabled or when more than one axes shares a limit pin.
  int32_t set_axis_position;
  // Set machine positions for homed limit switches. Don't update non-homed axes.
  for (idx=0; idx<N_AXIS; idx++) {
    26d4:	03 30       	cpi	r16, 0x03	; 3
    26d6:	11 05       	cpc	r17, r1
    26d8:	09 f0       	breq	.+2      	; 0x26dc <limits_go_home+0x3be>
    26da:	b3 cf       	rjmp	.-154    	; 0x2642 <limits_go_home+0x324>
        sys.position[idx] = set_axis_position;
      #endif

    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    26dc:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <plan_sync_position>
    26e0:	05 c0       	rjmp	.+10     	; 0x26ec <limits_go_home+0x3ce>
      // Exit routines: No time to run protocol_execute_realtime() in this loop.
      if (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET | EXEC_CYCLE_STOP)) {
        // Homing failure: Limit switches are still engaged after pull-off motion
        if ( (sys_rt_exec_state & (EXEC_SAFETY_DOOR | EXEC_RESET)) ||  // Safety door or reset issued
           (!approach && (limits_get_state() & cycle_mask)) ||  // Limit switch still engaged after pull-off motion
           ( approach && (sys_rt_exec_state & EXEC_CYCLE_STOP)) ) { // Limit switch not found during approach.
    26e2:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    26e6:	82 ff       	sbrs	r24, 2
    26e8:	4f cf       	rjmp	.-354    	; 0x2588 <limits_go_home+0x26a>
    26ea:	49 cf       	rjmp	.-366    	; 0x257e <limits_go_home+0x260>
    }
  }
  plan_sync_position(); // Sync planner position to homed machine position.
    
  // sys.state = STATE_HOMING; // Ensure system state set as homing before returning. 
}
    26ec:	6a 96       	adiw	r28, 0x1a	; 26
    26ee:	0f b6       	in	r0, 0x3f	; 63
    26f0:	f8 94       	cli
    26f2:	de bf       	out	0x3e, r29	; 62
    26f4:	0f be       	out	0x3f, r0	; 63
    26f6:	cd bf       	out	0x3d, r28	; 61
    26f8:	df 91       	pop	r29
    26fa:	cf 91       	pop	r28
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	ff 90       	pop	r15
    2702:	ef 90       	pop	r14
    2704:	df 90       	pop	r13
    2706:	cf 90       	pop	r12
    2708:	bf 90       	pop	r11
    270a:	af 90       	pop	r10
    270c:	9f 90       	pop	r9
    270e:	8f 90       	pop	r8
    2710:	7f 90       	pop	r7
    2712:	6f 90       	pop	r6
    2714:	5f 90       	pop	r5
    2716:	4f 90       	pop	r4
    2718:	3f 90       	pop	r3
    271a:	2f 90       	pop	r2
    271c:	08 95       	ret

0000271e <limits_soft_check>:


// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
    271e:	9f 92       	push	r9
    2720:	af 92       	push	r10
    2722:	bf 92       	push	r11
    2724:	cf 92       	push	r12
    2726:	df 92       	push	r13
    2728:	ef 92       	push	r14
    272a:	ff 92       	push	r15
    272c:	0f 93       	push	r16
    272e:	1f 93       	push	r17
    2730:	cf 93       	push	r28
    2732:	df 93       	push	r29
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    #endif
    
    if (sys.soft_limit) {
    2734:	90 90 07 06 	lds	r9, 0x0607	; 0x800607 <sys+0x3>
    2738:	ec 01       	movw	r28, r24
    273a:	0f 2e       	mov	r0, r31
    273c:	f7 e0       	ldi	r31, 0x07	; 7
    273e:	af 2e       	mov	r10, r31
    2740:	f7 e0       	ldi	r31, 0x07	; 7
    2742:	bf 2e       	mov	r11, r31
    2744:	f0 2d       	mov	r31, r0
    2746:	8c 01       	movw	r16, r24
    2748:	04 5f       	subi	r16, 0xF4	; 244
    274a:	1f 4f       	sbci	r17, 0xFF	; 255
      } else {
        if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
      }
    #else  
      // NOTE: max_travel is stored as negative
      if (target[idx] > 0 || target[idx] < settings.max_travel[idx]) { sys.soft_limit = true; }
    274c:	c9 90       	ld	r12, Y+
    274e:	d9 90       	ld	r13, Y+
    2750:	e9 90       	ld	r14, Y+
    2752:	f9 90       	ld	r15, Y+
    2754:	20 e0       	ldi	r18, 0x00	; 0
    2756:	30 e0       	ldi	r19, 0x00	; 0
    2758:	a9 01       	movw	r20, r18
    275a:	c7 01       	movw	r24, r14
    275c:	b6 01       	movw	r22, r12
    275e:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    2762:	18 16       	cp	r1, r24
    2764:	64 f0       	brlt	.+24     	; 0x277e <limits_soft_check+0x60>
    2766:	f5 01       	movw	r30, r10
    2768:	21 91       	ld	r18, Z+
    276a:	31 91       	ld	r19, Z+
    276c:	41 91       	ld	r20, Z+
    276e:	51 91       	ld	r21, Z+
    2770:	5f 01       	movw	r10, r30
    2772:	c7 01       	movw	r24, r14
    2774:	b6 01       	movw	r22, r12
    2776:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    277a:	88 23       	and	r24, r24
    277c:	24 f4       	brge	.+8      	; 0x2786 <limits_soft_check+0x68>
    277e:	81 e0       	ldi	r24, 0x01	; 1
    2780:	80 93 07 06 	sts	0x0607, r24	; 0x800607 <sys+0x3>
    2784:	02 c0       	rjmp	.+4      	; 0x278a <limits_soft_check+0x6c>
    #endif
    
    if (sys.soft_limit) {
    2786:	99 20       	and	r9, r9
    2788:	19 f1       	breq	.+70     	; 0x27d0 <limits_soft_check+0xb2>
      // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within 
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
    278a:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    278e:	88 30       	cpi	r24, 0x08	; 8
    2790:	91 f4       	brne	.+36     	; 0x27b6 <limits_soft_check+0x98>
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
    2792:	9f b7       	in	r25, 0x3f	; 63
    2794:	f8 94       	cli
    2796:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    279a:	88 60       	ori	r24, 0x08	; 8
    279c:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    27a0:	9f bf       	out	0x3f, r25	; 63
        do {
          protocol_execute_realtime();
          if (sys.abort) { return; }
    27a2:	c4 e0       	ldi	r28, 0x04	; 4
    27a4:	d6 e0       	ldi	r29, 0x06	; 6
      // workspace volume so just come to a controlled stop so position is not lost. When complete
      // enter alarm mode.
      if (sys.state == STATE_CYCLE) {
        bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD);
        do {
          protocol_execute_realtime();
    27a6:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
          if (sys.abort) { return; }
    27aa:	88 81       	ld	r24, Y
    27ac:	81 11       	cpse	r24, r1
    27ae:	14 c0       	rjmp	.+40     	; 0x27d8 <limits_soft_check+0xba>
        } while ( sys.state != STATE_IDLE );
    27b0:	89 81       	ldd	r24, Y+1	; 0x01
    27b2:	81 11       	cpse	r24, r1
    27b4:	f8 cf       	rjmp	.-16     	; 0x27a6 <limits_soft_check+0x88>
      }
    
      mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    27b6:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
    27ba:	9f b7       	in	r25, 0x3f	; 63
    27bc:	f8 94       	cli
    27be:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    27c2:	85 60       	ori	r24, 0x05	; 5
    27c4:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    27c8:	9f bf       	out	0x3f, r25	; 63
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    27ca:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
      return;
    27ce:	04 c0       	rjmp	.+8      	; 0x27d8 <limits_soft_check+0xba>
// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
void limits_soft_check(float *target)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    27d0:	c0 17       	cp	r28, r16
    27d2:	d1 07       	cpc	r29, r17
    27d4:	09 f0       	breq	.+2      	; 0x27d8 <limits_soft_check+0xba>
    27d6:	ba cf       	rjmp	.-140    	; 0x274c <limits_soft_check+0x2e>
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_SOFT_LIMIT|EXEC_CRITICAL_EVENT)); // Indicate soft limit critical event
      protocol_execute_realtime(); // Execute to enter critical event loop and system abort
      return;
    }
  }
}
    27d8:	df 91       	pop	r29
    27da:	cf 91       	pop	r28
    27dc:	1f 91       	pop	r17
    27de:	0f 91       	pop	r16
    27e0:	ff 90       	pop	r15
    27e2:	ef 90       	pop	r14
    27e4:	df 90       	pop	r13
    27e6:	cf 90       	pop	r12
    27e8:	bf 90       	pop	r11
    27ea:	af 90       	pop	r10
    27ec:	9f 90       	pop	r9
    27ee:	08 95       	ret

000027f0 <main>:
  // Initialize system upon power-up.
  //serial_init();   // Setup serial baud rate and interrupts
  /*---------------------------------------------------
  HAL replacement for serial_init()
  ----------------------------------------------------*/
  const UartConfig_t *UartConfig = Uart_ConfigGet();
    27f0:	0e 94 b2 39 	call	0x7364	; 0x7364 <Uart_ConfigGet>
  Uart_Init(UartConfig);  
    27f4:	0e 94 b2 38 	call	0x7164	; 0x7164 <Uart_Init>
  Uart_interruptTrigger(UART_0, RECEIVE);
    27f8:	61 e0       	ldi	r22, 0x01	; 1
    27fa:	80 e0       	ldi	r24, 0x00	; 0
    27fc:	0e 94 82 39 	call	0x7304	; 0x7304 <Uart_interruptTrigger>
  /*----------------------------------------------------*/
  settings_init(); // Load Grbl settings from EEPROM
    2800:	0e 94 99 2b 	call	0x5732	; 0x5732 <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
    2804:	0e 94 f2 2e 	call	0x5de4	; 0x5de4 <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
    2808:	0e 94 1b 36 	call	0x6c36	; 0x6c36 <system_init>
  
  memset(&sys, 0, sizeof(system_t));  // Clear all system variables
    280c:	e4 e0       	ldi	r30, 0x04	; 4
    280e:	f6 e0       	ldi	r31, 0x06	; 6
    2810:	8e e1       	ldi	r24, 0x1E	; 30
    2812:	df 01       	movw	r26, r30
    2814:	1d 92       	st	X+, r1
    2816:	8a 95       	dec	r24
    2818:	e9 f7       	brne	.-6      	; 0x2814 <main+0x24>
  sys.abort = true;   // Set abort to complete initialization
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	80 83       	st	Z, r24
  sei(); // Enable interrupts
    281e:	78 94       	sei
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
    2820:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    2824:	84 ff       	sbrs	r24, 4
    2826:	03 c0       	rjmp	.+6      	; 0x282e <main+0x3e>
    2828:	81 e0       	ldi	r24, 0x01	; 1
    282a:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <sys+0x1>
    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    gc_sync_position();

    // Reset system variables.
    sys.abort = false;
    282e:	c4 e0       	ldi	r28, 0x04	; 4
    2830:	d6 e0       	ldi	r29, 0x06	; 6

    // TODO: Separate configure task that require interrupts to be disabled, especially upon
    // a system abort and ensuring any active interrupts are cleanly reset.
  
    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
    2832:	0e 94 ee 28 	call	0x51dc	; 0x51dc <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
    2836:	0e 94 fd 05 	call	0xbfa	; 0xbfa <gc_init>
    spindle_init();
    283a:	0e 94 ca 2b 	call	0x5794	; 0x5794 <spindle_init>
    coolant_init();
    283e:	0e 94 06 05 	call	0xa0c	; 0xa0c <coolant_init>
    limits_init(); 
    2842:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
    probe_init();
    2846:	0e 94 23 20 	call	0x4046	; 0x4046 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
    284a:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
    284e:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
    2852:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <plan_sync_position>
    gc_sync_position();
    2856:	0e 94 0f 06 	call	0xc1e	; 0xc1e <gc_sync_position>

    // Reset system variables.
    sys.abort = false;
    285a:	18 82       	st	Y, r1
    sys_rt_exec_state = 0;
    285c:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
    2860:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys_rt_exec_alarm>
    sys.suspend = false;
    2864:	1a 82       	std	Y+2, r1	; 0x02
    sys.soft_limit = false;
    2866:	1b 82       	std	Y+3, r1	; 0x03
              
    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
    2868:	0e 94 8e 21 	call	0x431c	; 0x431c <protocol_main_loop>
    286c:	e2 cf       	rjmp	.-60     	; 0x2832 <main+0x42>

0000286e <mc_line>:
#ifdef USE_LINE_NUMBERS
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number)
#else
  void mc_line(float *target, float feed_rate, uint8_t invert_feed_rate)
#endif
{
    286e:	bf 92       	push	r11
    2870:	cf 92       	push	r12
    2872:	df 92       	push	r13
    2874:	ef 92       	push	r14
    2876:	ff 92       	push	r15
    2878:	0f 93       	push	r16
    287a:	1f 93       	push	r17
    287c:	cf 93       	push	r28
    287e:	df 93       	push	r29
    2880:	8c 01       	movw	r16, r24
    2882:	6a 01       	movw	r12, r20
    2884:	7b 01       	movw	r14, r22
    2886:	b2 2e       	mov	r11, r18
  // If enabled, check for soft limit violations. Placed here all line motions are picked up
  // from everywhere in Grbl.
  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) { limits_soft_check(target); }    
    2888:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    288c:	85 ff       	sbrs	r24, 5
    288e:	03 c0       	rjmp	.+6      	; 0x2896 <mc_line+0x28>
    2890:	c8 01       	movw	r24, r16
    2892:	0e 94 8f 13 	call	0x271e	; 0x271e <limits_soft_check>
      
  // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2896:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    289a:	82 30       	cpi	r24, 0x02	; 2
    289c:	a1 f0       	breq	.+40     	; 0x28c6 <mc_line+0x58>

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    if (sys.abort) { return; } // Bail, if system abort.
    289e:	c4 e0       	ldi	r28, 0x04	; 4
    28a0:	d6 e0       	ldi	r29, 0x06	; 6
  // parser and planner are separate from the system machine positions, this is doable.

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Remain in this loop until there is room in the buffer.
  do {
    protocol_execute_realtime(); // Check for any run-time commands
    28a2:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail, if system abort.
    28a6:	88 81       	ld	r24, Y
    28a8:	81 11       	cpse	r24, r1
    28aa:	0d c0       	rjmp	.+26     	; 0x28c6 <mc_line+0x58>
    if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffer is full.
    28ac:	0e 94 30 1b 	call	0x3660	; 0x3660 <plan_check_full_buffer>
    28b0:	88 23       	and	r24, r24
    28b2:	19 f0       	breq	.+6      	; 0x28ba <mc_line+0x4c>
    28b4:	0e 94 85 21 	call	0x430a	; 0x430a <protocol_auto_cycle_start>
    else { break; }
  } while (1);
    28b8:	f4 cf       	rjmp	.-24     	; 0x28a2 <mc_line+0x34>

  // Plan and queue motion into planner buffer
  #ifdef USE_LINE_NUMBERS
    plan_buffer_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    plan_buffer_line(target, feed_rate, invert_feed_rate);
    28ba:	2b 2d       	mov	r18, r11
    28bc:	b7 01       	movw	r22, r14
    28be:	a6 01       	movw	r20, r12
    28c0:	c8 01       	movw	r24, r16
    28c2:	0e 94 38 1b 	call	0x3670	; 0x3670 <plan_buffer_line>
  #endif
}
    28c6:	df 91       	pop	r29
    28c8:	cf 91       	pop	r28
    28ca:	1f 91       	pop	r17
    28cc:	0f 91       	pop	r16
    28ce:	ff 90       	pop	r15
    28d0:	ef 90       	pop	r14
    28d2:	df 90       	pop	r13
    28d4:	cf 90       	pop	r12
    28d6:	bf 90       	pop	r11
    28d8:	08 95       	ret

000028da <mc_arc>:
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc, int32_t line_number)
#else
  void mc_arc(float *position, float *target, float *offset, float radius, float feed_rate,
    uint8_t invert_feed_rate, uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
#endif
{
    28da:	2f 92       	push	r2
    28dc:	3f 92       	push	r3
    28de:	4f 92       	push	r4
    28e0:	5f 92       	push	r5
    28e2:	6f 92       	push	r6
    28e4:	7f 92       	push	r7
    28e6:	8f 92       	push	r8
    28e8:	9f 92       	push	r9
    28ea:	af 92       	push	r10
    28ec:	bf 92       	push	r11
    28ee:	cf 92       	push	r12
    28f0:	df 92       	push	r13
    28f2:	ef 92       	push	r14
    28f4:	ff 92       	push	r15
    28f6:	0f 93       	push	r16
    28f8:	1f 93       	push	r17
    28fa:	cf 93       	push	r28
    28fc:	df 93       	push	r29
    28fe:	cd b7       	in	r28, 0x3d	; 61
    2900:	de b7       	in	r29, 0x3e	; 62
    2902:	e4 97       	sbiw	r28, 0x34	; 52
    2904:	0f b6       	in	r0, 0x3f	; 63
    2906:	f8 94       	cli
    2908:	de bf       	out	0x3e, r29	; 62
    290a:	0f be       	out	0x3f, r0	; 63
    290c:	cd bf       	out	0x3d, r28	; 61
    290e:	9e 87       	std	Y+14, r25	; 0x0e
    2910:	8d 87       	std	Y+13, r24	; 0x0d
    2912:	7c ab       	std	Y+52, r23	; 0x34
    2914:	6b ab       	std	Y+51, r22	; 0x33
    2916:	3a 01       	movw	r6, r20
    2918:	0d 83       	std	Y+5, r16	; 0x05
    291a:	1e 83       	std	Y+6, r17	; 0x06
    291c:	2f 83       	std	Y+7, r18	; 0x07
    291e:	38 87       	std	Y+8, r19	; 0x08
    2920:	cf 86       	std	Y+15, r12	; 0x0f
    2922:	d8 8a       	std	Y+16, r13	; 0x10
    2924:	e9 8a       	std	Y+17, r14	; 0x11
    2926:	fa 8a       	std	Y+18, r15	; 0x12
    2928:	0a 2d       	mov	r16, r10
  float center_axis0 = position[axis_0] + offset[axis_0];
    292a:	91 2c       	mov	r9, r1
    292c:	88 0c       	add	r8, r8
    292e:	99 1c       	adc	r9, r9
    2930:	88 0c       	add	r8, r8
    2932:	99 1c       	adc	r9, r9
    2934:	88 0d       	add	r24, r8
    2936:	99 1d       	adc	r25, r9
    2938:	9c 8b       	std	Y+20, r25	; 0x14
    293a:	8b 8b       	std	Y+19, r24	; 0x13
    293c:	ca 01       	movw	r24, r20
    293e:	88 0d       	add	r24, r8
    2940:	99 1d       	adc	r25, r9
    2942:	98 ab       	std	Y+48, r25	; 0x30
    2944:	8f a7       	std	Y+47, r24	; 0x2f
    2946:	dc 01       	movw	r26, r24
    2948:	2d 90       	ld	r2, X+
    294a:	3d 90       	ld	r3, X+
    294c:	4d 90       	ld	r4, X+
    294e:	5c 90       	ld	r5, X
    2950:	eb 89       	ldd	r30, Y+19	; 0x13
    2952:	fc 89       	ldd	r31, Y+20	; 0x14
    2954:	20 81       	ld	r18, Z
    2956:	31 81       	ldd	r19, Z+1	; 0x01
    2958:	42 81       	ldd	r20, Z+2	; 0x02
    295a:	53 81       	ldd	r21, Z+3	; 0x03
    295c:	c2 01       	movw	r24, r4
    295e:	b1 01       	movw	r22, r2
    2960:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2964:	6d 8b       	std	Y+21, r22	; 0x15
    2966:	7e 8b       	std	Y+22, r23	; 0x16
    2968:	8f 8b       	std	Y+23, r24	; 0x17
    296a:	98 8f       	std	Y+24, r25	; 0x18
  float center_axis1 = position[axis_1] + offset[axis_1];
    296c:	2a 96       	adiw	r28, 0x0a	; 10
    296e:	af ac       	ldd	r10, Y+63	; 0x3f
    2970:	2a 97       	sbiw	r28, 0x0a	; 10
    2972:	b1 2c       	mov	r11, r1
    2974:	aa 0c       	add	r10, r10
    2976:	bb 1c       	adc	r11, r11
    2978:	aa 0c       	add	r10, r10
    297a:	bb 1c       	adc	r11, r11
    297c:	8d 85       	ldd	r24, Y+13	; 0x0d
    297e:	9e 85       	ldd	r25, Y+14	; 0x0e
    2980:	8a 0d       	add	r24, r10
    2982:	9b 1d       	adc	r25, r11
    2984:	9a 8f       	std	Y+26, r25	; 0x1a
    2986:	89 8f       	std	Y+25, r24	; 0x19
    2988:	d3 01       	movw	r26, r6
    298a:	aa 0d       	add	r26, r10
    298c:	bb 1d       	adc	r27, r11
    298e:	ba ab       	std	Y+50, r27	; 0x32
    2990:	a9 ab       	std	Y+49, r26	; 0x31
    2992:	cd 90       	ld	r12, X+
    2994:	dd 90       	ld	r13, X+
    2996:	ed 90       	ld	r14, X+
    2998:	fc 90       	ld	r15, X
    299a:	fc 01       	movw	r30, r24
    299c:	20 81       	ld	r18, Z
    299e:	31 81       	ldd	r19, Z+1	; 0x01
    29a0:	42 81       	ldd	r20, Z+2	; 0x02
    29a2:	53 81       	ldd	r21, Z+3	; 0x03
    29a4:	c7 01       	movw	r24, r14
    29a6:	b6 01       	movw	r22, r12
    29a8:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    29ac:	6b 8f       	std	Y+27, r22	; 0x1b
    29ae:	7c 8f       	std	Y+28, r23	; 0x1c
    29b0:	8d 8f       	std	Y+29, r24	; 0x1d
    29b2:	9e 8f       	std	Y+30, r25	; 0x1e
  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
    29b4:	d2 01       	movw	r26, r4
    29b6:	c1 01       	movw	r24, r2
    29b8:	b0 58       	subi	r27, 0x80	; 128
    29ba:	89 83       	std	Y+1, r24	; 0x01
    29bc:	9a 83       	std	Y+2, r25	; 0x02
    29be:	ab 83       	std	Y+3, r26	; 0x03
    29c0:	bc 83       	std	Y+4, r27	; 0x04
  float r_axis1 = -offset[axis_1];
    29c2:	d7 01       	movw	r26, r14
    29c4:	c6 01       	movw	r24, r12
    29c6:	b0 58       	subi	r27, 0x80	; 128
    29c8:	89 87       	std	Y+9, r24	; 0x09
    29ca:	9a 87       	std	Y+10, r25	; 0x0a
    29cc:	ab 87       	std	Y+11, r26	; 0x0b
    29ce:	bc 87       	std	Y+12, r27	; 0x0c
  float rt_axis0 = target[axis_0] - center_axis0;
    29d0:	eb a9       	ldd	r30, Y+51	; 0x33
    29d2:	fc a9       	ldd	r31, Y+52	; 0x34
    29d4:	e8 0d       	add	r30, r8
    29d6:	f9 1d       	adc	r31, r9
    29d8:	2d 89       	ldd	r18, Y+21	; 0x15
    29da:	3e 89       	ldd	r19, Y+22	; 0x16
    29dc:	4f 89       	ldd	r20, Y+23	; 0x17
    29de:	58 8d       	ldd	r21, Y+24	; 0x18
    29e0:	60 81       	ld	r22, Z
    29e2:	71 81       	ldd	r23, Z+1	; 0x01
    29e4:	82 81       	ldd	r24, Z+2	; 0x02
    29e6:	93 81       	ldd	r25, Z+3	; 0x03
    29e8:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    29ec:	6b 01       	movw	r12, r22
    29ee:	7c 01       	movw	r14, r24
  float rt_axis1 = target[axis_1] - center_axis1;
    29f0:	eb a9       	ldd	r30, Y+51	; 0x33
    29f2:	fc a9       	ldd	r31, Y+52	; 0x34
    29f4:	ea 0d       	add	r30, r10
    29f6:	fb 1d       	adc	r31, r11
    29f8:	2b 8d       	ldd	r18, Y+27	; 0x1b
    29fa:	3c 8d       	ldd	r19, Y+28	; 0x1c
    29fc:	4d 8d       	ldd	r20, Y+29	; 0x1d
    29fe:	5e 8d       	ldd	r21, Y+30	; 0x1e
    2a00:	60 81       	ld	r22, Z
    2a02:	71 81       	ldd	r23, Z+1	; 0x01
    2a04:	82 81       	ldd	r24, Z+2	; 0x02
    2a06:	93 81       	ldd	r25, Z+3	; 0x03
    2a08:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2a0c:	4b 01       	movw	r8, r22
    2a0e:	5c 01       	movw	r10, r24
  
  // CCW angle between position and target from circle center. Only one atan2() trig computation required.
  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);
    2a10:	a7 01       	movw	r20, r14
    2a12:	96 01       	movw	r18, r12
    2a14:	69 81       	ldd	r22, Y+1	; 0x01
    2a16:	7a 81       	ldd	r23, Y+2	; 0x02
    2a18:	8b 81       	ldd	r24, Y+3	; 0x03
    2a1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2a1c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2a20:	2b 01       	movw	r4, r22
    2a22:	3c 01       	movw	r6, r24
    2a24:	a5 01       	movw	r20, r10
    2a26:	94 01       	movw	r18, r8
    2a28:	69 85       	ldd	r22, Y+9	; 0x09
    2a2a:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a2c:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a2e:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a30:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2a34:	9b 01       	movw	r18, r22
    2a36:	ac 01       	movw	r20, r24
    2a38:	c3 01       	movw	r24, r6
    2a3a:	b2 01       	movw	r22, r4
    2a3c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2a40:	2b 01       	movw	r4, r22
    2a42:	3c 01       	movw	r6, r24
    2a44:	a5 01       	movw	r20, r10
    2a46:	94 01       	movw	r18, r8
    2a48:	69 81       	ldd	r22, Y+1	; 0x01
    2a4a:	7a 81       	ldd	r23, Y+2	; 0x02
    2a4c:	8b 81       	ldd	r24, Y+3	; 0x03
    2a4e:	9c 81       	ldd	r25, Y+4	; 0x04
    2a50:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2a54:	4b 01       	movw	r8, r22
    2a56:	5c 01       	movw	r10, r24
    2a58:	a7 01       	movw	r20, r14
    2a5a:	96 01       	movw	r18, r12
    2a5c:	69 85       	ldd	r22, Y+9	; 0x09
    2a5e:	7a 85       	ldd	r23, Y+10	; 0x0a
    2a60:	8b 85       	ldd	r24, Y+11	; 0x0b
    2a62:	9c 85       	ldd	r25, Y+12	; 0x0c
    2a64:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2a68:	9b 01       	movw	r18, r22
    2a6a:	ac 01       	movw	r20, r24
    2a6c:	c5 01       	movw	r24, r10
    2a6e:	b4 01       	movw	r22, r8
    2a70:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2a74:	a3 01       	movw	r20, r6
    2a76:	92 01       	movw	r18, r4
    2a78:	0e 94 35 3a 	call	0x746a	; 0x746a <atan2>
    2a7c:	4b 01       	movw	r8, r22
    2a7e:	5c 01       	movw	r10, r24
  if (is_clockwise_arc) { // Correct atan2 output per direction
    2a80:	2c 96       	adiw	r28, 0x0c	; 12
    2a82:	8f ad       	ldd	r24, Y+63	; 0x3f
    2a84:	2c 97       	sbiw	r28, 0x0c	; 12
    2a86:	88 23       	and	r24, r24
    2a88:	a9 f0       	breq	.+42     	; 0x2ab4 <mc_arc+0x1da>
    if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
    2a8a:	2d eb       	ldi	r18, 0xBD	; 189
    2a8c:	37 e3       	ldi	r19, 0x37	; 55
    2a8e:	46 e0       	ldi	r20, 0x06	; 6
    2a90:	55 eb       	ldi	r21, 0xB5	; 181
    2a92:	c5 01       	movw	r24, r10
    2a94:	b4 01       	movw	r22, r8
    2a96:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    2a9a:	88 23       	and	r24, r24
    2a9c:	fc f0       	brlt	.+62     	; 0x2adc <mc_arc+0x202>
    2a9e:	2b ed       	ldi	r18, 0xDB	; 219
    2aa0:	3f e0       	ldi	r19, 0x0F	; 15
    2aa2:	49 ec       	ldi	r20, 0xC9	; 201
    2aa4:	50 e4       	ldi	r21, 0x40	; 64
    2aa6:	c5 01       	movw	r24, r10
    2aa8:	b4 01       	movw	r22, r8
    2aaa:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2aae:	4b 01       	movw	r8, r22
    2ab0:	5c 01       	movw	r10, r24
    2ab2:	14 c0       	rjmp	.+40     	; 0x2adc <mc_arc+0x202>
  } else {
    if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
    2ab4:	2d eb       	ldi	r18, 0xBD	; 189
    2ab6:	37 e3       	ldi	r19, 0x37	; 55
    2ab8:	46 e0       	ldi	r20, 0x06	; 6
    2aba:	55 e3       	ldi	r21, 0x35	; 53
    2abc:	c5 01       	movw	r24, r10
    2abe:	b4 01       	movw	r22, r8
    2ac0:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    2ac4:	18 16       	cp	r1, r24
    2ac6:	54 f0       	brlt	.+20     	; 0x2adc <mc_arc+0x202>
    2ac8:	2b ed       	ldi	r18, 0xDB	; 219
    2aca:	3f e0       	ldi	r19, 0x0F	; 15
    2acc:	49 ec       	ldi	r20, 0xC9	; 201
    2ace:	50 e4       	ldi	r21, 0x40	; 64
    2ad0:	c5 01       	movw	r24, r10
    2ad2:	b4 01       	movw	r22, r8
    2ad4:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2ad8:	4b 01       	movw	r8, r22
    2ada:	5c 01       	movw	r10, r24
  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
    2adc:	c0 90 1c 07 	lds	r12, 0x071C	; 0x80071c <settings+0x39>
    2ae0:	d0 90 1d 07 	lds	r13, 0x071D	; 0x80071d <settings+0x3a>
    2ae4:	e0 90 1e 07 	lds	r14, 0x071E	; 0x80071e <settings+0x3b>
    2ae8:	f0 90 1f 07 	lds	r15, 0x071F	; 0x80071f <settings+0x3c>
    2aec:	2d 81       	ldd	r18, Y+5	; 0x05
    2aee:	3e 81       	ldd	r19, Y+6	; 0x06
    2af0:	4f 81       	ldd	r20, Y+7	; 0x07
    2af2:	58 85       	ldd	r21, Y+8	; 0x08
    2af4:	ca 01       	movw	r24, r20
    2af6:	b9 01       	movw	r22, r18
    2af8:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2afc:	2b 01       	movw	r4, r22
    2afe:	3c 01       	movw	r6, r24
    2b00:	a7 01       	movw	r20, r14
    2b02:	96 01       	movw	r18, r12
    2b04:	c3 01       	movw	r24, r6
    2b06:	b2 01       	movw	r22, r4
    2b08:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2b0c:	a7 01       	movw	r20, r14
    2b0e:	96 01       	movw	r18, r12
    2b10:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2b14:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    2b18:	6b 01       	movw	r12, r22
    2b1a:	7c 01       	movw	r14, r24

  // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by up to
  // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment fit
  // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculation.
  // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
  uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
    2b1c:	20 e0       	ldi	r18, 0x00	; 0
    2b1e:	30 e0       	ldi	r19, 0x00	; 0
    2b20:	40 e0       	ldi	r20, 0x00	; 0
    2b22:	5f e3       	ldi	r21, 0x3F	; 63
    2b24:	c5 01       	movw	r24, r10
    2b26:	b4 01       	movw	r22, r8
    2b28:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2b2c:	2d 81       	ldd	r18, Y+5	; 0x05
    2b2e:	3e 81       	ldd	r19, Y+6	; 0x06
    2b30:	4f 81       	ldd	r20, Y+7	; 0x07
    2b32:	58 85       	ldd	r21, Y+8	; 0x08
    2b34:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2b38:	9f 77       	andi	r25, 0x7F	; 127
    2b3a:	a7 01       	movw	r20, r14
    2b3c:	96 01       	movw	r18, r12
    2b3e:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    2b42:	0e 94 9a 3b 	call	0x7734	; 0x7734 <floor>
    2b46:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    2b4a:	6b 01       	movw	r12, r22
    2b4c:	7c 01       	movw	r14, r24
    2b4e:	3b 01       	movw	r6, r22
                          sqrt(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
  
  if (segments) { 
    2b50:	61 15       	cp	r22, r1
    2b52:	71 05       	cpc	r23, r1
    2b54:	09 f4       	brne	.+2      	; 0x2b58 <mc_arc+0x27e>
    2b56:	81 c1       	rjmp	.+770    	; 0x2e5a <mc_arc+0x580>
    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of 
    // all segments.
    if (invert_feed_rate) { feed_rate *= segments; }
    2b58:	00 23       	and	r16, r16
    2b5a:	81 f0       	breq	.+32     	; 0x2b7c <mc_arc+0x2a2>
    2b5c:	80 e0       	ldi	r24, 0x00	; 0
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    2b64:	9b 01       	movw	r18, r22
    2b66:	ac 01       	movw	r20, r24
    2b68:	6f 85       	ldd	r22, Y+15	; 0x0f
    2b6a:	78 89       	ldd	r23, Y+16	; 0x10
    2b6c:	89 89       	ldd	r24, Y+17	; 0x11
    2b6e:	9a 89       	ldd	r25, Y+18	; 0x12
    2b70:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2b74:	6f 87       	std	Y+15, r22	; 0x0f
    2b76:	78 8b       	std	Y+16, r23	; 0x10
    2b78:	89 8b       	std	Y+17, r24	; 0x11
    2b7a:	9a 8b       	std	Y+18, r25	; 0x12
   
    float theta_per_segment = angular_travel/segments;
    2b7c:	b6 01       	movw	r22, r12
    2b7e:	80 e0       	ldi	r24, 0x00	; 0
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    2b86:	6b 01       	movw	r12, r22
    2b88:	7c 01       	movw	r14, r24
    2b8a:	9b 01       	movw	r18, r22
    2b8c:	ac 01       	movw	r20, r24
    2b8e:	c5 01       	movw	r24, r10
    2b90:	b4 01       	movw	r22, r8
    2b92:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    2b96:	6b a7       	std	Y+43, r22	; 0x2b
    2b98:	7c a7       	std	Y+44, r23	; 0x2c
    2b9a:	8d a7       	std	Y+45, r24	; 0x2d
    2b9c:	9e a7       	std	Y+46, r25	; 0x2e
    float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
    2b9e:	2b 96       	adiw	r28, 0x0b	; 11
    2ba0:	8f ad       	ldd	r24, Y+63	; 0x3f
    2ba2:	2b 97       	sbiw	r28, 0x0b	; 11
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	88 0f       	add	r24, r24
    2ba8:	99 1f       	adc	r25, r25
    2baa:	88 0f       	add	r24, r24
    2bac:	99 1f       	adc	r25, r25
    2bae:	4d 84       	ldd	r4, Y+13	; 0x0d
    2bb0:	5e 84       	ldd	r5, Y+14	; 0x0e
    2bb2:	48 0e       	add	r4, r24
    2bb4:	59 1e       	adc	r5, r25
    2bb6:	eb a9       	ldd	r30, Y+51	; 0x33
    2bb8:	fc a9       	ldd	r31, Y+52	; 0x34
    2bba:	e8 0f       	add	r30, r24
    2bbc:	f9 1f       	adc	r31, r25
    2bbe:	d2 01       	movw	r26, r4
    2bc0:	2d 91       	ld	r18, X+
    2bc2:	3d 91       	ld	r19, X+
    2bc4:	4d 91       	ld	r20, X+
    2bc6:	5c 91       	ld	r21, X
    2bc8:	60 81       	ld	r22, Z
    2bca:	71 81       	ldd	r23, Z+1	; 0x01
    2bcc:	82 81       	ldd	r24, Z+2	; 0x02
    2bce:	93 81       	ldd	r25, Z+3	; 0x03
    2bd0:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2bd4:	a7 01       	movw	r20, r14
    2bd6:	96 01       	movw	r18, r12
    2bd8:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    2bdc:	6f 8f       	std	Y+31, r22	; 0x1f
    2bde:	78 a3       	std	Y+32, r23	; 0x20
    2be0:	89 a3       	std	Y+33, r24	; 0x21
    2be2:	9a a3       	std	Y+34, r25	; 0x22
       without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
       a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. 
       This is important when there are successive arc motions. 
    */
    // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3/6) in ~52usec
    float cos_T = 2.0 - theta_per_segment*theta_per_segment;
    2be4:	2b a5       	ldd	r18, Y+43	; 0x2b
    2be6:	3c a5       	ldd	r19, Y+44	; 0x2c
    2be8:	4d a5       	ldd	r20, Y+45	; 0x2d
    2bea:	5e a5       	ldd	r21, Y+46	; 0x2e
    2bec:	ca 01       	movw	r24, r20
    2bee:	b9 01       	movw	r22, r18
    2bf0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2bf4:	9b 01       	movw	r18, r22
    2bf6:	ac 01       	movw	r20, r24
    2bf8:	60 e0       	ldi	r22, 0x00	; 0
    2bfa:	70 e0       	ldi	r23, 0x00	; 0
    2bfc:	80 e0       	ldi	r24, 0x00	; 0
    2bfe:	90 e4       	ldi	r25, 0x40	; 64
    2c00:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2c04:	6b 01       	movw	r12, r22
    2c06:	7c 01       	movw	r14, r24
    float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
    2c08:	2b ea       	ldi	r18, 0xAB	; 171
    2c0a:	3a ea       	ldi	r19, 0xAA	; 170
    2c0c:	4a e2       	ldi	r20, 0x2A	; 42
    2c0e:	5e e3       	ldi	r21, 0x3E	; 62
    2c10:	6b a5       	ldd	r22, Y+43	; 0x2b
    2c12:	7c a5       	ldd	r23, Y+44	; 0x2c
    2c14:	8d a5       	ldd	r24, Y+45	; 0x2d
    2c16:	9e a5       	ldd	r25, Y+46	; 0x2e
    2c18:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2c1c:	4b 01       	movw	r8, r22
    2c1e:	5c 01       	movw	r10, r24
    2c20:	20 e0       	ldi	r18, 0x00	; 0
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	40 e8       	ldi	r20, 0x80	; 128
    2c26:	50 e4       	ldi	r21, 0x40	; 64
    2c28:	c7 01       	movw	r24, r14
    2c2a:	b6 01       	movw	r22, r12
    2c2c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2c30:	9b 01       	movw	r18, r22
    2c32:	ac 01       	movw	r20, r24
    2c34:	c5 01       	movw	r24, r10
    2c36:	b4 01       	movw	r22, r8
    2c38:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2c3c:	6b a3       	std	Y+35, r22	; 0x23
    2c3e:	7c a3       	std	Y+36, r23	; 0x24
    2c40:	8d a3       	std	Y+37, r24	; 0x25
    2c42:	9e a3       	std	Y+38, r25	; 0x26
    cos_T *= 0.5;
    2c44:	20 e0       	ldi	r18, 0x00	; 0
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	40 e0       	ldi	r20, 0x00	; 0
    2c4a:	5f e3       	ldi	r21, 0x3F	; 63
    2c4c:	c7 01       	movw	r24, r14
    2c4e:	b6 01       	movw	r22, r12
    2c50:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2c54:	6f a3       	std	Y+39, r22	; 0x27
    2c56:	78 a7       	std	Y+40, r23	; 0x28
    2c58:	89 a7       	std	Y+41, r24	; 0x29
    2c5a:	9a a7       	std	Y+42, r25	; 0x2a
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2c5c:	b2 e0       	ldi	r27, 0x02	; 2
    2c5e:	6b 16       	cp	r6, r27
    2c60:	71 04       	cpc	r7, r1
    2c62:	08 f4       	brcc	.+2      	; 0x2c66 <mc_arc+0x38c>
    2c64:	fa c0       	rjmp	.+500    	; 0x2e5a <mc_arc+0x580>
    2c66:	10 e0       	ldi	r17, 0x00	; 0
    2c68:	22 24       	eor	r2, r2
    2c6a:	23 94       	inc	r2
    2c6c:	31 2c       	mov	r3, r1
      #else
        mc_line(position, feed_rate, invert_feed_rate);
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2c6e:	c9 84       	ldd	r12, Y+9	; 0x09
    2c70:	da 84       	ldd	r13, Y+10	; 0x0a
    2c72:	eb 84       	ldd	r14, Y+11	; 0x0b
    2c74:	fc 84       	ldd	r15, Y+12	; 0x0c
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
      
      if (count < N_ARC_CORRECTION) {
    2c76:	1c 30       	cpi	r17, 0x0C	; 12
    2c78:	08 f0       	brcs	.+2      	; 0x2c7c <mc_arc+0x3a2>
    2c7a:	44 c0       	rjmp	.+136    	; 0x2d04 <mc_arc+0x42a>
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
    2c7c:	a7 01       	movw	r20, r14
    2c7e:	96 01       	movw	r18, r12
    2c80:	6f a1       	ldd	r22, Y+39	; 0x27
    2c82:	78 a5       	ldd	r23, Y+40	; 0x28
    2c84:	89 a5       	ldd	r24, Y+41	; 0x29
    2c86:	9a a5       	ldd	r25, Y+42	; 0x2a
    2c88:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2c8c:	4b 01       	movw	r8, r22
    2c8e:	5c 01       	movw	r10, r24
    2c90:	29 81       	ldd	r18, Y+1	; 0x01
    2c92:	3a 81       	ldd	r19, Y+2	; 0x02
    2c94:	4b 81       	ldd	r20, Y+3	; 0x03
    2c96:	5c 81       	ldd	r21, Y+4	; 0x04
    2c98:	6b a1       	ldd	r22, Y+35	; 0x23
    2c9a:	7c a1       	ldd	r23, Y+36	; 0x24
    2c9c:	8d a1       	ldd	r24, Y+37	; 0x25
    2c9e:	9e a1       	ldd	r25, Y+38	; 0x26
    2ca0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2ca4:	a5 01       	movw	r20, r10
    2ca6:	94 01       	movw	r18, r8
    2ca8:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2cac:	86 2e       	mov	r8, r22
    2cae:	97 2e       	mov	r9, r23
    2cb0:	a8 2e       	mov	r10, r24
    2cb2:	b9 2e       	mov	r11, r25
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
    2cb4:	29 81       	ldd	r18, Y+1	; 0x01
    2cb6:	3a 81       	ldd	r19, Y+2	; 0x02
    2cb8:	4b 81       	ldd	r20, Y+3	; 0x03
    2cba:	5c 81       	ldd	r21, Y+4	; 0x04
    2cbc:	6f a1       	ldd	r22, Y+39	; 0x27
    2cbe:	78 a5       	ldd	r23, Y+40	; 0x28
    2cc0:	89 a5       	ldd	r24, Y+41	; 0x29
    2cc2:	9a a5       	ldd	r25, Y+42	; 0x2a
    2cc4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2cc8:	69 83       	std	Y+1, r22	; 0x01
    2cca:	7a 83       	std	Y+2, r23	; 0x02
    2ccc:	8b 83       	std	Y+3, r24	; 0x03
    2cce:	9c 83       	std	Y+4, r25	; 0x04
    2cd0:	a7 01       	movw	r20, r14
    2cd2:	96 01       	movw	r18, r12
    2cd4:	6b a1       	ldd	r22, Y+35	; 0x23
    2cd6:	7c a1       	ldd	r23, Y+36	; 0x24
    2cd8:	8d a1       	ldd	r24, Y+37	; 0x25
    2cda:	9e a1       	ldd	r25, Y+38	; 0x26
    2cdc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2ce0:	9b 01       	movw	r18, r22
    2ce2:	ac 01       	movw	r20, r24
    2ce4:	69 81       	ldd	r22, Y+1	; 0x01
    2ce6:	7a 81       	ldd	r23, Y+2	; 0x02
    2ce8:	8b 81       	ldd	r24, Y+3	; 0x03
    2cea:	9c 81       	ldd	r25, Y+4	; 0x04
    2cec:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2cf0:	69 83       	std	Y+1, r22	; 0x01
    2cf2:	7a 83       	std	Y+2, r23	; 0x02
    2cf4:	8b 83       	std	Y+3, r24	; 0x03
    2cf6:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = r_axisi;
        count++;
    2cf8:	1f 5f       	subi	r17, 0xFF	; 255
      
      if (count < N_ARC_CORRECTION) {
        // Apply vector rotation matrix. ~40 usec
        r_axisi = r_axis0*sin_T + r_axis1*cos_T;
        r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
        r_axis1 = r_axisi;
    2cfa:	c8 2c       	mov	r12, r8
    2cfc:	d9 2c       	mov	r13, r9
    2cfe:	ea 2c       	mov	r14, r10
    2d00:	fb 2c       	mov	r15, r11
    2d02:	66 c0       	rjmp	.+204    	; 0x2dd0 <mc_arc+0x4f6>
        count++;
      } else {      
        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 usec
        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
        cos_Ti = cos(i*theta_per_segment);
    2d04:	b1 01       	movw	r22, r2
    2d06:	80 e0       	ldi	r24, 0x00	; 0
    2d08:	90 e0       	ldi	r25, 0x00	; 0
    2d0a:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    2d0e:	2b a5       	ldd	r18, Y+43	; 0x2b
    2d10:	3c a5       	ldd	r19, Y+44	; 0x2c
    2d12:	4d a5       	ldd	r20, Y+45	; 0x2d
    2d14:	5e a5       	ldd	r21, Y+46	; 0x2e
    2d16:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2d1a:	6b 01       	movw	r12, r22
    2d1c:	7c 01       	movw	r14, r24
    2d1e:	0e 94 b0 3a 	call	0x7560	; 0x7560 <cos>
    2d22:	6d 83       	std	Y+5, r22	; 0x05
    2d24:	7e 83       	std	Y+6, r23	; 0x06
    2d26:	8f 83       	std	Y+7, r24	; 0x07
    2d28:	98 87       	std	Y+8, r25	; 0x08
        sin_Ti = sin(i*theta_per_segment);
    2d2a:	c7 01       	movw	r24, r14
    2d2c:	b6 01       	movw	r22, r12
    2d2e:	0e 94 9e 3d 	call	0x7b3c	; 0x7b3c <sin>
    2d32:	69 87       	std	Y+9, r22	; 0x09
    2d34:	7a 87       	std	Y+10, r23	; 0x0a
    2d36:	8b 87       	std	Y+11, r24	; 0x0b
    2d38:	9c 87       	std	Y+12, r25	; 0x0c
        r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
    2d3a:	ef a5       	ldd	r30, Y+47	; 0x2f
    2d3c:	f8 a9       	ldd	r31, Y+48	; 0x30
    2d3e:	c0 80       	ld	r12, Z
    2d40:	d1 80       	ldd	r13, Z+1	; 0x01
    2d42:	e2 80       	ldd	r14, Z+2	; 0x02
    2d44:	f3 80       	ldd	r15, Z+3	; 0x03
    2d46:	f7 fa       	bst	r15, 7
    2d48:	f0 94       	com	r15
    2d4a:	f7 f8       	bld	r15, 7
    2d4c:	f0 94       	com	r15
    2d4e:	a9 a9       	ldd	r26, Y+49	; 0x31
    2d50:	ba a9       	ldd	r27, Y+50	; 0x32
    2d52:	8d 90       	ld	r8, X+
    2d54:	9d 90       	ld	r9, X+
    2d56:	ad 90       	ld	r10, X+
    2d58:	bc 90       	ld	r11, X
    2d5a:	a7 01       	movw	r20, r14
    2d5c:	96 01       	movw	r18, r12
    2d5e:	6d 81       	ldd	r22, Y+5	; 0x05
    2d60:	7e 81       	ldd	r23, Y+6	; 0x06
    2d62:	8f 81       	ldd	r24, Y+7	; 0x07
    2d64:	98 85       	ldd	r25, Y+8	; 0x08
    2d66:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2d6a:	69 83       	std	Y+1, r22	; 0x01
    2d6c:	7a 83       	std	Y+2, r23	; 0x02
    2d6e:	8b 83       	std	Y+3, r24	; 0x03
    2d70:	9c 83       	std	Y+4, r25	; 0x04
    2d72:	a5 01       	movw	r20, r10
    2d74:	94 01       	movw	r18, r8
    2d76:	69 85       	ldd	r22, Y+9	; 0x09
    2d78:	7a 85       	ldd	r23, Y+10	; 0x0a
    2d7a:	8b 85       	ldd	r24, Y+11	; 0x0b
    2d7c:	9c 85       	ldd	r25, Y+12	; 0x0c
    2d7e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2d82:	9b 01       	movw	r18, r22
    2d84:	ac 01       	movw	r20, r24
    2d86:	69 81       	ldd	r22, Y+1	; 0x01
    2d88:	7a 81       	ldd	r23, Y+2	; 0x02
    2d8a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d8c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d8e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2d92:	69 83       	std	Y+1, r22	; 0x01
    2d94:	7a 83       	std	Y+2, r23	; 0x02
    2d96:	8b 83       	std	Y+3, r24	; 0x03
    2d98:	9c 83       	std	Y+4, r25	; 0x04
        r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
    2d9a:	a7 01       	movw	r20, r14
    2d9c:	96 01       	movw	r18, r12
    2d9e:	69 85       	ldd	r22, Y+9	; 0x09
    2da0:	7a 85       	ldd	r23, Y+10	; 0x0a
    2da2:	8b 85       	ldd	r24, Y+11	; 0x0b
    2da4:	9c 85       	ldd	r25, Y+12	; 0x0c
    2da6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2daa:	6b 01       	movw	r12, r22
    2dac:	7c 01       	movw	r14, r24
    2dae:	a5 01       	movw	r20, r10
    2db0:	94 01       	movw	r18, r8
    2db2:	6d 81       	ldd	r22, Y+5	; 0x05
    2db4:	7e 81       	ldd	r23, Y+6	; 0x06
    2db6:	8f 81       	ldd	r24, Y+7	; 0x07
    2db8:	98 85       	ldd	r25, Y+8	; 0x08
    2dba:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2dbe:	9b 01       	movw	r18, r22
    2dc0:	ac 01       	movw	r20, r24
    2dc2:	c7 01       	movw	r24, r14
    2dc4:	b6 01       	movw	r22, r12
    2dc6:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2dca:	6b 01       	movw	r12, r22
    2dcc:	7c 01       	movw	r14, r24
        count = 0;
    2dce:	10 e0       	ldi	r17, 0x00	; 0
      }
  
      // Update arc_target location
      position[axis_0] = center_axis0 + r_axis0;
    2dd0:	2d 89       	ldd	r18, Y+21	; 0x15
    2dd2:	3e 89       	ldd	r19, Y+22	; 0x16
    2dd4:	4f 89       	ldd	r20, Y+23	; 0x17
    2dd6:	58 8d       	ldd	r21, Y+24	; 0x18
    2dd8:	69 81       	ldd	r22, Y+1	; 0x01
    2dda:	7a 81       	ldd	r23, Y+2	; 0x02
    2ddc:	8b 81       	ldd	r24, Y+3	; 0x03
    2dde:	9c 81       	ldd	r25, Y+4	; 0x04
    2de0:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2de4:	eb 89       	ldd	r30, Y+19	; 0x13
    2de6:	fc 89       	ldd	r31, Y+20	; 0x14
    2de8:	60 83       	st	Z, r22
    2dea:	71 83       	std	Z+1, r23	; 0x01
    2dec:	82 83       	std	Z+2, r24	; 0x02
    2dee:	93 83       	std	Z+3, r25	; 0x03
      position[axis_1] = center_axis1 + r_axis1;
    2df0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    2df2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    2df4:	4d 8d       	ldd	r20, Y+29	; 0x1d
    2df6:	5e 8d       	ldd	r21, Y+30	; 0x1e
    2df8:	c7 01       	movw	r24, r14
    2dfa:	b6 01       	movw	r22, r12
    2dfc:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2e00:	a9 8d       	ldd	r26, Y+25	; 0x19
    2e02:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2e04:	6d 93       	st	X+, r22
    2e06:	7d 93       	st	X+, r23
    2e08:	8d 93       	st	X+, r24
    2e0a:	9c 93       	st	X, r25
    2e0c:	13 97       	sbiw	r26, 0x03	; 3
      position[axis_linear] += linear_per_segment;
    2e0e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2e10:	38 a1       	ldd	r19, Y+32	; 0x20
    2e12:	49 a1       	ldd	r20, Y+33	; 0x21
    2e14:	5a a1       	ldd	r21, Y+34	; 0x22
    2e16:	f2 01       	movw	r30, r4
    2e18:	60 81       	ld	r22, Z
    2e1a:	71 81       	ldd	r23, Z+1	; 0x01
    2e1c:	82 81       	ldd	r24, Z+2	; 0x02
    2e1e:	93 81       	ldd	r25, Z+3	; 0x03
    2e20:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    2e24:	d2 01       	movw	r26, r4
    2e26:	6d 93       	st	X+, r22
    2e28:	7d 93       	st	X+, r23
    2e2a:	8d 93       	st	X+, r24
    2e2c:	9c 93       	st	X, r25
    2e2e:	13 97       	sbiw	r26, 0x03	; 3
      
      #ifdef USE_LINE_NUMBERS
        mc_line(position, feed_rate, invert_feed_rate, line_number);
      #else
        mc_line(position, feed_rate, invert_feed_rate);
    2e30:	20 2f       	mov	r18, r16
    2e32:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e34:	58 89       	ldd	r21, Y+16	; 0x10
    2e36:	69 89       	ldd	r22, Y+17	; 0x11
    2e38:	7a 89       	ldd	r23, Y+18	; 0x12
    2e3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    2e3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    2e3e:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
      #endif
      
      // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
      if (sys.abort) { return; }
    2e42:	e4 e0       	ldi	r30, 0x04	; 4
    2e44:	f6 e0       	ldi	r31, 0x06	; 6
    2e46:	80 81       	ld	r24, Z
    2e48:	81 11       	cpse	r24, r1
    2e4a:	10 c0       	rjmp	.+32     	; 0x2e6c <mc_arc+0x592>
    float cos_Ti;
    float r_axisi;
    uint16_t i;
    uint8_t count = 0;
  
    for (i = 1; i<segments; i++) { // Increment (segments-1).
    2e4c:	ff ef       	ldi	r31, 0xFF	; 255
    2e4e:	2f 1a       	sub	r2, r31
    2e50:	3f 0a       	sbc	r3, r31
    2e52:	62 14       	cp	r6, r2
    2e54:	73 04       	cpc	r7, r3
    2e56:	09 f0       	breq	.+2      	; 0x2e5a <mc_arc+0x580>
    2e58:	0e cf       	rjmp	.-484    	; 0x2c76 <mc_arc+0x39c>
  }
  // Ensure last segment arrives at target location.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2e5a:	20 2f       	mov	r18, r16
    2e5c:	4f 85       	ldd	r20, Y+15	; 0x0f
    2e5e:	58 89       	ldd	r21, Y+16	; 0x10
    2e60:	69 89       	ldd	r22, Y+17	; 0x11
    2e62:	7a 89       	ldd	r23, Y+18	; 0x12
    2e64:	8b a9       	ldd	r24, Y+51	; 0x33
    2e66:	9c a9       	ldd	r25, Y+52	; 0x34
    2e68:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
  #endif
}
    2e6c:	e4 96       	adiw	r28, 0x34	; 52
    2e6e:	0f b6       	in	r0, 0x3f	; 63
    2e70:	f8 94       	cli
    2e72:	de bf       	out	0x3e, r29	; 62
    2e74:	0f be       	out	0x3f, r0	; 63
    2e76:	cd bf       	out	0x3d, r28	; 61
    2e78:	df 91       	pop	r29
    2e7a:	cf 91       	pop	r28
    2e7c:	1f 91       	pop	r17
    2e7e:	0f 91       	pop	r16
    2e80:	ff 90       	pop	r15
    2e82:	ef 90       	pop	r14
    2e84:	df 90       	pop	r13
    2e86:	cf 90       	pop	r12
    2e88:	bf 90       	pop	r11
    2e8a:	af 90       	pop	r10
    2e8c:	9f 90       	pop	r9
    2e8e:	8f 90       	pop	r8
    2e90:	7f 90       	pop	r7
    2e92:	6f 90       	pop	r6
    2e94:	5f 90       	pop	r5
    2e96:	4f 90       	pop	r4
    2e98:	3f 90       	pop	r3
    2e9a:	2f 90       	pop	r2
    2e9c:	08 95       	ret

00002e9e <mc_dwell>:


// Execute dwell in seconds.
void mc_dwell(float seconds) 
{
    2e9e:	8f 92       	push	r8
    2ea0:	9f 92       	push	r9
    2ea2:	af 92       	push	r10
    2ea4:	bf 92       	push	r11
    2ea6:	cf 92       	push	r12
    2ea8:	df 92       	push	r13
    2eaa:	ef 92       	push	r14
    2eac:	ff 92       	push	r15
    2eae:	cf 93       	push	r28
    2eb0:	df 93       	push	r29
   if (sys.state == STATE_CHECK_MODE) { return; }
    2eb2:	20 91 05 06 	lds	r18, 0x0605	; 0x800605 <sys+0x1>
    2eb6:	22 30       	cpi	r18, 0x02	; 2
    2eb8:	09 f4       	brne	.+2      	; 0x2ebc <mc_dwell+0x1e>
    2eba:	48 c0       	rjmp	.+144    	; 0x2f4c <mc_dwell+0xae>
    2ebc:	4b 01       	movw	r8, r22
    2ebe:	5c 01       	movw	r10, r24
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
    2ec0:	20 e0       	ldi	r18, 0x00	; 0
    2ec2:	30 e0       	ldi	r19, 0x00	; 0
    2ec4:	40 ea       	ldi	r20, 0xA0	; 160
    2ec6:	51 e4       	ldi	r21, 0x41	; 65
    2ec8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2ecc:	0e 94 9a 3b 	call	0x7734	; 0x7734 <floor>
    2ed0:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    2ed4:	6b 01       	movw	r12, r22
    2ed6:	7c 01       	movw	r14, r24
    2ed8:	eb 01       	movw	r28, r22
   protocol_buffer_synchronize();
    2eda:	0e 94 3b 22 	call	0x4476	; 0x4476 <protocol_buffer_synchronize>
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
    2ede:	20 e0       	ldi	r18, 0x00	; 0
    2ee0:	30 e0       	ldi	r19, 0x00	; 0
    2ee2:	4a e7       	ldi	r20, 0x7A	; 122
    2ee4:	54 e4       	ldi	r21, 0x44	; 68
    2ee6:	c5 01       	movw	r24, r10
    2ee8:	b4 01       	movw	r22, r8
    2eea:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    2eee:	4b 01       	movw	r8, r22
    2ef0:	5c 01       	movw	r10, r24
    2ef2:	82 e3       	ldi	r24, 0x32	; 50
    2ef4:	8c 9d       	mul	r24, r12
    2ef6:	b0 01       	movw	r22, r0
    2ef8:	8d 9d       	mul	r24, r13
    2efa:	70 0d       	add	r23, r0
    2efc:	11 24       	eor	r1, r1
    2efe:	80 e0       	ldi	r24, 0x00	; 0
    2f00:	90 e0       	ldi	r25, 0x00	; 0
    2f02:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    2f06:	9b 01       	movw	r18, r22
    2f08:	ac 01       	movw	r20, r24
    2f0a:	c5 01       	movw	r24, r10
    2f0c:	b4 01       	movw	r22, r8
    2f0e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    2f12:	0e 94 9a 3b 	call	0x7734	; 0x7734 <floor>
    2f16:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    2f1a:	cb 01       	movw	r24, r22
    2f1c:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>
   while (i-- > 0) {
    2f20:	cd 2b       	or	r28, r29
    2f22:	a1 f0       	breq	.+40     	; 0x2f4c <mc_dwell+0xae>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
    2f24:	c4 e0       	ldi	r28, 0x04	; 4
    2f26:	d6 e0       	ldi	r29, 0x06	; 6
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
    2f28:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
     if (sys.abort) { return; }
    2f2c:	88 81       	ld	r24, Y
    2f2e:	81 11       	cpse	r24, r1
    2f30:	0d c0       	rjmp	.+26     	; 0x2f4c <mc_dwell+0xae>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2f32:	2f ef       	ldi	r18, 0xFF	; 255
    2f34:	80 e7       	ldi	r24, 0x70	; 112
    2f36:	92 e0       	ldi	r25, 0x02	; 2
    2f38:	21 50       	subi	r18, 0x01	; 1
    2f3a:	80 40       	sbci	r24, 0x00	; 0
    2f3c:	90 40       	sbci	r25, 0x00	; 0
    2f3e:	e1 f7       	brne	.-8      	; 0x2f38 <mc_dwell+0x9a>
    2f40:	00 c0       	rjmp	.+0      	; 0x2f42 <mc_dwell+0xa4>
    2f42:	00 00       	nop
    2f44:	21 e0       	ldi	r18, 0x01	; 1
    2f46:	c2 1a       	sub	r12, r18
    2f48:	d1 08       	sbc	r13, r1
   if (sys.state == STATE_CHECK_MODE) { return; }
   
   uint16_t i = floor(1000/DWELL_TIME_STEP*seconds);
   protocol_buffer_synchronize();
   delay_ms(floor(1000*seconds-i*DWELL_TIME_STEP)); // Delay millisecond remainder.
   while (i-- > 0) {
    2f4a:	71 f7       	brne	.-36     	; 0x2f28 <mc_dwell+0x8a>
     // NOTE: Check and execute realtime commands during dwell every <= DWELL_TIME_STEP milliseconds.
     protocol_execute_realtime();
     if (sys.abort) { return; }
     _delay_ms(DWELL_TIME_STEP); // Delay DWELL_TIME_STEP increment
   }
}
    2f4c:	df 91       	pop	r29
    2f4e:	cf 91       	pop	r28
    2f50:	ff 90       	pop	r15
    2f52:	ef 90       	pop	r14
    2f54:	df 90       	pop	r13
    2f56:	cf 90       	pop	r12
    2f58:	bf 90       	pop	r11
    2f5a:	af 90       	pop	r10
    2f5c:	9f 90       	pop	r9
    2f5e:	8f 90       	pop	r8
    2f60:	08 95       	ret

00002f62 <mc_homing_cycle>:
      bit_true_atomic(sys_rt_exec_alarm, (EXEC_ALARM_HARD_LIMIT|EXEC_CRITICAL_EVENT));
      return;
    }
  #endif
   
  limits_disable(); // Disable hard limits pin change register for cycle duration
    2f62:	0e 94 06 11 	call	0x220c	; 0x220c <limits_disable>
    
  // -------------------------------------------------------------------------------------
  // Perform homing routine. NOTE: Special motion case. Only system reset works.
  
  // Search to engage all axes limit switches at faster homing seek rate.
  limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
    2f66:	84 e0       	ldi	r24, 0x04	; 4
    2f68:	0e 94 8f 11 	call	0x231e	; 0x231e <limits_go_home>
  #ifdef HOMING_CYCLE_1
    limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
    2f6c:	83 e0       	ldi	r24, 0x03	; 3
    2f6e:	0e 94 8f 11 	call	0x231e	; 0x231e <limits_go_home>
  #endif
  #ifdef HOMING_CYCLE_2
    limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
  #endif
    
  protocol_execute_realtime(); // Check for reset and set system abort.
    2f72:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
    2f76:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <sys>
    2f7a:	81 11       	cpse	r24, r1
    2f7c:	04 c0       	rjmp	.+8      	; 0x2f86 <mc_homing_cycle+0x24>

  // Homing cycle complete! Setup system for normal operation.
  // -------------------------------------------------------------------------------------

  // Gcode parser position was circumvented by the limits_go_home() routine, so sync position now.
  gc_sync_position();
    2f7e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <gc_sync_position>

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
    2f82:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
    2f86:	08 95       	ret

00002f88 <mc_probe_cycle>:
    uint8_t is_no_error, int32_t line_number)
#else
  void mc_probe_cycle(float *target, float feed_rate, uint8_t invert_feed_rate, uint8_t is_probe_away,
    uint8_t is_no_error)
#endif
{ 
    2f88:	8f 92       	push	r8
    2f8a:	9f 92       	push	r9
    2f8c:	af 92       	push	r10
    2f8e:	bf 92       	push	r11
    2f90:	cf 92       	push	r12
    2f92:	df 92       	push	r13
    2f94:	ef 92       	push	r14
    2f96:	0f 93       	push	r16
    2f98:	cf 93       	push	r28
    2f9a:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return; }
    2f9c:	30 91 05 06 	lds	r19, 0x0605	; 0x800605 <sys+0x1>
    2fa0:	32 30       	cpi	r19, 0x02	; 2
    2fa2:	09 f4       	brne	.+2      	; 0x2fa6 <mc_probe_cycle+0x1e>
    2fa4:	69 c0       	rjmp	.+210    	; 0x3078 <mc_probe_cycle+0xf0>
    2fa6:	c2 2f       	mov	r28, r18
    2fa8:	4a 01       	movw	r8, r20
    2faa:	5b 01       	movw	r10, r22
    2fac:	6c 01       	movw	r12, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
    2fae:	0e 94 3b 22 	call	0x4476	; 0x4476 <protocol_buffer_synchronize>

  // Initialize probing control variables
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.  
    2fb2:	10 92 20 06 	sts	0x0620, r1	; 0x800620 <sys+0x1c>
  probe_configure_invert_mask(is_probe_away);
    2fb6:	80 2f       	mov	r24, r16
    2fb8:	0e 94 26 20 	call	0x404c	; 0x404c <probe_configure_invert_mask>
  
  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
    2fbc:	0e 94 38 20 	call	0x4070	; 0x4070 <probe_get_state>
    2fc0:	88 23       	and	r24, r24
    2fc2:	51 f0       	breq	.+20     	; 0x2fd8 <mc_probe_cycle+0x50>
    bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL);
    2fc4:	9f b7       	in	r25, 0x3f	; 63
    2fc6:	f8 94       	cli
    2fc8:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    2fcc:	80 61       	ori	r24, 0x10	; 16
    2fce:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    2fd2:	9f bf       	out	0x3f, r25	; 63
    protocol_execute_realtime();
    2fd4:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
  }
  if (sys.abort) { return; } // Return if system reset has been issued.
    2fd8:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <sys>
    2fdc:	81 11       	cpse	r24, r1
    2fde:	4c c0       	rjmp	.+152    	; 0x3078 <mc_probe_cycle+0xf0>

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  #ifdef USE_LINE_NUMBERS
    mc_line(target, feed_rate, invert_feed_rate, line_number);
  #else
    mc_line(target, feed_rate, invert_feed_rate);
    2fe0:	2c 2f       	mov	r18, r28
    2fe2:	b5 01       	movw	r22, r10
    2fe4:	a4 01       	movw	r20, r8
    2fe6:	c6 01       	movw	r24, r12
    2fe8:	0e 94 37 14 	call	0x286e	; 0x286e <mc_line>
  #endif
  
  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	80 93 8a 05 	sts	0x058A, r24	; 0x80058a <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
    2ff2:	9f b7       	in	r25, 0x3f	; 63
    2ff4:	f8 94       	cli
    2ff6:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    2ffa:	82 60       	ori	r24, 0x02	; 2
    2ffc:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    3000:	9f bf       	out	0x3f, r25	; 63
  do {
    protocol_execute_realtime(); 
    if (sys.abort) { return; } // Check for system abort
    3002:	c4 e0       	ldi	r28, 0x04	; 4
    3004:	d6 e0       	ldi	r29, 0x06	; 6
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START);
  do {
    protocol_execute_realtime(); 
    3006:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    300a:	98 81       	ld	r25, Y
    300c:	91 11       	cpse	r25, r1
    300e:	34 c0       	rjmp	.+104    	; 0x3078 <mc_probe_cycle+0xf0>
  } while (sys.state != STATE_IDLE);
    3010:	99 81       	ldd	r25, Y+1	; 0x01
    3012:	91 11       	cpse	r25, r1
    3014:	f8 cf       	rjmp	.-16     	; 0x3006 <mc_probe_cycle+0x7e>
  
  // Probing cycle complete!
  
  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
    3016:	80 91 8a 05 	lds	r24, 0x058A	; 0x80058a <sys_probe_state>
    301a:	81 30       	cpi	r24, 0x01	; 1
    301c:	a9 f4       	brne	.+42     	; 0x3048 <mc_probe_cycle+0xc0>
    if (is_no_error) { memcpy(sys.probe_position, sys.position, sizeof(float)*N_AXIS); }
    301e:	ee 20       	and	r14, r14
    3020:	51 f0       	breq	.+20     	; 0x3036 <mc_probe_cycle+0xae>
    3022:	8c e0       	ldi	r24, 0x0C	; 12
    3024:	e8 e0       	ldi	r30, 0x08	; 8
    3026:	f6 e0       	ldi	r31, 0x06	; 6
    3028:	a4 e1       	ldi	r26, 0x14	; 20
    302a:	b6 e0       	ldi	r27, 0x06	; 6
    302c:	01 90       	ld	r0, Z+
    302e:	0d 92       	st	X+, r0
    3030:	8a 95       	dec	r24
    3032:	e1 f7       	brne	.-8      	; 0x302c <mc_probe_cycle+0xa4>
    3034:	0c c0       	rjmp	.+24     	; 0x304e <mc_probe_cycle+0xc6>
    else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_PROBE_FAIL); }
    3036:	9f b7       	in	r25, 0x3f	; 63
    3038:	f8 94       	cli
    303a:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    303e:	80 61       	ori	r24, 0x10	; 16
    3040:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    3044:	9f bf       	out	0x3f, r25	; 63
    3046:	03 c0       	rjmp	.+6      	; 0x304e <mc_probe_cycle+0xc6>
  } else { 
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
    3048:	81 e0       	ldi	r24, 0x01	; 1
    304a:	80 93 20 06 	sts	0x0620, r24	; 0x800620 <sys+0x1c>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
    304e:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys_probe_state>
  protocol_execute_realtime();   // Check and execute run-time commands
    3052:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Check for system abort
    3056:	80 91 04 06 	lds	r24, 0x0604	; 0x800604 <sys>
    305a:	81 11       	cpse	r24, r1
    305c:	0d c0       	rjmp	.+26     	; 0x3078 <mc_probe_cycle+0xf0>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reest step segment buffer.
    305e:	0e 94 c6 2e 	call	0x5d8c	; 0x5d8c <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
    3062:	0e 94 e0 1a 	call	0x35c0	; 0x35c0 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
    3066:	0e 94 a7 1e 	call	0x3d4e	; 0x3d4e <plan_sync_position>

  // TODO: Update the g-code parser code to not require this target calculation but uses a gc_sync_position() call.
  // NOTE: The target[] variable updated here will be sent back and synced with the g-code parser.
  system_convert_array_steps_to_mpos(target, sys.position);
    306a:	68 e0       	ldi	r22, 0x08	; 8
    306c:	76 e0       	ldi	r23, 0x06	; 6
    306e:	c6 01       	movw	r24, r12
    3070:	0e 94 97 38 	call	0x712e	; 0x712e <system_convert_array_steps_to_mpos>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
    3074:	0e 94 54 25 	call	0x4aa8	; 0x4aa8 <report_probe_parameters>
  #endif
}
    3078:	df 91       	pop	r29
    307a:	cf 91       	pop	r28
    307c:	0f 91       	pop	r16
    307e:	ef 90       	pop	r14
    3080:	df 90       	pop	r13
    3082:	cf 90       	pop	r12
    3084:	bf 90       	pop	r11
    3086:	af 90       	pop	r10
    3088:	9f 90       	pop	r9
    308a:	8f 90       	pop	r8
    308c:	08 95       	ret

0000308e <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
    308e:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    3092:	84 fd       	sbrc	r24, 4
    3094:	2a c0       	rjmp	.+84     	; 0x30ea <mc_reset+0x5c>
    bit_true_atomic(sys_rt_exec_state, EXEC_RESET);
    3096:	9f b7       	in	r25, 0x3f	; 63
    3098:	f8 94       	cli
    309a:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    309e:	80 61       	ori	r24, 0x10	; 16
    30a0:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    30a4:	9f bf       	out	0x3f, r25	; 63

    // Kill spindle and coolant.   
    spindle_stop();
    30a6:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
    coolant_stop();
    30aa:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING)) || (sys.suspend == SUSPEND_ENABLE_HOLD)) {
    30ae:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    30b2:	98 2f       	mov	r25, r24
    30b4:	9c 70       	andi	r25, 0x0C	; 12
    30b6:	21 f4       	brne	.+8      	; 0x30c0 <mc_reset+0x32>
    30b8:	90 91 06 06 	lds	r25, 0x0606	; 0x800606 <sys+0x2>
    30bc:	91 30       	cpi	r25, 0x01	; 1
    30be:	a9 f4       	brne	.+42     	; 0x30ea <mc_reset+0x5c>
      if (sys.state == STATE_HOMING) { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_HOMING_FAIL); }
    30c0:	84 30       	cpi	r24, 0x04	; 4
    30c2:	49 f4       	brne	.+18     	; 0x30d6 <mc_reset+0x48>
    30c4:	9f b7       	in	r25, 0x3f	; 63
    30c6:	f8 94       	cli
    30c8:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    30cc:	80 62       	ori	r24, 0x20	; 32
    30ce:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    30d2:	9f bf       	out	0x3f, r25	; 63
    30d4:	08 c0       	rjmp	.+16     	; 0x30e6 <mc_reset+0x58>
      else { bit_true_atomic(sys_rt_exec_alarm, EXEC_ALARM_ABORT_CYCLE); }
    30d6:	9f b7       	in	r25, 0x3f	; 63
    30d8:	f8 94       	cli
    30da:	80 91 8b 05 	lds	r24, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    30de:	88 60       	ori	r24, 0x08	; 8
    30e0:	80 93 8b 05 	sts	0x058B, r24	; 0x80058b <sys_rt_exec_alarm>
    30e4:	9f bf       	out	0x3f, r25	; 63
      st_go_idle(); // Force kill steppers. Position has likely been lost.
    30e6:	0e 94 64 2c 	call	0x58c8	; 0x58c8 <st_go_idle>
    30ea:	08 95       	ret

000030ec <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more 
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us) 
{
  while (us) {
    30ec:	4f 92       	push	r4
    30ee:	5f 92       	push	r5
    30f0:	6f 92       	push	r6
    30f2:	7f 92       	push	r7
    30f4:	8f 92       	push	r8
    30f6:	9f 92       	push	r9
    30f8:	af 92       	push	r10
    30fa:	bf 92       	push	r11
    30fc:	cf 92       	push	r12
    30fe:	df 92       	push	r13
    3100:	ef 92       	push	r14
    3102:	ff 92       	push	r15
    3104:	0f 93       	push	r16
    3106:	1f 93       	push	r17
    3108:	cf 93       	push	r28
    310a:	df 93       	push	r29
    310c:	dc 01       	movw	r26, r24
    310e:	fb 01       	movw	r30, r22
    3110:	c0 81       	ld	r28, Z
    3112:	d0 e0       	ldi	r29, 0x00	; 0
    3114:	fc 01       	movw	r30, r24
    3116:	ec 0f       	add	r30, r28
    3118:	fd 1f       	adc	r31, r29
    311a:	90 81       	ld	r25, Z
    311c:	9d 32       	cpi	r25, 0x2D	; 45
    311e:	29 f4       	brne	.+10     	; 0x312a <read_float+0x3e>
    3120:	ef 01       	movw	r28, r30
    3122:	22 96       	adiw	r28, 0x02	; 2
    3124:	91 81       	ldd	r25, Z+1	; 0x01
    3126:	01 e0       	ldi	r16, 0x01	; 1
    3128:	0b c0       	rjmp	.+22     	; 0x3140 <read_float+0x54>
    312a:	9b 32       	cpi	r25, 0x2B	; 43
    312c:	29 f0       	breq	.+10     	; 0x3138 <read_float+0x4c>
    312e:	21 96       	adiw	r28, 0x01	; 1
    3130:	ca 0f       	add	r28, r26
    3132:	db 1f       	adc	r29, r27
    3134:	00 e0       	ldi	r16, 0x00	; 0
    3136:	04 c0       	rjmp	.+8      	; 0x3140 <read_float+0x54>
    3138:	ef 01       	movw	r28, r30
    313a:	22 96       	adiw	r28, 0x02	; 2
    313c:	91 81       	ldd	r25, Z+1	; 0x01
    313e:	00 e0       	ldi	r16, 0x00	; 0
    3140:	80 e0       	ldi	r24, 0x00	; 0
    3142:	20 e0       	ldi	r18, 0x00	; 0
    3144:	10 e0       	ldi	r17, 0x00	; 0
    3146:	41 2c       	mov	r4, r1
    3148:	51 2c       	mov	r5, r1
    314a:	32 01       	movw	r6, r4
    314c:	31 e0       	ldi	r19, 0x01	; 1
    314e:	fe 01       	movw	r30, r28
    3150:	90 53       	subi	r25, 0x30	; 48
    3152:	9a 30       	cpi	r25, 0x0A	; 10
    3154:	10 f5       	brcc	.+68     	; 0x319a <read_float+0xae>
    3156:	2f 5f       	subi	r18, 0xFF	; 255
    3158:	29 30       	cpi	r18, 0x09	; 9
    315a:	d8 f4       	brcc	.+54     	; 0x3192 <read_float+0xa6>
    315c:	81 11       	cpse	r24, r1
    315e:	11 50       	subi	r17, 0x01	; 1
    3160:	53 01       	movw	r10, r6
    3162:	42 01       	movw	r8, r4
    3164:	88 0c       	add	r8, r8
    3166:	99 1c       	adc	r9, r9
    3168:	aa 1c       	adc	r10, r10
    316a:	bb 1c       	adc	r11, r11
    316c:	88 0c       	add	r8, r8
    316e:	99 1c       	adc	r9, r9
    3170:	aa 1c       	adc	r10, r10
    3172:	bb 1c       	adc	r11, r11
    3174:	84 0c       	add	r8, r4
    3176:	95 1c       	adc	r9, r5
    3178:	a6 1c       	adc	r10, r6
    317a:	b7 1c       	adc	r11, r7
    317c:	88 0c       	add	r8, r8
    317e:	99 1c       	adc	r9, r9
    3180:	aa 1c       	adc	r10, r10
    3182:	bb 1c       	adc	r11, r11
    3184:	24 01       	movw	r4, r8
    3186:	35 01       	movw	r6, r10
    3188:	49 0e       	add	r4, r25
    318a:	51 1c       	adc	r5, r1
    318c:	61 1c       	adc	r6, r1
    318e:	71 1c       	adc	r7, r1
    3190:	09 c0       	rjmp	.+18     	; 0x31a4 <read_float+0xb8>
    3192:	81 11       	cpse	r24, r1
    3194:	07 c0       	rjmp	.+14     	; 0x31a4 <read_float+0xb8>
    3196:	1f 5f       	subi	r17, 0xFF	; 255
    3198:	05 c0       	rjmp	.+10     	; 0x31a4 <read_float+0xb8>
    319a:	9e 3f       	cpi	r25, 0xFE	; 254
    319c:	31 f4       	brne	.+12     	; 0x31aa <read_float+0xbe>
    319e:	81 11       	cpse	r24, r1
    31a0:	04 c0       	rjmp	.+8      	; 0x31aa <read_float+0xbe>
    31a2:	83 2f       	mov	r24, r19
    31a4:	90 81       	ld	r25, Z
    31a6:	21 96       	adiw	r28, 0x01	; 1
    31a8:	d2 cf       	rjmp	.-92     	; 0x314e <read_float+0x62>
    31aa:	22 23       	and	r18, r18
    31ac:	09 f4       	brne	.+2      	; 0x31b0 <read_float+0xc4>
    31ae:	52 c0       	rjmp	.+164    	; 0x3254 <read_float+0x168>
    31b0:	6a 01       	movw	r12, r20
    31b2:	7b 01       	movw	r14, r22
    31b4:	5d 01       	movw	r10, r26
    31b6:	c3 01       	movw	r24, r6
    31b8:	b2 01       	movw	r22, r4
    31ba:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    31be:	2b 01       	movw	r4, r22
    31c0:	3c 01       	movw	r6, r24
    31c2:	20 e0       	ldi	r18, 0x00	; 0
    31c4:	30 e0       	ldi	r19, 0x00	; 0
    31c6:	a9 01       	movw	r20, r18
    31c8:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    31cc:	88 23       	and	r24, r24
    31ce:	51 f1       	breq	.+84     	; 0x3224 <read_float+0x138>
    31d0:	1f 3f       	cpi	r17, 0xFF	; 255
    31d2:	6c f4       	brge	.+26     	; 0x31ee <read_float+0x102>
    31d4:	2a e0       	ldi	r18, 0x0A	; 10
    31d6:	37 ed       	ldi	r19, 0xD7	; 215
    31d8:	43 e2       	ldi	r20, 0x23	; 35
    31da:	5c e3       	ldi	r21, 0x3C	; 60
    31dc:	c3 01       	movw	r24, r6
    31de:	b2 01       	movw	r22, r4
    31e0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    31e4:	2b 01       	movw	r4, r22
    31e6:	3c 01       	movw	r6, r24
    31e8:	1e 5f       	subi	r17, 0xFE	; 254
    31ea:	1f 3f       	cpi	r17, 0xFF	; 255
    31ec:	9c f3       	brlt	.-26     	; 0x31d4 <read_float+0xe8>
    31ee:	11 23       	and	r17, r17
    31f0:	5c f4       	brge	.+22     	; 0x3208 <read_float+0x11c>
    31f2:	2d ec       	ldi	r18, 0xCD	; 205
    31f4:	3c ec       	ldi	r19, 0xCC	; 204
    31f6:	4c ec       	ldi	r20, 0xCC	; 204
    31f8:	5d e3       	ldi	r21, 0x3D	; 61
    31fa:	c3 01       	movw	r24, r6
    31fc:	b2 01       	movw	r22, r4
    31fe:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3202:	2b 01       	movw	r4, r22
    3204:	3c 01       	movw	r6, r24
    3206:	0e c0       	rjmp	.+28     	; 0x3224 <read_float+0x138>
    3208:	11 16       	cp	r1, r17
    320a:	64 f4       	brge	.+24     	; 0x3224 <read_float+0x138>
    320c:	20 e0       	ldi	r18, 0x00	; 0
    320e:	30 e0       	ldi	r19, 0x00	; 0
    3210:	40 e2       	ldi	r20, 0x20	; 32
    3212:	51 e4       	ldi	r21, 0x41	; 65
    3214:	c3 01       	movw	r24, r6
    3216:	b2 01       	movw	r22, r4
    3218:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    321c:	2b 01       	movw	r4, r22
    321e:	3c 01       	movw	r6, r24
    3220:	11 50       	subi	r17, 0x01	; 1
    3222:	a1 f7       	brne	.-24     	; 0x320c <read_float+0x120>
    3224:	00 23       	and	r16, r16
    3226:	51 f0       	breq	.+20     	; 0x323c <read_float+0x150>
    3228:	77 fa       	bst	r7, 7
    322a:	70 94       	com	r7
    322c:	77 f8       	bld	r7, 7
    322e:	70 94       	com	r7
    3230:	f6 01       	movw	r30, r12
    3232:	40 82       	st	Z, r4
    3234:	51 82       	std	Z+1, r5	; 0x01
    3236:	62 82       	std	Z+2, r6	; 0x02
    3238:	73 82       	std	Z+3, r7	; 0x03
    323a:	05 c0       	rjmp	.+10     	; 0x3246 <read_float+0x15a>
    323c:	f6 01       	movw	r30, r12
    323e:	40 82       	st	Z, r4
    3240:	51 82       	std	Z+1, r5	; 0x01
    3242:	62 82       	std	Z+2, r6	; 0x02
    3244:	73 82       	std	Z+3, r7	; 0x03
    3246:	ca 19       	sub	r28, r10
    3248:	db 09       	sbc	r29, r11
    324a:	c1 50       	subi	r28, 0x01	; 1
    324c:	f7 01       	movw	r30, r14
    324e:	c0 83       	st	Z, r28
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	01 c0       	rjmp	.+2      	; 0x3256 <read_float+0x16a>
    3254:	80 e0       	ldi	r24, 0x00	; 0
    3256:	df 91       	pop	r29
    3258:	cf 91       	pop	r28
    325a:	1f 91       	pop	r17
    325c:	0f 91       	pop	r16
    325e:	ff 90       	pop	r15
    3260:	ef 90       	pop	r14
    3262:	df 90       	pop	r13
    3264:	cf 90       	pop	r12
    3266:	bf 90       	pop	r11
    3268:	af 90       	pop	r10
    326a:	9f 90       	pop	r9
    326c:	8f 90       	pop	r8
    326e:	7f 90       	pop	r7
    3270:	6f 90       	pop	r6
    3272:	5f 90       	pop	r5
    3274:	4f 90       	pop	r4
    3276:	08 95       	ret

00003278 <delay_ms>:
    3278:	00 97       	sbiw	r24, 0x00	; 0
    327a:	41 f0       	breq	.+16     	; 0x328c <delay_ms+0x14>
    327c:	ef e9       	ldi	r30, 0x9F	; 159
    327e:	ff e0       	ldi	r31, 0x0F	; 15
    3280:	31 97       	sbiw	r30, 0x01	; 1
    3282:	f1 f7       	brne	.-4      	; 0x3280 <delay_ms+0x8>
    3284:	00 c0       	rjmp	.+0      	; 0x3286 <delay_ms+0xe>
    3286:	00 00       	nop
    3288:	01 97       	sbiw	r24, 0x01	; 1
    328a:	c1 f7       	brne	.-16     	; 0x327c <delay_ms+0x4>
    328c:	08 95       	ret

0000328e <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    328e:	4f 92       	push	r4
    3290:	5f 92       	push	r5
    3292:	6f 92       	push	r6
    3294:	7f 92       	push	r7
    3296:	8f 92       	push	r8
    3298:	9f 92       	push	r9
    329a:	af 92       	push	r10
    329c:	bf 92       	push	r11
    329e:	cf 92       	push	r12
    32a0:	df 92       	push	r13
    32a2:	ef 92       	push	r14
    32a4:	ff 92       	push	r15
    32a6:	4b 01       	movw	r8, r22
    32a8:	5c 01       	movw	r10, r24
    32aa:	69 01       	movw	r12, r18
    32ac:	7a 01       	movw	r14, r20
    32ae:	a5 01       	movw	r20, r10
    32b0:	94 01       	movw	r18, r8
    32b2:	c5 01       	movw	r24, r10
    32b4:	b4 01       	movw	r22, r8
    32b6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    32ba:	4b 01       	movw	r8, r22
    32bc:	5c 01       	movw	r10, r24
    32be:	a7 01       	movw	r20, r14
    32c0:	96 01       	movw	r18, r12
    32c2:	c7 01       	movw	r24, r14
    32c4:	b6 01       	movw	r22, r12
    32c6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    32ca:	9b 01       	movw	r18, r22
    32cc:	ac 01       	movw	r20, r24
    32ce:	c5 01       	movw	r24, r10
    32d0:	b4 01       	movw	r22, r8
    32d2:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    32d6:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    32da:	ff 90       	pop	r15
    32dc:	ef 90       	pop	r14
    32de:	df 90       	pop	r13
    32e0:	cf 90       	pop	r12
    32e2:	bf 90       	pop	r11
    32e4:	af 90       	pop	r10
    32e6:	9f 90       	pop	r9
    32e8:	8f 90       	pop	r8
    32ea:	7f 90       	pop	r7
    32ec:	6f 90       	pop	r6
    32ee:	5f 90       	pop	r5
    32f0:	4f 90       	pop	r4
    32f2:	08 95       	ret

000032f4 <planner_recalculate>:
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
  return(block_index);
}
    32f4:	2f 92       	push	r2
    32f6:	3f 92       	push	r3
    32f8:	4f 92       	push	r4
    32fa:	5f 92       	push	r5
    32fc:	6f 92       	push	r6
    32fe:	7f 92       	push	r7
    3300:	8f 92       	push	r8
    3302:	9f 92       	push	r9
    3304:	af 92       	push	r10
    3306:	bf 92       	push	r11
    3308:	cf 92       	push	r12
    330a:	df 92       	push	r13
    330c:	ef 92       	push	r14
    330e:	ff 92       	push	r15
    3310:	0f 93       	push	r16
    3312:	1f 93       	push	r17
    3314:	cf 93       	push	r28
    3316:	df 93       	push	r29
    3318:	c0 91 82 01 	lds	r28, 0x0182	; 0x800182 <block_buffer_head>
    331c:	c1 11       	cpse	r28, r1
    331e:	01 c0       	rjmp	.+2      	; 0x3322 <planner_recalculate+0x2e>
    3320:	c2 e1       	ldi	r28, 0x12	; 18
    3322:	c1 50       	subi	r28, 0x01	; 1
    3324:	d0 91 80 01 	lds	r29, 0x0180	; 0x800180 <block_buffer_planned>
    3328:	dc 17       	cp	r29, r28
    332a:	09 f4       	brne	.+2      	; 0x332e <planner_recalculate+0x3a>
    332c:	36 c1       	rjmp	.+620    	; 0x359a <planner_recalculate+0x2a6>
    332e:	0c 2f       	mov	r16, r28
    3330:	10 e0       	ldi	r17, 0x00	; 0
    3332:	29 e2       	ldi	r18, 0x29	; 41
    3334:	c2 9f       	mul	r28, r18
    3336:	c0 01       	movw	r24, r0
    3338:	11 24       	eor	r1, r1
    333a:	fc 01       	movw	r30, r24
    333c:	ec 57       	subi	r30, 0x7C	; 124
    333e:	fe 4f       	sbci	r31, 0xFE	; 254
    3340:	6f 01       	movw	r12, r30
    3342:	e5 88       	ldd	r14, Z+21	; 0x15
    3344:	f6 88       	ldd	r15, Z+22	; 0x16
    3346:	97 88       	ldd	r9, Z+23	; 0x17
    3348:	80 8c       	ldd	r8, Z+24	; 0x18
    334a:	61 a1       	ldd	r22, Z+33	; 0x21
    334c:	72 a1       	ldd	r23, Z+34	; 0x22
    334e:	83 a1       	ldd	r24, Z+35	; 0x23
    3350:	94 a1       	ldd	r25, Z+36	; 0x24
    3352:	9b 01       	movw	r18, r22
    3354:	ac 01       	movw	r20, r24
    3356:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    335a:	f6 01       	movw	r30, r12
    335c:	25 a1       	ldd	r18, Z+37	; 0x25
    335e:	36 a1       	ldd	r19, Z+38	; 0x26
    3360:	47 a1       	ldd	r20, Z+39	; 0x27
    3362:	50 a5       	ldd	r21, Z+40	; 0x28
    3364:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3368:	a6 2e       	mov	r10, r22
    336a:	b7 2e       	mov	r11, r23
    336c:	c8 2e       	mov	r12, r24
    336e:	d9 2e       	mov	r13, r25
    3370:	26 2f       	mov	r18, r22
    3372:	37 2f       	mov	r19, r23
    3374:	48 2f       	mov	r20, r24
    3376:	59 2f       	mov	r21, r25
    3378:	6e 2d       	mov	r22, r14
    337a:	7f 2d       	mov	r23, r15
    337c:	89 2d       	mov	r24, r9
    337e:	98 2d       	mov	r25, r8
    3380:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3384:	88 23       	and	r24, r24
    3386:	24 f0       	brlt	.+8      	; 0x3390 <planner_recalculate+0x9c>
    3388:	ea 2c       	mov	r14, r10
    338a:	fb 2c       	mov	r15, r11
    338c:	9c 2c       	mov	r9, r12
    338e:	8d 2c       	mov	r8, r13
    3390:	89 e2       	ldi	r24, 0x29	; 41
    3392:	80 9f       	mul	r24, r16
    3394:	f0 01       	movw	r30, r0
    3396:	81 9f       	mul	r24, r17
    3398:	f0 0d       	add	r31, r0
    339a:	11 24       	eor	r1, r1
    339c:	ec 57       	subi	r30, 0x7C	; 124
    339e:	fe 4f       	sbci	r31, 0xFE	; 254
    33a0:	8e 2d       	mov	r24, r14
    33a2:	9f 2d       	mov	r25, r15
    33a4:	a9 2d       	mov	r26, r9
    33a6:	b8 2d       	mov	r27, r8
    33a8:	81 8b       	std	Z+17, r24	; 0x11
    33aa:	92 8b       	std	Z+18, r25	; 0x12
    33ac:	a3 8b       	std	Z+19, r26	; 0x13
    33ae:	b4 8b       	std	Z+20, r27	; 0x14
    33b0:	c1 11       	cpse	r28, r1
    33b2:	01 c0       	rjmp	.+2      	; 0x33b6 <planner_recalculate+0xc2>
    33b4:	c2 e1       	ldi	r28, 0x12	; 18
    33b6:	c1 50       	subi	r28, 0x01	; 1
    33b8:	dc 13       	cpse	r29, r28
    33ba:	07 c0       	rjmp	.+14     	; 0x33ca <planner_recalculate+0xd6>
    33bc:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    33c0:	d8 13       	cpse	r29, r24
    33c2:	7c c0       	rjmp	.+248    	; 0x34bc <planner_recalculate+0x1c8>
    33c4:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <st_update_plan_block_parameters>
    33c8:	79 c0       	rjmp	.+242    	; 0x34bc <planner_recalculate+0x1c8>
    33ca:	29 e2       	ldi	r18, 0x29	; 41
    33cc:	20 9f       	mul	r18, r16
    33ce:	c0 01       	movw	r24, r0
    33d0:	21 9f       	mul	r18, r17
    33d2:	90 0d       	add	r25, r0
    33d4:	11 24       	eor	r1, r1
    33d6:	9c 01       	movw	r18, r24
    33d8:	2c 57       	subi	r18, 0x7C	; 124
    33da:	3e 4f       	sbci	r19, 0xFE	; 254
    33dc:	69 01       	movw	r12, r18
    33de:	d9 e2       	ldi	r29, 0x29	; 41
    33e0:	ec 2e       	mov	r14, r28
    33e2:	f1 2c       	mov	r15, r1
    33e4:	de 9d       	mul	r29, r14
    33e6:	80 01       	movw	r16, r0
    33e8:	df 9d       	mul	r29, r15
    33ea:	10 0d       	add	r17, r0
    33ec:	11 24       	eor	r1, r1
    33ee:	0c 57       	subi	r16, 0x7C	; 124
    33f0:	1e 4f       	sbci	r17, 0xFE	; 254
    33f2:	c1 11       	cpse	r28, r1
    33f4:	01 c0       	rjmp	.+2      	; 0x33f8 <planner_recalculate+0x104>
    33f6:	c2 e1       	ldi	r28, 0x12	; 18
    33f8:	c1 50       	subi	r28, 0x01	; 1
    33fa:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    33fe:	8c 13       	cpse	r24, r28
    3400:	02 c0       	rjmp	.+4      	; 0x3406 <planner_recalculate+0x112>
    3402:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <st_update_plan_block_parameters>
    3406:	de 9d       	mul	r29, r14
    3408:	f0 01       	movw	r30, r0
    340a:	df 9d       	mul	r29, r15
    340c:	f0 0d       	add	r31, r0
    340e:	11 24       	eor	r1, r1
    3410:	ec 57       	subi	r30, 0x7C	; 124
    3412:	fe 4f       	sbci	r31, 0xFE	; 254
    3414:	45 88       	ldd	r4, Z+21	; 0x15
    3416:	56 88       	ldd	r5, Z+22	; 0x16
    3418:	67 88       	ldd	r6, Z+23	; 0x17
    341a:	70 8c       	ldd	r7, Z+24	; 0x18
    341c:	a3 01       	movw	r20, r6
    341e:	92 01       	movw	r18, r4
    3420:	61 89       	ldd	r22, Z+17	; 0x11
    3422:	72 89       	ldd	r23, Z+18	; 0x12
    3424:	83 89       	ldd	r24, Z+19	; 0x13
    3426:	94 89       	ldd	r25, Z+20	; 0x14
    3428:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    342c:	88 23       	and	r24, r24
    342e:	09 f4       	brne	.+2      	; 0x3432 <planner_recalculate+0x13e>
    3430:	40 c0       	rjmp	.+128    	; 0x34b2 <planner_recalculate+0x1be>
    3432:	de 9d       	mul	r29, r14
    3434:	c0 01       	movw	r24, r0
    3436:	df 9d       	mul	r29, r15
    3438:	90 0d       	add	r25, r0
    343a:	11 24       	eor	r1, r1
    343c:	fc 01       	movw	r30, r24
    343e:	ec 57       	subi	r30, 0x7C	; 124
    3440:	fe 4f       	sbci	r31, 0xFE	; 254
    3442:	5f 01       	movw	r10, r30
    3444:	61 a1       	ldd	r22, Z+33	; 0x21
    3446:	72 a1       	ldd	r23, Z+34	; 0x22
    3448:	83 a1       	ldd	r24, Z+35	; 0x23
    344a:	94 a1       	ldd	r25, Z+36	; 0x24
    344c:	9b 01       	movw	r18, r22
    344e:	ac 01       	movw	r20, r24
    3450:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    3454:	f5 01       	movw	r30, r10
    3456:	25 a1       	ldd	r18, Z+37	; 0x25
    3458:	36 a1       	ldd	r19, Z+38	; 0x26
    345a:	47 a1       	ldd	r20, Z+39	; 0x27
    345c:	50 a5       	ldd	r21, Z+40	; 0x28
    345e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3462:	f6 01       	movw	r30, r12
    3464:	21 89       	ldd	r18, Z+17	; 0x11
    3466:	32 89       	ldd	r19, Z+18	; 0x12
    3468:	43 89       	ldd	r20, Z+19	; 0x13
    346a:	54 89       	ldd	r21, Z+20	; 0x14
    346c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    3470:	4b 01       	movw	r8, r22
    3472:	5c 01       	movw	r10, r24
    3474:	9b 01       	movw	r18, r22
    3476:	ac 01       	movw	r20, r24
    3478:	c3 01       	movw	r24, r6
    347a:	b2 01       	movw	r22, r4
    347c:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    3480:	18 16       	cp	r1, r24
    3482:	64 f4       	brge	.+24     	; 0x349c <planner_recalculate+0x1a8>
    3484:	de 9d       	mul	r29, r14
    3486:	f0 01       	movw	r30, r0
    3488:	df 9d       	mul	r29, r15
    348a:	f0 0d       	add	r31, r0
    348c:	11 24       	eor	r1, r1
    348e:	ec 57       	subi	r30, 0x7C	; 124
    3490:	fe 4f       	sbci	r31, 0xFE	; 254
    3492:	81 8a       	std	Z+17, r8	; 0x11
    3494:	92 8a       	std	Z+18, r9	; 0x12
    3496:	a3 8a       	std	Z+19, r10	; 0x13
    3498:	b4 8a       	std	Z+20, r11	; 0x14
    349a:	0b c0       	rjmp	.+22     	; 0x34b2 <planner_recalculate+0x1be>
    349c:	de 9d       	mul	r29, r14
    349e:	f0 01       	movw	r30, r0
    34a0:	df 9d       	mul	r29, r15
    34a2:	f0 0d       	add	r31, r0
    34a4:	11 24       	eor	r1, r1
    34a6:	ec 57       	subi	r30, 0x7C	; 124
    34a8:	fe 4f       	sbci	r31, 0xFE	; 254
    34aa:	41 8a       	std	Z+17, r4	; 0x11
    34ac:	52 8a       	std	Z+18, r5	; 0x12
    34ae:	63 8a       	std	Z+19, r6	; 0x13
    34b0:	74 8a       	std	Z+20, r7	; 0x14
    34b2:	68 01       	movw	r12, r16
    34b4:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <block_buffer_planned>
    34b8:	8c 13       	cpse	r24, r28
    34ba:	92 cf       	rjmp	.-220    	; 0x33e0 <planner_recalculate+0xec>
    34bc:	20 90 80 01 	lds	r2, 0x0180	; 0x800180 <block_buffer_planned>
    34c0:	f9 e2       	ldi	r31, 0x29	; 41
    34c2:	2f 9e       	mul	r2, r31
    34c4:	c0 01       	movw	r24, r0
    34c6:	11 24       	eor	r1, r1
    34c8:	9c 01       	movw	r18, r24
    34ca:	2c 57       	subi	r18, 0x7C	; 124
    34cc:	3e 4f       	sbci	r19, 0xFE	; 254
    34ce:	79 01       	movw	r14, r18
    34d0:	c1 e0       	ldi	r28, 0x01	; 1
    34d2:	c2 0d       	add	r28, r2
    34d4:	c2 31       	cpi	r28, 0x12	; 18
    34d6:	09 f4       	brne	.+2      	; 0x34da <planner_recalculate+0x1e6>
    34d8:	c0 e0       	ldi	r28, 0x00	; 0
    34da:	30 90 82 01 	lds	r3, 0x0182	; 0x800182 <block_buffer_head>
    34de:	d9 e2       	ldi	r29, 0x29	; 41
    34e0:	58 c0       	rjmp	.+176    	; 0x3592 <planner_recalculate+0x29e>
    34e2:	cc 2e       	mov	r12, r28
    34e4:	d1 2c       	mov	r13, r1
    34e6:	dc 9d       	mul	r29, r12
    34e8:	80 01       	movw	r16, r0
    34ea:	dd 9d       	mul	r29, r13
    34ec:	10 0d       	add	r17, r0
    34ee:	11 24       	eor	r1, r1
    34f0:	0c 57       	subi	r16, 0x7C	; 124
    34f2:	1e 4f       	sbci	r17, 0xFE	; 254
    34f4:	f7 01       	movw	r30, r14
    34f6:	41 88       	ldd	r4, Z+17	; 0x11
    34f8:	52 88       	ldd	r5, Z+18	; 0x12
    34fa:	63 88       	ldd	r6, Z+19	; 0x13
    34fc:	74 88       	ldd	r7, Z+20	; 0x14
    34fe:	f8 01       	movw	r30, r16
    3500:	81 88       	ldd	r8, Z+17	; 0x11
    3502:	92 88       	ldd	r9, Z+18	; 0x12
    3504:	a3 88       	ldd	r10, Z+19	; 0x13
    3506:	b4 88       	ldd	r11, Z+20	; 0x14
    3508:	a5 01       	movw	r20, r10
    350a:	94 01       	movw	r18, r8
    350c:	c3 01       	movw	r24, r6
    350e:	b2 01       	movw	r22, r4
    3510:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3514:	88 23       	and	r24, r24
    3516:	24 f5       	brge	.+72     	; 0x3560 <planner_recalculate+0x26c>
    3518:	f7 01       	movw	r30, r14
    351a:	61 a1       	ldd	r22, Z+33	; 0x21
    351c:	72 a1       	ldd	r23, Z+34	; 0x22
    351e:	83 a1       	ldd	r24, Z+35	; 0x23
    3520:	94 a1       	ldd	r25, Z+36	; 0x24
    3522:	9b 01       	movw	r18, r22
    3524:	ac 01       	movw	r20, r24
    3526:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    352a:	f7 01       	movw	r30, r14
    352c:	25 a1       	ldd	r18, Z+37	; 0x25
    352e:	36 a1       	ldd	r19, Z+38	; 0x26
    3530:	47 a1       	ldd	r20, Z+39	; 0x27
    3532:	50 a5       	ldd	r21, Z+40	; 0x28
    3534:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3538:	a3 01       	movw	r20, r6
    353a:	92 01       	movw	r18, r4
    353c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    3540:	2b 01       	movw	r4, r22
    3542:	3c 01       	movw	r6, r24
    3544:	9b 01       	movw	r18, r22
    3546:	ac 01       	movw	r20, r24
    3548:	c5 01       	movw	r24, r10
    354a:	b4 01       	movw	r22, r8
    354c:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    3550:	18 16       	cp	r1, r24
    3552:	34 f4       	brge	.+12     	; 0x3560 <planner_recalculate+0x26c>
    3554:	f8 01       	movw	r30, r16
    3556:	41 8a       	std	Z+17, r4	; 0x11
    3558:	52 8a       	std	Z+18, r5	; 0x12
    355a:	63 8a       	std	Z+19, r6	; 0x13
    355c:	74 8a       	std	Z+20, r7	; 0x14
    355e:	2c 2e       	mov	r2, r28
    3560:	dc 9d       	mul	r29, r12
    3562:	f0 01       	movw	r30, r0
    3564:	dd 9d       	mul	r29, r13
    3566:	f0 0d       	add	r31, r0
    3568:	11 24       	eor	r1, r1
    356a:	ec 57       	subi	r30, 0x7C	; 124
    356c:	fe 4f       	sbci	r31, 0xFE	; 254
    356e:	25 89       	ldd	r18, Z+21	; 0x15
    3570:	36 89       	ldd	r19, Z+22	; 0x16
    3572:	47 89       	ldd	r20, Z+23	; 0x17
    3574:	50 8d       	ldd	r21, Z+24	; 0x18
    3576:	61 89       	ldd	r22, Z+17	; 0x11
    3578:	72 89       	ldd	r23, Z+18	; 0x12
    357a:	83 89       	ldd	r24, Z+19	; 0x13
    357c:	94 89       	ldd	r25, Z+20	; 0x14
    357e:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3582:	81 11       	cpse	r24, r1
    3584:	01 c0       	rjmp	.+2      	; 0x3588 <planner_recalculate+0x294>
    3586:	2c 2e       	mov	r2, r28
    3588:	cf 5f       	subi	r28, 0xFF	; 255
    358a:	c2 31       	cpi	r28, 0x12	; 18
    358c:	09 f4       	brne	.+2      	; 0x3590 <planner_recalculate+0x29c>
    358e:	c0 e0       	ldi	r28, 0x00	; 0
    3590:	78 01       	movw	r14, r16
    3592:	c3 11       	cpse	r28, r3
    3594:	a6 cf       	rjmp	.-180    	; 0x34e2 <planner_recalculate+0x1ee>
    3596:	20 92 80 01 	sts	0x0180, r2	; 0x800180 <block_buffer_planned>
    359a:	df 91       	pop	r29
    359c:	cf 91       	pop	r28
    359e:	1f 91       	pop	r17
    35a0:	0f 91       	pop	r16
    35a2:	ff 90       	pop	r15
    35a4:	ef 90       	pop	r14
    35a6:	df 90       	pop	r13
    35a8:	cf 90       	pop	r12
    35aa:	bf 90       	pop	r11
    35ac:	af 90       	pop	r10
    35ae:	9f 90       	pop	r9
    35b0:	8f 90       	pop	r8
    35b2:	7f 90       	pop	r7
    35b4:	6f 90       	pop	r6
    35b6:	5f 90       	pop	r5
    35b8:	4f 90       	pop	r4
    35ba:	3f 90       	pop	r3
    35bc:	2f 90       	pop	r2
    35be:	08 95       	ret

000035c0 <plan_reset>:
}


void plan_reset() 
{
  memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
    35c0:	8c e1       	ldi	r24, 0x1C	; 28
    35c2:	e4 e6       	ldi	r30, 0x64	; 100
    35c4:	f1 e0       	ldi	r31, 0x01	; 1
    35c6:	df 01       	movw	r26, r30
    35c8:	1d 92       	st	X+, r1
    35ca:	8a 95       	dec	r24
    35cc:	e9 f7       	brne	.-6      	; 0x35c8 <plan_reset+0x8>
  block_buffer_tail = 0;
    35ce:	10 92 83 01 	sts	0x0183, r1	; 0x800183 <block_buffer_tail>
  block_buffer_head = 0; // Empty = tail
    35d2:	10 92 82 01 	sts	0x0182, r1	; 0x800182 <block_buffer_head>
  next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
    35d6:	81 e0       	ldi	r24, 0x01	; 1
    35d8:	80 93 81 01 	sts	0x0181, r24	; 0x800181 <next_buffer_head>
  block_buffer_planned = 0; // = block_buffer_tail;
    35dc:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <block_buffer_planned>
    35e0:	08 95       	ret

000035e2 <plan_discard_current_block>:
}


void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    35e2:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    35e6:	90 91 82 01 	lds	r25, 0x0182	; 0x800182 <block_buffer_head>
    35ea:	98 17       	cp	r25, r24
    35ec:	69 f0       	breq	.+26     	; 0x3608 <plan_discard_current_block+0x26>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    35ee:	91 e0       	ldi	r25, 0x01	; 1
    35f0:	98 0f       	add	r25, r24
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    35f2:	92 31       	cpi	r25, 0x12	; 18
    35f4:	09 f4       	brne	.+2      	; 0x35f8 <plan_discard_current_block+0x16>
    35f6:	90 e0       	ldi	r25, 0x00	; 0
void plan_discard_current_block() 
{
  if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
    uint8_t block_index = plan_next_block_index( block_buffer_tail );
    // Push block_buffer_planned pointer, if encountered.
    if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
    35f8:	20 91 80 01 	lds	r18, 0x0180	; 0x800180 <block_buffer_planned>
    35fc:	82 13       	cpse	r24, r18
    35fe:	02 c0       	rjmp	.+4      	; 0x3604 <plan_discard_current_block+0x22>
    3600:	90 93 80 01 	sts	0x0180, r25	; 0x800180 <block_buffer_planned>
    block_buffer_tail = block_index;
    3604:	90 93 83 01 	sts	0x0183, r25	; 0x800183 <block_buffer_tail>
    3608:	08 95       	ret

0000360a <plan_get_current_block>:
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    360a:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    360e:	90 91 82 01 	lds	r25, 0x0182	; 0x800182 <block_buffer_head>
    3612:	98 17       	cp	r25, r24
    3614:	39 f0       	breq	.+14     	; 0x3624 <plan_get_current_block+0x1a>
  return(&block_buffer[block_buffer_tail]);
    3616:	29 e2       	ldi	r18, 0x29	; 41
    3618:	82 9f       	mul	r24, r18
    361a:	c0 01       	movw	r24, r0
    361c:	11 24       	eor	r1, r1
    361e:	8c 57       	subi	r24, 0x7C	; 124
    3620:	9e 4f       	sbci	r25, 0xFE	; 254
    3622:	08 95       	ret
}


plan_block_t *plan_get_current_block() 
{
  if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty  
    3624:	80 e0       	ldi	r24, 0x00	; 0
    3626:	90 e0       	ldi	r25, 0x00	; 0
  return(&block_buffer[block_buffer_tail]);
}
    3628:	08 95       	ret

0000362a <plan_get_exec_block_exit_speed>:


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    362a:	e0 91 83 01 	lds	r30, 0x0183	; 0x800183 <block_buffer_tail>
    362e:	ef 5f       	subi	r30, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    3630:	e2 31       	cpi	r30, 0x12	; 18
    3632:	09 f4       	brne	.+2      	; 0x3636 <plan_get_exec_block_exit_speed+0xc>
    3634:	e0 e0       	ldi	r30, 0x00	; 0


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3636:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <block_buffer_head>
    363a:	8e 17       	cp	r24, r30
    363c:	69 f0       	breq	.+26     	; 0x3658 <plan_get_exec_block_exit_speed+0x2e>
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
    363e:	89 e2       	ldi	r24, 0x29	; 41
    3640:	e8 9f       	mul	r30, r24
    3642:	f0 01       	movw	r30, r0
    3644:	11 24       	eor	r1, r1
    3646:	ec 57       	subi	r30, 0x7C	; 124
    3648:	fe 4f       	sbci	r31, 0xFE	; 254
    364a:	61 89       	ldd	r22, Z+17	; 0x11
    364c:	72 89       	ldd	r23, Z+18	; 0x12
    364e:	83 89       	ldd	r24, Z+19	; 0x13
    3650:	94 89       	ldd	r25, Z+20	; 0x14
    3652:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    3656:	08 95       	ret


float plan_get_exec_block_exit_speed()
{
  uint8_t block_index = plan_next_block_index(block_buffer_tail);
  if (block_index == block_buffer_head) { return( 0.0 ); }
    3658:	60 e0       	ldi	r22, 0x00	; 0
    365a:	70 e0       	ldi	r23, 0x00	; 0
    365c:	cb 01       	movw	r24, r22
  return( sqrt( block_buffer[block_index].entry_speed_sqr ) ); 
}
    365e:	08 95       	ret

00003660 <plan_check_full_buffer>:


// Returns the availability status of the block ring buffer. True, if full.
uint8_t plan_check_full_buffer()
{
    3660:	81 e0       	ldi	r24, 0x01	; 1
    3662:	20 91 83 01 	lds	r18, 0x0183	; 0x800183 <block_buffer_tail>
    3666:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <next_buffer_head>
    366a:	29 13       	cpse	r18, r25
    366c:	80 e0       	ldi	r24, 0x00	; 0
  if (block_buffer_tail == next_buffer_head) { return(true); }
  return(false);
}
    366e:	08 95       	ret

00003670 <plan_buffer_line>:
#ifdef USE_LINE_NUMBERS   
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate, int32_t line_number) 
#else
  void plan_buffer_line(float *target, float feed_rate, uint8_t invert_feed_rate) 
#endif
{
    3670:	2f 92       	push	r2
    3672:	3f 92       	push	r3
    3674:	4f 92       	push	r4
    3676:	5f 92       	push	r5
    3678:	6f 92       	push	r6
    367a:	7f 92       	push	r7
    367c:	8f 92       	push	r8
    367e:	9f 92       	push	r9
    3680:	af 92       	push	r10
    3682:	bf 92       	push	r11
    3684:	cf 92       	push	r12
    3686:	df 92       	push	r13
    3688:	ef 92       	push	r14
    368a:	ff 92       	push	r15
    368c:	0f 93       	push	r16
    368e:	1f 93       	push	r17
    3690:	cf 93       	push	r28
    3692:	df 93       	push	r29
    3694:	cd b7       	in	r28, 0x3d	; 61
    3696:	de b7       	in	r29, 0x3e	; 62
    3698:	e8 97       	sbiw	r28, 0x38	; 56
    369a:	0f b6       	in	r0, 0x3f	; 63
    369c:	f8 94       	cli
    369e:	de bf       	out	0x3e, r29	; 62
    36a0:	0f be       	out	0x3f, r0	; 63
    36a2:	cd bf       	out	0x3d, r28	; 61
    36a4:	4b a7       	std	Y+43, r20	; 0x2b
    36a6:	5c a7       	std	Y+44, r21	; 0x2c
    36a8:	6d a7       	std	Y+45, r22	; 0x2d
    36aa:	7e a7       	std	Y+46, r23	; 0x2e
    36ac:	02 2f       	mov	r16, r18
  // Prepare and initialize new block
  plan_block_t *block = &block_buffer[block_buffer_head];
    36ae:	20 91 82 01 	lds	r18, 0x0182	; 0x800182 <block_buffer_head>
  block->step_event_count = 0;
    36b2:	39 e2       	ldi	r19, 0x29	; 41
    36b4:	23 9f       	mul	r18, r19
    36b6:	a0 01       	movw	r20, r0
    36b8:	11 24       	eor	r1, r1
    36ba:	fa 01       	movw	r30, r20
    36bc:	ec 57       	subi	r30, 0x7C	; 124
    36be:	fe 4f       	sbci	r31, 0xFE	; 254
    36c0:	15 86       	std	Z+13, r1	; 0x0d
    36c2:	16 86       	std	Z+14, r1	; 0x0e
    36c4:	17 86       	std	Z+15, r1	; 0x0f
    36c6:	10 8a       	std	Z+16, r1	; 0x10
  block->millimeters = 0;
    36c8:	15 a2       	std	Z+37, r1	; 0x25
    36ca:	16 a2       	std	Z+38, r1	; 0x26
    36cc:	17 a2       	std	Z+39, r1	; 0x27
    36ce:	10 a6       	std	Z+40, r1	; 0x28
  block->direction_bits = 0;
    36d0:	10 82       	st	Z, r1
  block->acceleration = SOME_LARGE_VALUE; // Scaled down to maximum acceleration later
    36d2:	0f 2e       	mov	r0, r31
    36d4:	f9 e9       	ldi	r31, 0x99	; 153
    36d6:	cf 2e       	mov	r12, r31
    36d8:	f6 e7       	ldi	r31, 0x76	; 118
    36da:	df 2e       	mov	r13, r31
    36dc:	f6 e9       	ldi	r31, 0x96	; 150
    36de:	ef 2e       	mov	r14, r31
    36e0:	fe e7       	ldi	r31, 0x7E	; 126
    36e2:	ff 2e       	mov	r15, r31
    36e4:	f0 2d       	mov	r31, r0
    36e6:	c1 a2       	std	Z+33, r12	; 0x21
    36e8:	d2 a2       	std	Z+34, r13	; 0x22
    36ea:	e3 a2       	std	Z+35, r14	; 0x23
    36ec:	f4 a2       	std	Z+36, r15	; 0x24
    36ee:	9a 8f       	std	Y+26, r25	; 0x1a
    36f0:	89 8f       	std	Y+25, r24	; 0x19
    36f2:	83 ee       	ldi	r24, 0xE3	; 227
    36f4:	96 e0       	ldi	r25, 0x06	; 6
    36f6:	9a ab       	std	Y+50, r25	; 0x32
    36f8:	89 ab       	std	Y+49, r24	; 0x31
    36fa:	de 01       	movw	r26, r28
    36fc:	11 96       	adiw	r26, 0x01	; 1
    36fe:	bc 8f       	std	Y+28, r27	; 0x1c
    3700:	ab 8f       	std	Y+27, r26	; 0x1b
    3702:	e4 e6       	ldi	r30, 0x64	; 100
    3704:	f1 e0       	ldi	r31, 0x01	; 1
    3706:	fc ab       	std	Y+52, r31	; 0x34
    3708:	eb ab       	std	Y+51, r30	; 0x33
    370a:	ca 01       	movw	r24, r20
    370c:	8b 57       	subi	r24, 0x7B	; 123
    370e:	9e 4f       	sbci	r25, 0xFE	; 254
    3710:	9e 8f       	std	Y+30, r25	; 0x1e
    3712:	8d 8f       	std	Y+29, r24	; 0x1d
    3714:	4e 01       	movw	r8, r28
    3716:	9d e0       	ldi	r25, 0x0D	; 13
    3718:	89 0e       	add	r8, r25
    371a:	91 1c       	adc	r9, r1
    371c:	9a a2       	std	Y+34, r9	; 0x22
    371e:	89 a2       	std	Y+33, r8	; 0x21
    3720:	5f 01       	movw	r10, r30
    3722:	a3 ee       	ldi	r26, 0xE3	; 227
    3724:	b6 e0       	ldi	r27, 0x06	; 6
    3726:	bc a3       	std	Y+36, r27	; 0x24
    3728:	ab a3       	std	Y+35, r26	; 0x23
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    372a:	10 e0       	ldi	r17, 0x00	; 0
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    372c:	e2 2f       	mov	r30, r18
    372e:	f0 e0       	ldi	r31, 0x00	; 0
    3730:	f8 ab       	std	Y+48, r31	; 0x30
    3732:	ef a7       	std	Y+47, r30	; 0x2f
    3734:	9a 01       	movw	r18, r20
    3736:	2c 57       	subi	r18, 0x7C	; 124
    3738:	3e 4f       	sbci	r19, 0xFE	; 254
    373a:	3a a7       	std	Y+42, r19	; 0x2a
    373c:	29 a7       	std	Y+41, r18	; 0x29
    373e:	23 5f       	subi	r18, 0xF3	; 243
    3740:	3f 4f       	sbci	r19, 0xFF	; 255
    3742:	38 a7       	std	Y+40, r19	; 0x28
    3744:	2f a3       	std	Y+39, r18	; 0x27
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    3746:	29 a4       	ldd	r2, Y+41	; 0x29
    3748:	3a a4       	ldd	r3, Y+42	; 0x2a
    374a:	35 e2       	ldi	r19, 0x25	; 37
    374c:	23 0e       	add	r2, r19
    374e:	31 1c       	adc	r3, r1
        delta_mm = (target_steps[X_AXIS]-pl.position[X_AXIS] - target_steps[Y_AXIS]+pl.position[Y_AXIS])/settings.steps_per_mm[idx];
      } else {
        delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
      }
    #else
      target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
    3750:	a9 8d       	ldd	r26, Y+25	; 0x19
    3752:	ba 8d       	ldd	r27, Y+26	; 0x1a
    3754:	6d 91       	ld	r22, X+
    3756:	7d 91       	ld	r23, X+
    3758:	8d 91       	ld	r24, X+
    375a:	9d 91       	ld	r25, X+
    375c:	ba 8f       	std	Y+26, r27	; 0x1a
    375e:	a9 8f       	std	Y+25, r26	; 0x19
    3760:	eb a1       	ldd	r30, Y+35	; 0x23
    3762:	fc a1       	ldd	r31, Y+36	; 0x24
    3764:	41 90       	ld	r4, Z+
    3766:	51 90       	ld	r5, Z+
    3768:	61 90       	ld	r6, Z+
    376a:	71 90       	ld	r7, Z+
    376c:	fc a3       	std	Y+36, r31	; 0x24
    376e:	eb a3       	std	Y+35, r30	; 0x23
    3770:	a3 01       	movw	r20, r6
    3772:	92 01       	movw	r18, r4
    3774:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3778:	0e 94 da 3c 	call	0x79b4	; 0x79b4 <lround>
    377c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    377e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3780:	6d 93       	st	X+, r22
    3782:	7d 93       	st	X+, r23
    3784:	8d 93       	st	X+, r24
    3786:	9d 93       	st	X+, r25
    3788:	bc 8f       	std	Y+28, r27	; 0x1c
    378a:	ab 8f       	std	Y+27, r26	; 0x1b
      block->steps[idx] = labs(target_steps[idx]-pl.position[idx]);
    378c:	f5 01       	movw	r30, r10
    378e:	c1 90       	ld	r12, Z+
    3790:	d1 90       	ld	r13, Z+
    3792:	e1 90       	ld	r14, Z+
    3794:	f1 90       	ld	r15, Z+
    3796:	5f 01       	movw	r10, r30
    3798:	6c 19       	sub	r22, r12
    379a:	7d 09       	sbc	r23, r13
    379c:	8e 09       	sbc	r24, r14
    379e:	9f 09       	sbc	r25, r15
    37a0:	9b 01       	movw	r18, r22
    37a2:	ac 01       	movw	r20, r24
    37a4:	3a f4       	brpl	.+14     	; 0x37b4 <plan_buffer_line+0x144>
    37a6:	22 27       	eor	r18, r18
    37a8:	33 27       	eor	r19, r19
    37aa:	a9 01       	movw	r20, r18
    37ac:	26 1b       	sub	r18, r22
    37ae:	37 0b       	sbc	r19, r23
    37b0:	48 0b       	sbc	r20, r24
    37b2:	59 0b       	sbc	r21, r25
    37b4:	ad 8d       	ldd	r26, Y+29	; 0x1d
    37b6:	be 8d       	ldd	r27, Y+30	; 0x1e
    37b8:	2d 93       	st	X+, r18
    37ba:	3d 93       	st	X+, r19
    37bc:	4d 93       	st	X+, r20
    37be:	5d 93       	st	X+, r21
    37c0:	be 8f       	std	Y+30, r27	; 0x1e
    37c2:	ad 8f       	std	Y+29, r26	; 0x1d
      block->step_event_count = max(block->step_event_count, block->steps[idx]);
    37c4:	ef a1       	ldd	r30, Y+39	; 0x27
    37c6:	f8 a5       	ldd	r31, Y+40	; 0x28
    37c8:	c0 80       	ld	r12, Z
    37ca:	d1 80       	ldd	r13, Z+1	; 0x01
    37cc:	e2 80       	ldd	r14, Z+2	; 0x02
    37ce:	f3 80       	ldd	r15, Z+3	; 0x03
    37d0:	c2 16       	cp	r12, r18
    37d2:	d3 06       	cpc	r13, r19
    37d4:	e4 06       	cpc	r14, r20
    37d6:	f5 06       	cpc	r15, r21
    37d8:	10 f4       	brcc	.+4      	; 0x37de <plan_buffer_line+0x16e>
    37da:	69 01       	movw	r12, r18
    37dc:	7a 01       	movw	r14, r20
    37de:	af a1       	ldd	r26, Y+39	; 0x27
    37e0:	b8 a5       	ldd	r27, Y+40	; 0x28
    37e2:	cd 92       	st	X+, r12
    37e4:	dd 92       	st	X+, r13
    37e6:	ed 92       	st	X+, r14
    37e8:	fc 92       	st	X, r15
    37ea:	13 97       	sbiw	r26, 0x03	; 3
      delta_mm = (target_steps[idx] - pl.position[idx])/settings.steps_per_mm[idx];
    37ec:	0e 94 5f 3b 	call	0x76be	; 0x76be <__floatsisf>
    37f0:	a3 01       	movw	r20, r6
    37f2:	92 01       	movw	r18, r4
    37f4:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    37f8:	2b 01       	movw	r4, r22
    37fa:	3c 01       	movw	r6, r24
    #endif
    unit_vec[idx] = delta_mm; // Store unit vector numerator. Denominator computed later.
    37fc:	e9 a1       	ldd	r30, Y+33	; 0x21
    37fe:	fa a1       	ldd	r31, Y+34	; 0x22
    3800:	61 93       	st	Z+, r22
    3802:	71 93       	st	Z+, r23
    3804:	81 93       	st	Z+, r24
    3806:	91 93       	st	Z+, r25
    3808:	fa a3       	std	Y+34, r31	; 0x22
    380a:	e9 a3       	std	Y+33, r30	; 0x21
        
    // Set direction bits. Bit enabled always means direction is negative.
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    380c:	20 e0       	ldi	r18, 0x00	; 0
    380e:	30 e0       	ldi	r19, 0x00	; 0
    3810:	a9 01       	movw	r20, r18
    3812:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3816:	88 23       	and	r24, r24
    3818:	44 f4       	brge	.+16     	; 0x382a <plan_buffer_line+0x1ba>
    381a:	81 2f       	mov	r24, r17
    381c:	0e 94 b0 2b 	call	0x5760	; 0x5760 <get_direction_pin_mask>
    3820:	a9 a5       	ldd	r26, Y+41	; 0x29
    3822:	ba a5       	ldd	r27, Y+42	; 0x2a
    3824:	9c 91       	ld	r25, X
    3826:	89 2b       	or	r24, r25
    3828:	8c 93       	st	X, r24
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
    382a:	a3 01       	movw	r20, r6
    382c:	92 01       	movw	r18, r4
    382e:	c3 01       	movw	r24, r6
    3830:	b2 01       	movw	r22, r4
    3832:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3836:	f1 01       	movw	r30, r2
    3838:	20 81       	ld	r18, Z
    383a:	31 81       	ldd	r19, Z+1	; 0x01
    383c:	42 81       	ldd	r20, Z+2	; 0x02
    383e:	53 81       	ldd	r21, Z+3	; 0x03
    3840:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    3844:	d1 01       	movw	r26, r2
    3846:	6d 93       	st	X+, r22
    3848:	7d 93       	st	X+, r23
    384a:	8d 93       	st	X+, r24
    384c:	9c 93       	st	X, r25
    384e:	13 97       	sbiw	r26, 0x03	; 3
    target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
    block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) + (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
    block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-pl.position[X_AXIS]) - (target_steps[Y_AXIS]-pl.position[Y_AXIS]));
  #endif

  for (idx=0; idx<N_AXIS; idx++) {
    3850:	1f 5f       	subi	r17, 0xFF	; 255
    3852:	13 30       	cpi	r17, 0x03	; 3
    3854:	09 f0       	breq	.+2      	; 0x3858 <plan_buffer_line+0x1e8>
    3856:	7c cf       	rjmp	.-264    	; 0x3750 <plan_buffer_line+0xe0>
    if (delta_mm < 0 ) { block->direction_bits |= get_direction_pin_mask(idx); }
    
    // Incrementally compute total move distance by Euclidean norm. First add square of each term.
    block->millimeters += delta_mm*delta_mm;
  }
  block->millimeters = sqrt(block->millimeters); // Complete millimeters calculation with sqrt()
    3858:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    385c:	6b 01       	movw	r12, r22
    385e:	7c 01       	movw	r14, r24
    3860:	89 e2       	ldi	r24, 0x29	; 41
    3862:	2f a5       	ldd	r18, Y+47	; 0x2f
    3864:	38 a9       	ldd	r19, Y+48	; 0x30
    3866:	82 9f       	mul	r24, r18
    3868:	f0 01       	movw	r30, r0
    386a:	83 9f       	mul	r24, r19
    386c:	f0 0d       	add	r31, r0
    386e:	11 24       	eor	r1, r1
    3870:	ec 57       	subi	r30, 0x7C	; 124
    3872:	fe 4f       	sbci	r31, 0xFE	; 254
    3874:	c5 a2       	std	Z+37, r12	; 0x25
    3876:	d6 a2       	std	Z+38, r13	; 0x26
    3878:	e7 a2       	std	Z+39, r14	; 0x27
    387a:	f0 a6       	std	Z+40, r15	; 0x28
  
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
    387c:	85 85       	ldd	r24, Z+13	; 0x0d
    387e:	96 85       	ldd	r25, Z+14	; 0x0e
    3880:	a7 85       	ldd	r26, Z+15	; 0x0f
    3882:	b0 89       	ldd	r27, Z+16	; 0x10
    3884:	89 2b       	or	r24, r25
    3886:	8a 2b       	or	r24, r26
    3888:	8b 2b       	or	r24, r27
    388a:	09 f4       	brne	.+2      	; 0x388e <plan_buffer_line+0x21e>
    388c:	47 c2       	rjmp	.+1166   	; 0x3d1c <plan_buffer_line+0x6ac>
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    388e:	20 e0       	ldi	r18, 0x00	; 0
    3890:	30 e0       	ldi	r19, 0x00	; 0
    3892:	a9 01       	movw	r20, r18
    3894:	6b a5       	ldd	r22, Y+43	; 0x2b
    3896:	7c a5       	ldd	r23, Y+44	; 0x2c
    3898:	8d a5       	ldd	r24, Y+45	; 0x2d
    389a:	9e a5       	ldd	r25, Y+46	; 0x2e
    389c:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    38a0:	88 23       	and	r24, r24
    38a2:	0c f1       	brlt	.+66     	; 0x38e6 <plan_buffer_line+0x276>
  else if (invert_feed_rate) { feed_rate *= block->millimeters; }
    38a4:	00 23       	and	r16, r16
    38a6:	61 f0       	breq	.+24     	; 0x38c0 <plan_buffer_line+0x250>
    38a8:	a7 01       	movw	r20, r14
    38aa:	96 01       	movw	r18, r12
    38ac:	6b a5       	ldd	r22, Y+43	; 0x2b
    38ae:	7c a5       	ldd	r23, Y+44	; 0x2c
    38b0:	8d a5       	ldd	r24, Y+45	; 0x2d
    38b2:	9e a5       	ldd	r25, Y+46	; 0x2e
    38b4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    38b8:	6b a7       	std	Y+43, r22	; 0x2b
    38ba:	7c a7       	std	Y+44, r23	; 0x2c
    38bc:	8d a7       	std	Y+45, r24	; 0x2d
    38be:	9e a7       	std	Y+46, r25	; 0x2e
  if (feed_rate < MINIMUM_FEED_RATE) { feed_rate = MINIMUM_FEED_RATE; } // Prevents step generation round-off condition.
    38c0:	20 e0       	ldi	r18, 0x00	; 0
    38c2:	30 e0       	ldi	r19, 0x00	; 0
    38c4:	40 e8       	ldi	r20, 0x80	; 128
    38c6:	5f e3       	ldi	r21, 0x3F	; 63
    38c8:	6b a5       	ldd	r22, Y+43	; 0x2b
    38ca:	7c a5       	ldd	r23, Y+44	; 0x2c
    38cc:	8d a5       	ldd	r24, Y+45	; 0x2d
    38ce:	9e a5       	ldd	r25, Y+46	; 0x2e
    38d0:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    38d4:	88 23       	and	r24, r24
    38d6:	7c f4       	brge	.+30     	; 0x38f6 <plan_buffer_line+0x286>
    38d8:	1b a6       	std	Y+43, r1	; 0x2b
    38da:	1c a6       	std	Y+44, r1	; 0x2c
    38dc:	30 e8       	ldi	r19, 0x80	; 128
    38de:	3d a7       	std	Y+45, r19	; 0x2d
    38e0:	4f e3       	ldi	r20, 0x3F	; 63
    38e2:	4e a7       	std	Y+46, r20	; 0x2e
    38e4:	08 c0       	rjmp	.+16     	; 0x38f6 <plan_buffer_line+0x286>
  // Bail if this is a zero-length block. Highly unlikely to occur.
  if (block->step_event_count == 0) { return; } 
  
  // Adjust feed_rate value to mm/min depending on type of rate input (normal, inverse time, or rapids)
  // TODO: Need to distinguish a rapids vs feed move for overrides. Some flag of some sort.
  if (feed_rate < 0) { feed_rate = SOME_LARGE_VALUE; } // Scaled down to absolute max/rapids rate later
    38e6:	59 e9       	ldi	r21, 0x99	; 153
    38e8:	5b a7       	std	Y+43, r21	; 0x2b
    38ea:	86 e7       	ldi	r24, 0x76	; 118
    38ec:	8c a7       	std	Y+44, r24	; 0x2c
    38ee:	96 e9       	ldi	r25, 0x96	; 150
    38f0:	9d a7       	std	Y+45, r25	; 0x2d
    38f2:	ae e7       	ldi	r26, 0x7E	; 126
    38f4:	ae a7       	std	Y+46, r26	; 0x2e
  // Calculate the unit vector of the line move and the block maximum feed rate and acceleration scaled 
  // down such that no individual axes maximum values are exceeded with respect to the line direction. 
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
    38f6:	a7 01       	movw	r20, r14
    38f8:	96 01       	movw	r18, r12
    38fa:	60 e0       	ldi	r22, 0x00	; 0
    38fc:	70 e0       	ldi	r23, 0x00	; 0
    38fe:	80 e8       	ldi	r24, 0x80	; 128
    3900:	9f e3       	ldi	r25, 0x3F	; 63
    3902:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    3906:	6d ab       	std	Y+53, r22	; 0x35
    3908:	7e ab       	std	Y+54, r23	; 0x36
    390a:	8f ab       	std	Y+55, r24	; 0x37
    390c:	98 af       	std	Y+56, r25	; 0x38
    390e:	2e 01       	movw	r4, r28
    3910:	b9 e1       	ldi	r27, 0x19	; 25
    3912:	4b 0e       	add	r4, r27
    3914:	51 1c       	adc	r5, r1
  float junction_cos_theta = 0;
    3916:	1b a2       	std	Y+35, r1	; 0x23
    3918:	1c a2       	std	Y+36, r1	; 0x24
    391a:	1d a2       	std	Y+37, r1	; 0x25
    391c:	1e a2       	std	Y+38, r1	; 0x26
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    391e:	29 e2       	ldi	r18, 0x29	; 41
    3920:	ef a5       	ldd	r30, Y+47	; 0x2f
    3922:	f8 a9       	ldd	r31, Y+48	; 0x30
    3924:	2e 9f       	mul	r18, r30
    3926:	c0 01       	movw	r24, r0
    3928:	2f 9f       	mul	r18, r31
    392a:	90 0d       	add	r25, r0
    392c:	11 24       	eor	r1, r1
    392e:	9c 01       	movw	r18, r24
    3930:	2b 55       	subi	r18, 0x5B	; 91
    3932:	3e 4f       	sbci	r19, 0xFE	; 254
    3934:	19 01       	movw	r2, r18
    3936:	69 a8       	ldd	r6, Y+49	; 0x31
    3938:	7a a8       	ldd	r7, Y+50	; 0x32
    393a:	0b a9       	ldd	r16, Y+51	; 0x33
    393c:	1c a9       	ldd	r17, Y+52	; 0x34
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    393e:	d4 01       	movw	r26, r8
    3940:	cd 90       	ld	r12, X+
    3942:	dd 90       	ld	r13, X+
    3944:	ed 90       	ld	r14, X+
    3946:	fc 90       	ld	r15, X
    3948:	20 e0       	ldi	r18, 0x00	; 0
    394a:	30 e0       	ldi	r19, 0x00	; 0
    394c:	a9 01       	movw	r20, r18
    394e:	c7 01       	movw	r24, r14
    3950:	b6 01       	movw	r22, r12
    3952:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3956:	88 23       	and	r24, r24
    3958:	09 f4       	brne	.+2      	; 0x395c <plan_buffer_line+0x2ec>
    395a:	8d c0       	rjmp	.+282    	; 0x3a76 <plan_buffer_line+0x406>
      unit_vec[idx] *= inverse_millimeters;  // Complete unit vector calculation
    395c:	a7 01       	movw	r20, r14
    395e:	96 01       	movw	r18, r12
    3960:	6d a9       	ldd	r22, Y+53	; 0x35
    3962:	7e a9       	ldd	r23, Y+54	; 0x36
    3964:	8f a9       	ldd	r24, Y+55	; 0x37
    3966:	98 ad       	ldd	r25, Y+56	; 0x38
    3968:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    396c:	6b 01       	movw	r12, r22
    396e:	7c 01       	movw	r14, r24
    3970:	f4 01       	movw	r30, r8
    3972:	60 83       	st	Z, r22
    3974:	71 83       	std	Z+1, r23	; 0x01
    3976:	82 83       	std	Z+2, r24	; 0x02
    3978:	93 83       	std	Z+3, r25	; 0x03
      inverse_unit_vec_value = fabs(1.0/unit_vec[idx]); // Inverse to remove multiple float divides.
    397a:	9b 01       	movw	r18, r22
    397c:	ac 01       	movw	r20, r24
    397e:	60 e0       	ldi	r22, 0x00	; 0
    3980:	70 e0       	ldi	r23, 0x00	; 0
    3982:	80 e8       	ldi	r24, 0x80	; 128
    3984:	9f e3       	ldi	r25, 0x3F	; 63
    3986:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    398a:	9b 01       	movw	r18, r22
    398c:	ac 01       	movw	r20, r24
    398e:	5f 77       	andi	r21, 0x7F	; 127
    3990:	2d 8f       	std	Y+29, r18	; 0x1d
    3992:	3e 8f       	std	Y+30, r19	; 0x1e
    3994:	4f 8f       	std	Y+31, r20	; 0x1f
    3996:	58 a3       	std	Y+32, r21	; 0x20
    3998:	7a a2       	std	Y+34, r7	; 0x22
    399a:	69 a2       	std	Y+33, r6	; 0x21

      // Check and limit feed rate against max individual axis velocities and accelerations
      feed_rate = min(feed_rate,settings.max_rate[idx]*inverse_unit_vec_value);
    399c:	d3 01       	movw	r26, r6
    399e:	1c 96       	adiw	r26, 0x0c	; 12
    39a0:	2d 91       	ld	r18, X+
    39a2:	3d 91       	ld	r19, X+
    39a4:	4d 91       	ld	r20, X+
    39a6:	5c 91       	ld	r21, X
    39a8:	1f 97       	sbiw	r26, 0x0f	; 15
    39aa:	6d 8d       	ldd	r22, Y+29	; 0x1d
    39ac:	7e 8d       	ldd	r23, Y+30	; 0x1e
    39ae:	8f 8d       	ldd	r24, Y+31	; 0x1f
    39b0:	98 a1       	ldd	r25, Y+32	; 0x20
    39b2:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    39b6:	69 8f       	std	Y+25, r22	; 0x19
    39b8:	7b 8f       	std	Y+27, r23	; 0x1b
    39ba:	b8 2e       	mov	r11, r24
    39bc:	a9 2e       	mov	r10, r25
    39be:	2b a5       	ldd	r18, Y+43	; 0x2b
    39c0:	3c a5       	ldd	r19, Y+44	; 0x2c
    39c2:	4d a5       	ldd	r20, Y+45	; 0x2d
    39c4:	5e a5       	ldd	r21, Y+46	; 0x2e
    39c6:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    39ca:	18 16       	cp	r1, r24
    39cc:	34 f0       	brlt	.+12     	; 0x39da <plan_buffer_line+0x36a>
    39ce:	b9 8d       	ldd	r27, Y+25	; 0x19
    39d0:	bb a7       	std	Y+43, r27	; 0x2b
    39d2:	eb 8d       	ldd	r30, Y+27	; 0x1b
    39d4:	ec a7       	std	Y+44, r30	; 0x2c
    39d6:	bd a6       	std	Y+45, r11	; 0x2d
    39d8:	ae a6       	std	Y+46, r10	; 0x2e
      block->acceleration = min(block->acceleration,settings.acceleration[idx]*inverse_unit_vec_value);
    39da:	d1 01       	movw	r26, r2
    39dc:	bc 91       	ld	r27, X
    39de:	b9 8f       	std	Y+25, r27	; 0x19
    39e0:	f1 01       	movw	r30, r2
    39e2:	f1 81       	ldd	r31, Z+1	; 0x01
    39e4:	fb 8f       	std	Y+27, r31	; 0x1b
    39e6:	d1 01       	movw	r26, r2
    39e8:	12 96       	adiw	r26, 0x02	; 2
    39ea:	ac 90       	ld	r10, X
    39ec:	12 97       	sbiw	r26, 0x02	; 2
    39ee:	13 96       	adiw	r26, 0x03	; 3
    39f0:	bc 90       	ld	r11, X
    39f2:	e9 a1       	ldd	r30, Y+33	; 0x21
    39f4:	fa a1       	ldd	r31, Y+34	; 0x22
    39f6:	20 8d       	ldd	r18, Z+24	; 0x18
    39f8:	31 8d       	ldd	r19, Z+25	; 0x19
    39fa:	42 8d       	ldd	r20, Z+26	; 0x1a
    39fc:	53 8d       	ldd	r21, Z+27	; 0x1b
    39fe:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3a00:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3a02:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3a04:	98 a1       	ldd	r25, Y+32	; 0x20
    3a06:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3a0a:	6d 8f       	std	Y+29, r22	; 0x1d
    3a0c:	79 a3       	std	Y+33, r23	; 0x21
    3a0e:	8f a3       	std	Y+39, r24	; 0x27
    3a10:	99 a7       	std	Y+41, r25	; 0x29
    3a12:	26 2f       	mov	r18, r22
    3a14:	37 2f       	mov	r19, r23
    3a16:	48 2f       	mov	r20, r24
    3a18:	59 2f       	mov	r21, r25
    3a1a:	69 8d       	ldd	r22, Y+25	; 0x19
    3a1c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3a1e:	8a 2d       	mov	r24, r10
    3a20:	9b 2d       	mov	r25, r11
    3a22:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3a26:	88 23       	and	r24, r24
    3a28:	34 f0       	brlt	.+12     	; 0x3a36 <plan_buffer_line+0x3c6>
    3a2a:	fd 8d       	ldd	r31, Y+29	; 0x1d
    3a2c:	f9 8f       	std	Y+25, r31	; 0x19
    3a2e:	29 a1       	ldd	r18, Y+33	; 0x21
    3a30:	2b 8f       	std	Y+27, r18	; 0x1b
    3a32:	af a0       	ldd	r10, Y+39	; 0x27
    3a34:	b9 a4       	ldd	r11, Y+41	; 0x29
    3a36:	89 8d       	ldd	r24, Y+25	; 0x19
    3a38:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3a3a:	aa 2d       	mov	r26, r10
    3a3c:	bb 2d       	mov	r27, r11
    3a3e:	f1 01       	movw	r30, r2
    3a40:	80 83       	st	Z, r24
    3a42:	91 83       	std	Z+1, r25	; 0x01
    3a44:	a2 83       	std	Z+2, r26	; 0x02
    3a46:	b3 83       	std	Z+3, r27	; 0x03

      // Incrementally compute cosine of angle between previous and current path. Cos(theta) of the junction
      // between the current move and the previous move is simply the dot product of the two unit vectors, 
      // where prev_unit_vec is negative. Used later to compute maximum junction speed.
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    3a48:	d8 01       	movw	r26, r16
    3a4a:	1c 96       	adiw	r26, 0x0c	; 12
    3a4c:	2d 91       	ld	r18, X+
    3a4e:	3d 91       	ld	r19, X+
    3a50:	4d 91       	ld	r20, X+
    3a52:	5c 91       	ld	r21, X
    3a54:	1f 97       	sbiw	r26, 0x0f	; 15
    3a56:	c7 01       	movw	r24, r14
    3a58:	b6 01       	movw	r22, r12
    3a5a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3a5e:	9b 01       	movw	r18, r22
    3a60:	ac 01       	movw	r20, r24
    3a62:	6b a1       	ldd	r22, Y+35	; 0x23
    3a64:	7c a1       	ldd	r23, Y+36	; 0x24
    3a66:	8d a1       	ldd	r24, Y+37	; 0x25
    3a68:	9e a1       	ldd	r25, Y+38	; 0x26
    3a6a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    3a6e:	6b a3       	std	Y+35, r22	; 0x23
    3a70:	7c a3       	std	Y+36, r23	; 0x24
    3a72:	8d a3       	std	Y+37, r24	; 0x25
    3a74:	9e a3       	std	Y+38, r25	; 0x26
    3a76:	b4 e0       	ldi	r27, 0x04	; 4
    3a78:	8b 0e       	add	r8, r27
    3a7a:	91 1c       	adc	r9, r1
    3a7c:	0c 5f       	subi	r16, 0xFC	; 252
    3a7e:	1f 4f       	sbci	r17, 0xFF	; 255
    3a80:	e4 e0       	ldi	r30, 0x04	; 4
    3a82:	6e 0e       	add	r6, r30
    3a84:	71 1c       	adc	r7, r1
  // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
  // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
  float inverse_unit_vec_value;
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple float divides	
  float junction_cos_theta = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3a86:	84 14       	cp	r8, r4
    3a88:	95 04       	cpc	r9, r5
    3a8a:	09 f0       	breq	.+2      	; 0x3a8e <plan_buffer_line+0x41e>
    3a8c:	58 cf       	rjmp	.-336    	; 0x393e <plan_buffer_line+0x2ce>
      junction_cos_theta -= pl.previous_unit_vec[idx] * unit_vec[idx];
    }
  }
  
  // TODO: Need to check this method handling zero junction speeds when starting from rest.
  if (block_buffer_head == block_buffer_tail) {
    3a8e:	90 91 82 01 	lds	r25, 0x0182	; 0x800182 <block_buffer_head>
    3a92:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    3a96:	98 13       	cpse	r25, r24
    3a98:	13 c0       	rjmp	.+38     	; 0x3ac0 <plan_buffer_line+0x450>
  
    // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will correct this later.
    block->entry_speed_sqr = 0.0;
    3a9a:	89 e2       	ldi	r24, 0x29	; 41
    3a9c:	2f a5       	ldd	r18, Y+47	; 0x2f
    3a9e:	38 a9       	ldd	r19, Y+48	; 0x30
    3aa0:	82 9f       	mul	r24, r18
    3aa2:	f0 01       	movw	r30, r0
    3aa4:	83 9f       	mul	r24, r19
    3aa6:	f0 0d       	add	r31, r0
    3aa8:	11 24       	eor	r1, r1
    3aaa:	ec 57       	subi	r30, 0x7C	; 124
    3aac:	fe 4f       	sbci	r31, 0xFE	; 254
    3aae:	11 8a       	std	Z+17, r1	; 0x11
    3ab0:	12 8a       	std	Z+18, r1	; 0x12
    3ab2:	13 8a       	std	Z+19, r1	; 0x13
    3ab4:	14 8a       	std	Z+20, r1	; 0x14
    block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
    3ab6:	11 8e       	std	Z+25, r1	; 0x19
    3ab8:	12 8e       	std	Z+26, r1	; 0x1a
    3aba:	13 8e       	std	Z+27, r1	; 0x1b
    3abc:	14 8e       	std	Z+28, r1	; 0x1c
    3abe:	90 c0       	rjmp	.+288    	; 0x3be0 <plan_buffer_line+0x570>
       changed dynamically during operation nor can the line move geometry. This must be kept in
       memory in the event of a feedrate override changing the nominal speeds of blocks, which can 
       change the overall maximum entry speed conditions of all blocks.
    */
    // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of cos(theta).
    if (junction_cos_theta > 0.999999) {
    3ac0:	2f ee       	ldi	r18, 0xEF	; 239
    3ac2:	3f ef       	ldi	r19, 0xFF	; 255
    3ac4:	4f e7       	ldi	r20, 0x7F	; 127
    3ac6:	5f e3       	ldi	r21, 0x3F	; 63
    3ac8:	6b a1       	ldd	r22, Y+35	; 0x23
    3aca:	7c a1       	ldd	r23, Y+36	; 0x24
    3acc:	8d a1       	ldd	r24, Y+37	; 0x25
    3ace:	9e a1       	ldd	r25, Y+38	; 0x26
    3ad0:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    3ad4:	18 16       	cp	r1, r24
    3ad6:	7c f4       	brge	.+30     	; 0x3af6 <plan_buffer_line+0x486>
      //  For a 0 degree acute junction, just set minimum junction speed. 
      block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
    3ad8:	89 e2       	ldi	r24, 0x29	; 41
    3ada:	4f a5       	ldd	r20, Y+47	; 0x2f
    3adc:	58 a9       	ldd	r21, Y+48	; 0x30
    3ade:	84 9f       	mul	r24, r20
    3ae0:	f0 01       	movw	r30, r0
    3ae2:	85 9f       	mul	r24, r21
    3ae4:	f0 0d       	add	r31, r0
    3ae6:	11 24       	eor	r1, r1
    3ae8:	ec 57       	subi	r30, 0x7C	; 124
    3aea:	fe 4f       	sbci	r31, 0xFE	; 254
    3aec:	11 8e       	std	Z+25, r1	; 0x19
    3aee:	12 8e       	std	Z+26, r1	; 0x1a
    3af0:	13 8e       	std	Z+27, r1	; 0x1b
    3af2:	14 8e       	std	Z+28, r1	; 0x1c
    3af4:	75 c0       	rjmp	.+234    	; 0x3be0 <plan_buffer_line+0x570>
    } else {
      junction_cos_theta = max(junction_cos_theta,-0.999999); // Check for numerical round-off to avoid divide by zero.
    3af6:	2f ee       	ldi	r18, 0xEF	; 239
    3af8:	3f ef       	ldi	r19, 0xFF	; 255
    3afa:	4f e7       	ldi	r20, 0x7F	; 127
    3afc:	5f eb       	ldi	r21, 0xBF	; 191
    3afe:	6b a1       	ldd	r22, Y+35	; 0x23
    3b00:	7c a1       	ldd	r23, Y+36	; 0x24
    3b02:	8d a1       	ldd	r24, Y+37	; 0x25
    3b04:	9e a1       	ldd	r25, Y+38	; 0x26
    3b06:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    3b0a:	18 16       	cp	r1, r24
    3b0c:	44 f0       	brlt	.+16     	; 0x3b1e <plan_buffer_line+0x4ae>
    3b0e:	8f ee       	ldi	r24, 0xEF	; 239
    3b10:	9f ef       	ldi	r25, 0xFF	; 255
    3b12:	af e7       	ldi	r26, 0x7F	; 127
    3b14:	bf eb       	ldi	r27, 0xBF	; 191
    3b16:	8b a3       	std	Y+35, r24	; 0x23
    3b18:	9c a3       	std	Y+36, r25	; 0x24
    3b1a:	ad a3       	std	Y+37, r26	; 0x25
    3b1c:	be a3       	std	Y+38, r27	; 0x26
      float sin_theta_d2 = sqrt(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Always positive.
    3b1e:	2b a1       	ldd	r18, Y+35	; 0x23
    3b20:	3c a1       	ldd	r19, Y+36	; 0x24
    3b22:	4d a1       	ldd	r20, Y+37	; 0x25
    3b24:	5e a1       	ldd	r21, Y+38	; 0x26
    3b26:	60 e0       	ldi	r22, 0x00	; 0
    3b28:	70 e0       	ldi	r23, 0x00	; 0
    3b2a:	80 e8       	ldi	r24, 0x80	; 128
    3b2c:	9f e3       	ldi	r25, 0x3F	; 63
    3b2e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    3b32:	20 e0       	ldi	r18, 0x00	; 0
    3b34:	30 e0       	ldi	r19, 0x00	; 0
    3b36:	40 e0       	ldi	r20, 0x00	; 0
    3b38:	5f e3       	ldi	r21, 0x3F	; 63
    3b3a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3b3e:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    3b42:	6b 01       	movw	r12, r22
    3b44:	7c 01       	movw	r14, r24

      // TODO: Technically, the acceleration used in calculation needs to be limited by the minimum of the
      // two junctions. However, this shouldn't be a significant problem except in extreme circumstances.
      block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
    3b46:	89 e2       	ldi	r24, 0x29	; 41
    3b48:	af a5       	ldd	r26, Y+47	; 0x2f
    3b4a:	b8 a9       	ldd	r27, Y+48	; 0x30
    3b4c:	8a 9f       	mul	r24, r26
    3b4e:	f0 01       	movw	r30, r0
    3b50:	8b 9f       	mul	r24, r27
    3b52:	f0 0d       	add	r31, r0
    3b54:	11 24       	eor	r1, r1
    3b56:	ec 57       	subi	r30, 0x7C	; 124
    3b58:	fe 4f       	sbci	r31, 0xFE	; 254
    3b5a:	20 91 18 07 	lds	r18, 0x0718	; 0x800718 <settings+0x35>
    3b5e:	30 91 19 07 	lds	r19, 0x0719	; 0x800719 <settings+0x36>
    3b62:	40 91 1a 07 	lds	r20, 0x071A	; 0x80071a <settings+0x37>
    3b66:	50 91 1b 07 	lds	r21, 0x071B	; 0x80071b <settings+0x38>
    3b6a:	61 a1       	ldd	r22, Z+33	; 0x21
    3b6c:	72 a1       	ldd	r23, Z+34	; 0x22
    3b6e:	83 a1       	ldd	r24, Z+35	; 0x23
    3b70:	94 a1       	ldd	r25, Z+36	; 0x24
    3b72:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3b76:	a7 01       	movw	r20, r14
    3b78:	96 01       	movw	r18, r12
    3b7a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3b7e:	4b 01       	movw	r8, r22
    3b80:	5c 01       	movw	r10, r24
    3b82:	a7 01       	movw	r20, r14
    3b84:	96 01       	movw	r18, r12
    3b86:	60 e0       	ldi	r22, 0x00	; 0
    3b88:	70 e0       	ldi	r23, 0x00	; 0
    3b8a:	80 e8       	ldi	r24, 0x80	; 128
    3b8c:	9f e3       	ldi	r25, 0x3F	; 63
    3b8e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    3b92:	9b 01       	movw	r18, r22
    3b94:	ac 01       	movw	r20, r24
    3b96:	c5 01       	movw	r24, r10
    3b98:	b4 01       	movw	r22, r8
    3b9a:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    3b9e:	e6 2e       	mov	r14, r22
    3ba0:	f7 2e       	mov	r15, r23
    3ba2:	08 2f       	mov	r16, r24
    3ba4:	19 2f       	mov	r17, r25
    3ba6:	20 e0       	ldi	r18, 0x00	; 0
    3ba8:	30 e0       	ldi	r19, 0x00	; 0
    3baa:	a9 01       	movw	r20, r18
    3bac:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3bb0:	88 23       	and	r24, r24
    3bb2:	24 f4       	brge	.+8      	; 0x3bbc <plan_buffer_line+0x54c>
    3bb4:	e1 2c       	mov	r14, r1
    3bb6:	f1 2c       	mov	r15, r1
    3bb8:	00 e0       	ldi	r16, 0x00	; 0
    3bba:	10 e0       	ldi	r17, 0x00	; 0
    3bbc:	89 e2       	ldi	r24, 0x29	; 41
    3bbe:	2f a5       	ldd	r18, Y+47	; 0x2f
    3bc0:	38 a9       	ldd	r19, Y+48	; 0x30
    3bc2:	82 9f       	mul	r24, r18
    3bc4:	f0 01       	movw	r30, r0
    3bc6:	83 9f       	mul	r24, r19
    3bc8:	f0 0d       	add	r31, r0
    3bca:	11 24       	eor	r1, r1
    3bcc:	ec 57       	subi	r30, 0x7C	; 124
    3bce:	fe 4f       	sbci	r31, 0xFE	; 254
    3bd0:	4e 2d       	mov	r20, r14
    3bd2:	5f 2d       	mov	r21, r15
    3bd4:	60 2f       	mov	r22, r16
    3bd6:	71 2f       	mov	r23, r17
    3bd8:	41 8f       	std	Z+25, r20	; 0x19
    3bda:	52 8f       	std	Z+26, r21	; 0x1a
    3bdc:	63 8f       	std	Z+27, r22	; 0x1b
    3bde:	74 8f       	std	Z+28, r23	; 0x1c

    }
  }

  // Store block nominal speed
  block->nominal_speed_sqr = feed_rate*feed_rate; // (mm/min). Always > 0
    3be0:	2b a5       	ldd	r18, Y+43	; 0x2b
    3be2:	3c a5       	ldd	r19, Y+44	; 0x2c
    3be4:	4d a5       	ldd	r20, Y+45	; 0x2d
    3be6:	5e a5       	ldd	r21, Y+46	; 0x2e
    3be8:	6b a5       	ldd	r22, Y+43	; 0x2b
    3bea:	7c a5       	ldd	r23, Y+44	; 0x2c
    3bec:	8d a5       	ldd	r24, Y+45	; 0x2d
    3bee:	9e a5       	ldd	r25, Y+46	; 0x2e
    3bf0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3bf4:	f6 2e       	mov	r15, r22
    3bf6:	07 2f       	mov	r16, r23
    3bf8:	18 2f       	mov	r17, r24
    3bfa:	e9 2e       	mov	r14, r25
    3bfc:	89 e2       	ldi	r24, 0x29	; 41
    3bfe:	4f a5       	ldd	r20, Y+47	; 0x2f
    3c00:	58 a9       	ldd	r21, Y+48	; 0x30
    3c02:	84 9f       	mul	r24, r20
    3c04:	f0 01       	movw	r30, r0
    3c06:	85 9f       	mul	r24, r21
    3c08:	f0 0d       	add	r31, r0
    3c0a:	11 24       	eor	r1, r1
    3c0c:	ec 57       	subi	r30, 0x7C	; 124
    3c0e:	fe 4f       	sbci	r31, 0xFE	; 254
    3c10:	8f 2d       	mov	r24, r15
    3c12:	90 2f       	mov	r25, r16
    3c14:	a1 2f       	mov	r26, r17
    3c16:	be 2d       	mov	r27, r14
    3c18:	85 8f       	std	Z+29, r24	; 0x1d
    3c1a:	96 8f       	std	Z+30, r25	; 0x1e
    3c1c:	a7 8f       	std	Z+31, r26	; 0x1f
    3c1e:	b0 a3       	std	Z+32, r27	; 0x20
  
  // Compute the junction maximum entry based on the minimum of the junction speed and neighboring nominal speeds.
  block->max_entry_speed_sqr = min(block->max_junction_speed_sqr, 
    3c20:	d1 8c       	ldd	r13, Z+25	; 0x19
    3c22:	c2 8c       	ldd	r12, Z+26	; 0x1a
    3c24:	b3 8c       	ldd	r11, Z+27	; 0x1b
    3c26:	a4 8c       	ldd	r10, Z+28	; 0x1c
    3c28:	90 90 7c 01 	lds	r9, 0x017C	; 0x80017c <__data_end+0x18>
    3c2c:	80 90 7d 01 	lds	r8, 0x017D	; 0x80017d <__data_end+0x19>
    3c30:	70 90 7e 01 	lds	r7, 0x017E	; 0x80017e <__data_end+0x1a>
    3c34:	60 90 7f 01 	lds	r6, 0x017F	; 0x80017f <__data_end+0x1b>
    3c38:	29 2d       	mov	r18, r9
    3c3a:	38 2d       	mov	r19, r8
    3c3c:	47 2d       	mov	r20, r7
    3c3e:	56 2d       	mov	r21, r6
    3c40:	6f 2d       	mov	r22, r15
    3c42:	70 2f       	mov	r23, r16
    3c44:	81 2f       	mov	r24, r17
    3c46:	9e 2d       	mov	r25, r14
    3c48:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3c4c:	88 23       	and	r24, r24
    3c4e:	2c f0       	brlt	.+10     	; 0x3c5a <plan_buffer_line+0x5ea>
    3c50:	b9 2d       	mov	r27, r9
    3c52:	a8 2d       	mov	r26, r8
    3c54:	f7 2d       	mov	r31, r7
    3c56:	e6 2d       	mov	r30, r6
    3c58:	04 c0       	rjmp	.+8      	; 0x3c62 <plan_buffer_line+0x5f2>
    3c5a:	bf 2d       	mov	r27, r15
    3c5c:	a0 2f       	mov	r26, r16
    3c5e:	f1 2f       	mov	r31, r17
    3c60:	ee 2d       	mov	r30, r14
    3c62:	2d 2d       	mov	r18, r13
    3c64:	3c 2d       	mov	r19, r12
    3c66:	4b 2d       	mov	r20, r11
    3c68:	5a 2d       	mov	r21, r10
    3c6a:	6b 2f       	mov	r22, r27
    3c6c:	7a 2f       	mov	r23, r26
    3c6e:	8f 2f       	mov	r24, r31
    3c70:	9e 2f       	mov	r25, r30
    3c72:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    3c76:	18 16       	cp	r1, r24
    3c78:	ac f0       	brlt	.+42     	; 0x3ca4 <plan_buffer_line+0x634>
    3c7a:	29 2d       	mov	r18, r9
    3c7c:	38 2d       	mov	r19, r8
    3c7e:	47 2d       	mov	r20, r7
    3c80:	56 2d       	mov	r21, r6
    3c82:	6f 2d       	mov	r22, r15
    3c84:	70 2f       	mov	r23, r16
    3c86:	81 2f       	mov	r24, r17
    3c88:	9e 2d       	mov	r25, r14
    3c8a:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3c8e:	88 23       	and	r24, r24
    3c90:	2c f0       	brlt	.+10     	; 0x3c9c <plan_buffer_line+0x62c>
    3c92:	d9 2c       	mov	r13, r9
    3c94:	c8 2c       	mov	r12, r8
    3c96:	b7 2c       	mov	r11, r7
    3c98:	a6 2c       	mov	r10, r6
    3c9a:	04 c0       	rjmp	.+8      	; 0x3ca4 <plan_buffer_line+0x634>
    3c9c:	df 2c       	mov	r13, r15
    3c9e:	c0 2e       	mov	r12, r16
    3ca0:	b1 2e       	mov	r11, r17
    3ca2:	ae 2c       	mov	r10, r14
    3ca4:	89 e2       	ldi	r24, 0x29	; 41
    3ca6:	af a5       	ldd	r26, Y+47	; 0x2f
    3ca8:	b8 a9       	ldd	r27, Y+48	; 0x30
    3caa:	8a 9f       	mul	r24, r26
    3cac:	f0 01       	movw	r30, r0
    3cae:	8b 9f       	mul	r24, r27
    3cb0:	f0 0d       	add	r31, r0
    3cb2:	11 24       	eor	r1, r1
    3cb4:	ec 57       	subi	r30, 0x7C	; 124
    3cb6:	fe 4f       	sbci	r31, 0xFE	; 254
    3cb8:	8d 2d       	mov	r24, r13
    3cba:	9c 2d       	mov	r25, r12
    3cbc:	ab 2d       	mov	r26, r11
    3cbe:	ba 2d       	mov	r27, r10
    3cc0:	85 8b       	std	Z+21, r24	; 0x15
    3cc2:	96 8b       	std	Z+22, r25	; 0x16
    3cc4:	a7 8b       	std	Z+23, r26	; 0x17
    3cc6:	b0 8f       	std	Z+24, r27	; 0x18
                                   min(block->nominal_speed_sqr,pl.previous_nominal_speed_sqr));
  
  // Update previous path unit_vector and nominal speed (squared)
  memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[]
    3cc8:	8c e0       	ldi	r24, 0x0C	; 12
    3cca:	fe 01       	movw	r30, r28
    3ccc:	3d 96       	adiw	r30, 0x0d	; 13
    3cce:	a0 e7       	ldi	r26, 0x70	; 112
    3cd0:	b1 e0       	ldi	r27, 0x01	; 1
    3cd2:	01 90       	ld	r0, Z+
    3cd4:	0d 92       	st	X+, r0
    3cd6:	8a 95       	dec	r24
    3cd8:	e1 f7       	brne	.-8      	; 0x3cd2 <plan_buffer_line+0x662>
  pl.previous_nominal_speed_sqr = block->nominal_speed_sqr;
    3cda:	8f 2d       	mov	r24, r15
    3cdc:	90 2f       	mov	r25, r16
    3cde:	a1 2f       	mov	r26, r17
    3ce0:	be 2d       	mov	r27, r14
    3ce2:	80 93 7c 01 	sts	0x017C, r24	; 0x80017c <__data_end+0x18>
    3ce6:	90 93 7d 01 	sts	0x017D, r25	; 0x80017d <__data_end+0x19>
    3cea:	a0 93 7e 01 	sts	0x017E, r26	; 0x80017e <__data_end+0x1a>
    3cee:	b0 93 7f 01 	sts	0x017F, r27	; 0x80017f <__data_end+0x1b>
    
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
    3cf2:	8c e0       	ldi	r24, 0x0C	; 12
    3cf4:	fe 01       	movw	r30, r28
    3cf6:	31 96       	adiw	r30, 0x01	; 1
    3cf8:	a4 e6       	ldi	r26, 0x64	; 100
    3cfa:	b1 e0       	ldi	r27, 0x01	; 1
    3cfc:	01 90       	ld	r0, Z+
    3cfe:	0d 92       	st	X+, r0
    3d00:	8a 95       	dec	r24
    3d02:	e1 f7       	brne	.-8      	; 0x3cfc <plan_buffer_line+0x68c>

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
    3d04:	80 91 81 01 	lds	r24, 0x0181	; 0x800181 <next_buffer_head>
    3d08:	80 93 82 01 	sts	0x0182, r24	; 0x800182 <block_buffer_head>


// Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
uint8_t plan_next_block_index(uint8_t block_index) 
{
  block_index++;
    3d0c:	8f 5f       	subi	r24, 0xFF	; 255
  if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
    3d0e:	82 31       	cpi	r24, 0x12	; 18
    3d10:	09 f4       	brne	.+2      	; 0x3d14 <plan_buffer_line+0x6a4>
    3d12:	80 e0       	ldi	r24, 0x00	; 0
  // Update planner position
  memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]

  // New block is all set. Update buffer head and next buffer head indices.
  block_buffer_head = next_buffer_head;  
  next_buffer_head = plan_next_block_index(block_buffer_head);
    3d14:	80 93 81 01 	sts	0x0181, r24	; 0x800181 <next_buffer_head>
  
  // Finish up by recalculating the plan with the new block.
  planner_recalculate();
    3d18:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <planner_recalculate>
}
    3d1c:	e8 96       	adiw	r28, 0x38	; 56
    3d1e:	0f b6       	in	r0, 0x3f	; 63
    3d20:	f8 94       	cli
    3d22:	de bf       	out	0x3e, r29	; 62
    3d24:	0f be       	out	0x3f, r0	; 63
    3d26:	cd bf       	out	0x3d, r28	; 61
    3d28:	df 91       	pop	r29
    3d2a:	cf 91       	pop	r28
    3d2c:	1f 91       	pop	r17
    3d2e:	0f 91       	pop	r16
    3d30:	ff 90       	pop	r15
    3d32:	ef 90       	pop	r14
    3d34:	df 90       	pop	r13
    3d36:	cf 90       	pop	r12
    3d38:	bf 90       	pop	r11
    3d3a:	af 90       	pop	r10
    3d3c:	9f 90       	pop	r9
    3d3e:	8f 90       	pop	r8
    3d40:	7f 90       	pop	r7
    3d42:	6f 90       	pop	r6
    3d44:	5f 90       	pop	r5
    3d46:	4f 90       	pop	r4
    3d48:	3f 90       	pop	r3
    3d4a:	2f 90       	pop	r2
    3d4c:	08 95       	ret

00003d4e <plan_sync_position>:


// Reset the planner position vectors. Called by the system abort/initialization routine.
void plan_sync_position()
{
    3d4e:	a8 e0       	ldi	r26, 0x08	; 8
    3d50:	b6 e0       	ldi	r27, 0x06	; 6
    3d52:	e4 e6       	ldi	r30, 0x64	; 100
    3d54:	f1 e0       	ldi	r31, 0x01	; 1
    3d56:	80 e7       	ldi	r24, 0x70	; 112
    3d58:	91 e0       	ldi	r25, 0x01	; 1
        pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys.position);
      } else {
        pl.position[idx] = sys.position[idx];
      }
    #else
      pl.position[idx] = sys.position[idx];
    3d5a:	4d 91       	ld	r20, X+
    3d5c:	5d 91       	ld	r21, X+
    3d5e:	6d 91       	ld	r22, X+
    3d60:	7d 91       	ld	r23, X+
    3d62:	41 93       	st	Z+, r20
    3d64:	51 93       	st	Z+, r21
    3d66:	61 93       	st	Z+, r22
    3d68:	71 93       	st	Z+, r23
void plan_sync_position()
{
  // TODO: For motor configurations not in the same coordinate frame as the machine position,
  // this function needs to be updated to accomodate the difference. 
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    3d6a:	e8 17       	cp	r30, r24
    3d6c:	f9 07       	cpc	r31, r25
    3d6e:	a9 f7       	brne	.-22     	; 0x3d5a <plan_sync_position+0xc>
      }
    #else
      pl.position[idx] = sys.position[idx];
    #endif
  }
}
    3d70:	08 95       	ret

00003d72 <plan_get_block_buffer_count>:


// Returns the number of active blocks are in the planner buffer.
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
    3d72:	80 91 82 01 	lds	r24, 0x0182	; 0x800182 <block_buffer_head>
    3d76:	90 91 83 01 	lds	r25, 0x0183	; 0x800183 <block_buffer_tail>
    3d7a:	89 17       	cp	r24, r25
    3d7c:	10 f0       	brcs	.+4      	; 0x3d82 <plan_get_block_buffer_count+0x10>
    3d7e:	89 1b       	sub	r24, r25
    3d80:	08 95       	ret
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
    3d82:	8e 5e       	subi	r24, 0xEE	; 238
    3d84:	89 1b       	sub	r24, r25
}
    3d86:	08 95       	ret

00003d88 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    3d88:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    3d8c:	80 91 83 01 	lds	r24, 0x0183	; 0x800183 <block_buffer_tail>
    3d90:	80 93 80 01 	sts	0x0180, r24	; 0x800180 <block_buffer_planned>
  planner_recalculate();  
    3d94:	0e 94 7a 19 	call	0x32f4	; 0x32f4 <planner_recalculate>
    3d98:	08 95       	ret

00003d9a <printString>:
    serial_write('-');
    print_uint32_base10(-n);
  } else {
    print_uint32_base10(n);
  }
}
    3d9a:	cf 93       	push	r28
    3d9c:	df 93       	push	r29
    3d9e:	ec 01       	movw	r28, r24
    3da0:	88 81       	ld	r24, Y
    3da2:	88 23       	and	r24, r24
    3da4:	31 f0       	breq	.+12     	; 0x3db2 <printString+0x18>
    3da6:	21 96       	adiw	r28, 0x01	; 1
    3da8:	0e 94 1d 28 	call	0x503a	; 0x503a <serial_write>
    3dac:	89 91       	ld	r24, Y+
    3dae:	81 11       	cpse	r24, r1
    3db0:	fb cf       	rjmp	.-10     	; 0x3da8 <printString+0xe>
    3db2:	df 91       	pop	r29
    3db4:	cf 91       	pop	r28
    3db6:	08 95       	ret

00003db8 <printPgmString>:
    3db8:	cf 93       	push	r28
    3dba:	df 93       	push	r29
    3dbc:	ec 01       	movw	r28, r24
    3dbe:	21 96       	adiw	r28, 0x01	; 1
    3dc0:	fc 01       	movw	r30, r24
    3dc2:	84 91       	lpm	r24, Z
    3dc4:	88 23       	and	r24, r24
    3dc6:	39 f0       	breq	.+14     	; 0x3dd6 <printPgmString+0x1e>
    3dc8:	0e 94 1d 28 	call	0x503a	; 0x503a <serial_write>
    3dcc:	fe 01       	movw	r30, r28
    3dce:	84 91       	lpm	r24, Z
    3dd0:	21 96       	adiw	r28, 0x01	; 1
    3dd2:	81 11       	cpse	r24, r1
    3dd4:	f9 cf       	rjmp	.-14     	; 0x3dc8 <printPgmString+0x10>
    3dd6:	df 91       	pop	r29
    3dd8:	cf 91       	pop	r28
    3dda:	08 95       	ret

00003ddc <print_unsigned_int8>:
    3ddc:	cf 92       	push	r12
    3dde:	df 92       	push	r13
    3de0:	ef 92       	push	r14
    3de2:	ff 92       	push	r15
    3de4:	1f 93       	push	r17
    3de6:	cf 93       	push	r28
    3de8:	df 93       	push	r29
    3dea:	cd b7       	in	r28, 0x3d	; 61
    3dec:	de b7       	in	r29, 0x3e	; 62
    3dee:	56 2f       	mov	r21, r22
    3df0:	14 2f       	mov	r17, r20
    3df2:	cd b6       	in	r12, 0x3d	; 61
    3df4:	de b6       	in	r13, 0x3e	; 62
    3df6:	2d b7       	in	r18, 0x3d	; 61
    3df8:	3e b7       	in	r19, 0x3e	; 62
    3dfa:	24 1b       	sub	r18, r20
    3dfc:	31 09       	sbc	r19, r1
    3dfe:	0f b6       	in	r0, 0x3f	; 63
    3e00:	f8 94       	cli
    3e02:	3e bf       	out	0x3e, r19	; 62
    3e04:	0f be       	out	0x3f, r0	; 63
    3e06:	2d bf       	out	0x3d, r18	; 61
    3e08:	6d b7       	in	r22, 0x3d	; 61
    3e0a:	7e b7       	in	r23, 0x3e	; 62
    3e0c:	6f 5f       	subi	r22, 0xFF	; 255
    3e0e:	7f 4f       	sbci	r23, 0xFF	; 255
    3e10:	7b 01       	movw	r14, r22
    3e12:	44 23       	and	r20, r20
    3e14:	d1 f0       	breq	.+52     	; 0x3e4a <print_unsigned_int8+0x6e>
    3e16:	fb 01       	movw	r30, r22
    3e18:	9f ef       	ldi	r25, 0xFF	; 255
    3e1a:	94 0f       	add	r25, r20
    3e1c:	29 2f       	mov	r18, r25
    3e1e:	30 e0       	ldi	r19, 0x00	; 0
    3e20:	2f 5f       	subi	r18, 0xFF	; 255
    3e22:	3f 4f       	sbci	r19, 0xFF	; 255
    3e24:	26 0f       	add	r18, r22
    3e26:	37 1f       	adc	r19, r23
    3e28:	65 2f       	mov	r22, r21
    3e2a:	0e 94 16 3e 	call	0x7c2c	; 0x7c2c <__udivmodqi4>
    3e2e:	91 93       	st	Z+, r25
    3e30:	2e 17       	cp	r18, r30
    3e32:	3f 07       	cpc	r19, r31
    3e34:	c9 f7       	brne	.-14     	; 0x3e28 <print_unsigned_int8+0x4c>
    3e36:	f7 01       	movw	r30, r14
    3e38:	e1 0f       	add	r30, r17
    3e3a:	f1 1d       	adc	r31, r1
    3e3c:	31 97       	sbiw	r30, 0x01	; 1
    3e3e:	80 81       	ld	r24, Z
    3e40:	80 5d       	subi	r24, 0xD0	; 208
    3e42:	0e 94 1d 28 	call	0x503a	; 0x503a <serial_write>
    3e46:	11 50       	subi	r17, 0x01	; 1
    3e48:	b1 f7       	brne	.-20     	; 0x3e36 <print_unsigned_int8+0x5a>
    3e4a:	0f b6       	in	r0, 0x3f	; 63
    3e4c:	f8 94       	cli
    3e4e:	de be       	out	0x3e, r13	; 62
    3e50:	0f be       	out	0x3f, r0	; 63
    3e52:	cd be       	out	0x3d, r12	; 61
    3e54:	df 91       	pop	r29
    3e56:	cf 91       	pop	r28
    3e58:	1f 91       	pop	r17
    3e5a:	ff 90       	pop	r15
    3e5c:	ef 90       	pop	r14
    3e5e:	df 90       	pop	r13
    3e60:	cf 90       	pop	r12
    3e62:	08 95       	ret

00003e64 <print_uint8_base2>:
    3e64:	48 e0       	ldi	r20, 0x08	; 8
    3e66:	62 e0       	ldi	r22, 0x02	; 2
    3e68:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <print_unsigned_int8>
    3e6c:	08 95       	ret

00003e6e <print_uint8_base10>:
    3e6e:	8a 30       	cpi	r24, 0x0A	; 10
    3e70:	20 f0       	brcs	.+8      	; 0x3e7a <print_uint8_base10+0xc>
    3e72:	84 36       	cpi	r24, 0x64	; 100
    3e74:	20 f0       	brcs	.+8      	; 0x3e7e <print_uint8_base10+0x10>
    3e76:	43 e0       	ldi	r20, 0x03	; 3
    3e78:	03 c0       	rjmp	.+6      	; 0x3e80 <print_uint8_base10+0x12>
    3e7a:	41 e0       	ldi	r20, 0x01	; 1
    3e7c:	01 c0       	rjmp	.+2      	; 0x3e80 <print_uint8_base10+0x12>
    3e7e:	42 e0       	ldi	r20, 0x02	; 2
    3e80:	6a e0       	ldi	r22, 0x0A	; 10
    3e82:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <print_unsigned_int8>
    3e86:	08 95       	ret

00003e88 <printFloat>:
// more digits than a float. Number of decimal places, which are tracked by a counter,
// may be set by the user. The integer is then efficiently converted to a string.
// NOTE: AVR '%' and '/' integer operations are very efficient. Bitshifting speed-up 
// techniques are actually just slightly slower. Found this out the hard way.
void printFloat(float n, uint8_t decimal_places)
{
    3e88:	8f 92       	push	r8
    3e8a:	9f 92       	push	r9
    3e8c:	af 92       	push	r10
    3e8e:	bf 92       	push	r11
    3e90:	cf 92       	push	r12
    3e92:	df 92       	push	r13
    3e94:	ef 92       	push	r14
    3e96:	ff 92       	push	r15
    3e98:	0f 93       	push	r16
    3e9a:	1f 93       	push	r17
    3e9c:	cf 93       	push	r28
    3e9e:	df 93       	push	r29
    3ea0:	cd b7       	in	r28, 0x3d	; 61
    3ea2:	de b7       	in	r29, 0x3e	; 62
    3ea4:	2a 97       	sbiw	r28, 0x0a	; 10
    3ea6:	0f b6       	in	r0, 0x3f	; 63
    3ea8:	f8 94       	cli
    3eaa:	de bf       	out	0x3e, r29	; 62
    3eac:	0f be       	out	0x3f, r0	; 63
    3eae:	cd bf       	out	0x3d, r28	; 61
    3eb0:	6b 01       	movw	r12, r22
    3eb2:	7c 01       	movw	r14, r24
    3eb4:	04 2f       	mov	r16, r20
  if (n < 0) {
    3eb6:	20 e0       	ldi	r18, 0x00	; 0
    3eb8:	30 e0       	ldi	r19, 0x00	; 0
    3eba:	a9 01       	movw	r20, r18
    3ebc:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    3ec0:	88 23       	and	r24, r24
    3ec2:	3c f4       	brge	.+14     	; 0x3ed2 <printFloat+0x4a>
    serial_write('-');
    3ec4:	8d e2       	ldi	r24, 0x2D	; 45
    3ec6:	0e 94 1d 28 	call	0x503a	; 0x503a <serial_write>
    n = -n;
    3eca:	f7 fa       	bst	r15, 7
    3ecc:	f0 94       	com	r15
    3ece:	f7 f8       	bld	r15, 7
    3ed0:	f0 94       	com	r15
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3ed2:	02 30       	cpi	r16, 0x02	; 2
    3ed4:	88 f0       	brcs	.+34     	; 0x3ef8 <printFloat+0x70>
    3ed6:	10 2f       	mov	r17, r16
    n *= 100;
    3ed8:	20 e0       	ldi	r18, 0x00	; 0
    3eda:	30 e0       	ldi	r19, 0x00	; 0
    3edc:	48 ec       	ldi	r20, 0xC8	; 200
    3ede:	52 e4       	ldi	r21, 0x42	; 66
    3ee0:	c7 01       	movw	r24, r14
    3ee2:	b6 01       	movw	r22, r12
    3ee4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3ee8:	6b 01       	movw	r12, r22
    3eea:	7c 01       	movw	r14, r24
    decimals -= 2;
    3eec:	12 50       	subi	r17, 0x02	; 2
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    3eee:	12 30       	cpi	r17, 0x02	; 2
    3ef0:	98 f7       	brcc	.-26     	; 0x3ed8 <printFloat+0x50>
    3ef2:	80 2f       	mov	r24, r16
    3ef4:	81 70       	andi	r24, 0x01	; 1
    3ef6:	01 c0       	rjmp	.+2      	; 0x3efa <printFloat+0x72>
  if (n < 0) {
    serial_write('-');
    n = -n;
  }

  uint8_t decimals = decimal_places;
    3ef8:	80 2f       	mov	r24, r16
  while (decimals >= 2) { // Quickly convert values expected to be E0 to E-4.
    n *= 100;
    decimals -= 2;
  }
  if (decimals) { n *= 10; }
    3efa:	88 23       	and	r24, r24
    3efc:	51 f0       	breq	.+20     	; 0x3f12 <printFloat+0x8a>
    3efe:	20 e0       	ldi	r18, 0x00	; 0
    3f00:	30 e0       	ldi	r19, 0x00	; 0
    3f02:	40 e2       	ldi	r20, 0x20	; 32
    3f04:	51 e4       	ldi	r21, 0x41	; 65
    3f06:	c7 01       	movw	r24, r14
    3f08:	b6 01       	movw	r22, r12
    3f0a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    3f0e:	6b 01       	movw	r12, r22
    3f10:	7c 01       	movw	r14, r24
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
    3f12:	20 e0       	ldi	r18, 0x00	; 0
    3f14:	30 e0       	ldi	r19, 0x00	; 0
    3f16:	40 e0       	ldi	r20, 0x00	; 0
    3f18:	5f e3       	ldi	r21, 0x3F	; 63
    3f1a:	c7 01       	movw	r24, r14
    3f1c:	b6 01       	movw	r22, r12
    3f1e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    3f22:	0e 94 27 3b 	call	0x764e	; 0x764e <__fixsfsi>
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
    3f26:	2e e2       	ldi	r18, 0x2E	; 46
    3f28:	fe 01       	movw	r30, r28
    3f2a:	e0 0f       	add	r30, r16
    3f2c:	f1 1d       	adc	r31, r1
    3f2e:	21 83       	std	Z+1, r18	; 0x01
  while(a > 0) {
    3f30:	61 15       	cp	r22, r1
    3f32:	71 05       	cpc	r23, r1
    3f34:	81 05       	cpc	r24, r1
    3f36:	91 05       	cpc	r25, r1
    3f38:	41 f1       	breq	.+80     	; 0x3f8a <printFloat+0x102>
    3f3a:	10 e0       	ldi	r17, 0x00	; 0
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    3f3c:	0f 2e       	mov	r0, r31
    3f3e:	fa e0       	ldi	r31, 0x0A	; 10
    3f40:	8f 2e       	mov	r8, r31
    3f42:	91 2c       	mov	r9, r1
    3f44:	a1 2c       	mov	r10, r1
    3f46:	b1 2c       	mov	r11, r1
    3f48:	f0 2d       	mov	r31, r0
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    3f4a:	01 13       	cpse	r16, r17
    3f4c:	03 c0       	rjmp	.+6      	; 0x3f54 <printFloat+0xcc>
    3f4e:	21 e0       	ldi	r18, 0x01	; 1
    3f50:	21 0f       	add	r18, r17
    3f52:	01 c0       	rjmp	.+2      	; 0x3f56 <printFloat+0xce>
    3f54:	21 2f       	mov	r18, r17
    buf[i++] = (a % 10) + '0'; // Get digit
    3f56:	11 e0       	ldi	r17, 0x01	; 1
    3f58:	12 0f       	add	r17, r18
    3f5a:	ee 24       	eor	r14, r14
    3f5c:	e3 94       	inc	r14
    3f5e:	f1 2c       	mov	r15, r1
    3f60:	ec 0e       	add	r14, r28
    3f62:	fd 1e       	adc	r15, r29
    3f64:	e2 0e       	add	r14, r18
    3f66:	f1 1c       	adc	r15, r1
    3f68:	a5 01       	movw	r20, r10
    3f6a:	94 01       	movw	r18, r8
    3f6c:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__udivmodsi4>
    3f70:	60 5d       	subi	r22, 0xD0	; 208
    3f72:	f7 01       	movw	r30, r14
    3f74:	60 83       	st	Z, r22
    a /= 10;
    3f76:	62 2f       	mov	r22, r18
    3f78:	73 2f       	mov	r23, r19
    3f7a:	84 2f       	mov	r24, r20
    3f7c:	95 2f       	mov	r25, r21
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
  uint32_t a = (long)n;  
  buf[decimal_places] = '.'; // Place decimal point, even if decimal places are zero.
  while(a > 0) {
    3f7e:	61 15       	cp	r22, r1
    3f80:	71 05       	cpc	r23, r1
    3f82:	81 05       	cpc	r24, r1
    3f84:	91 05       	cpc	r25, r1
    3f86:	09 f7       	brne	.-62     	; 0x3f4a <printFloat+0xc2>
    3f88:	01 c0       	rjmp	.+2      	; 0x3f8c <printFloat+0x104>
  if (decimals) { n *= 10; }
  n += 0.5; // Add rounding factor. Ensures carryover through entire value.
    
  // Generate digits backwards and store in string.
  unsigned char buf[10]; 
  uint8_t i = 0;
    3f8a:	10 e0       	ldi	r17, 0x00	; 0
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3f8c:	10 17       	cp	r17, r16
    3f8e:	60 f4       	brcc	.+24     	; 0x3fa8 <printFloat+0x120>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
    3f90:	80 e3       	ldi	r24, 0x30	; 48
    3f92:	e1 e0       	ldi	r30, 0x01	; 1
    3f94:	f0 e0       	ldi	r31, 0x00	; 0
    3f96:	ec 0f       	add	r30, r28
    3f98:	fd 1f       	adc	r31, r29
    3f9a:	e1 0f       	add	r30, r17
    3f9c:	f1 1d       	adc	r31, r1
    3f9e:	80 83       	st	Z, r24
    3fa0:	1f 5f       	subi	r17, 0xFF	; 255
  while(a > 0) {
    if (i == decimal_places) { i++; } // Skip decimal point location
    buf[i++] = (a % 10) + '0'; // Get digit
    a /= 10;
  }
  while (i < decimal_places) { 
    3fa2:	01 13       	cpse	r16, r17
    3fa4:	f6 cf       	rjmp	.-20     	; 0x3f92 <printFloat+0x10a>
    3fa6:	02 c0       	rjmp	.+4      	; 0x3fac <printFloat+0x124>
     buf[i++] = '0'; // Fill in zeros to decimal point for (n < 1)
  }
  if (i == decimal_places) { // Fill in leading zero, if needed.
    3fa8:	01 13       	cpse	r16, r17
    3faa:	08 c0       	rjmp	.+16     	; 0x3fbc <printFloat+0x134>
    i++;
    buf[i++] = '0'; 
    3fac:	12 e0       	ldi	r17, 0x02	; 2
    3fae:	10 0f       	add	r17, r16
    3fb0:	0f 5f       	subi	r16, 0xFF	; 255
    3fb2:	fe 01       	movw	r30, r28
    3fb4:	e0 0f       	add	r30, r16
    3fb6:	f1 1d       	adc	r31, r1
    3fb8:	80 e3       	ldi	r24, 0x30	; 48
    3fba:	81 83       	std	Z+1, r24	; 0x01
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3fbc:	11 23       	and	r17, r17
    3fbe:	41 f0       	breq	.+16     	; 0x3fd0 <printFloat+0x148>
    serial_write(buf[i-1]);
    3fc0:	fe 01       	movw	r30, r28
    3fc2:	e1 0f       	add	r30, r17
    3fc4:	f1 1d       	adc	r31, r1
    3fc6:	80 81       	ld	r24, Z
    3fc8:	0e 94 1d 28 	call	0x503a	; 0x503a <serial_write>
    i++;
    buf[i++] = '0'; 
  }   
  
  // Print the generated string.
  for (; i > 0; i--)
    3fcc:	11 50       	subi	r17, 0x01	; 1
    3fce:	c1 f7       	brne	.-16     	; 0x3fc0 <printFloat+0x138>
    serial_write(buf[i-1]);
}
    3fd0:	2a 96       	adiw	r28, 0x0a	; 10
    3fd2:	0f b6       	in	r0, 0x3f	; 63
    3fd4:	f8 94       	cli
    3fd6:	de bf       	out	0x3e, r29	; 62
    3fd8:	0f be       	out	0x3f, r0	; 63
    3fda:	cd bf       	out	0x3d, r28	; 61
    3fdc:	df 91       	pop	r29
    3fde:	cf 91       	pop	r28
    3fe0:	1f 91       	pop	r17
    3fe2:	0f 91       	pop	r16
    3fe4:	ff 90       	pop	r15
    3fe6:	ef 90       	pop	r14
    3fe8:	df 90       	pop	r13
    3fea:	cf 90       	pop	r12
    3fec:	bf 90       	pop	r11
    3fee:	af 90       	pop	r10
    3ff0:	9f 90       	pop	r9
    3ff2:	8f 90       	pop	r8
    3ff4:	08 95       	ret

00003ff6 <printFloat_CoordValue>:
// in the config.h.
//  - CoordValue: Handles all position or coordinate values in inches or mm reporting.
//  - RateValue: Handles feed rate and current velocity in inches or mm reporting.
//  - SettingValue: Handles all floating point settings values (always in mm.)
void printFloat_CoordValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) { 
    3ff6:	20 91 20 07 	lds	r18, 0x0720	; 0x800720 <settings+0x3d>
    3ffa:	20 ff       	sbrs	r18, 0
    3ffc:	0a c0       	rjmp	.+20     	; 0x4012 <printFloat_CoordValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_COORDVALUE_INCH);
    3ffe:	2b e8       	ldi	r18, 0x8B	; 139
    4000:	32 e4       	ldi	r19, 0x42	; 66
    4002:	41 e2       	ldi	r20, 0x21	; 33
    4004:	5d e3       	ldi	r21, 0x3D	; 61
    4006:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    400a:	44 e0       	ldi	r20, 0x04	; 4
    400c:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <printFloat>
    4010:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_COORDVALUE_MM);
    4012:	43 e0       	ldi	r20, 0x03	; 3
    4014:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <printFloat>
    4018:	08 95       	ret

0000401a <printFloat_RateValue>:
  }
}

void printFloat_RateValue(float n) { 
  if (bit_istrue(settings.flags,BITFLAG_REPORT_INCHES)) {
    401a:	20 91 20 07 	lds	r18, 0x0720	; 0x800720 <settings+0x3d>
    401e:	20 ff       	sbrs	r18, 0
    4020:	0a c0       	rjmp	.+20     	; 0x4036 <printFloat_RateValue+0x1c>
    printFloat(n*INCH_PER_MM,N_DECIMAL_RATEVALUE_INCH);
    4022:	2b e8       	ldi	r18, 0x8B	; 139
    4024:	32 e4       	ldi	r19, 0x42	; 66
    4026:	41 e2       	ldi	r20, 0x21	; 33
    4028:	5d e3       	ldi	r21, 0x3D	; 61
    402a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    402e:	41 e0       	ldi	r20, 0x01	; 1
    4030:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <printFloat>
    4034:	08 95       	ret
  } else {
    printFloat(n,N_DECIMAL_RATEVALUE_MM);
    4036:	40 e0       	ldi	r20, 0x00	; 0
    4038:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <printFloat>
    403c:	08 95       	ret

0000403e <printFloat_SettingValue>:
  }
}

void printFloat_SettingValue(float n) { printFloat(n,N_DECIMAL_SETTINGVALUE); }
    403e:	43 e0       	ldi	r20, 0x03	; 3
    4040:	0e 94 44 1f 	call	0x3e88	; 0x3e88 <printFloat>
    4044:	08 95       	ret

00004046 <probe_init>:


// Probe pin initialization routine.
void probe_init() 
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    4046:	3d 98       	cbi	0x07, 5	; 7
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    4048:	45 9a       	sbi	0x08, 5	; 8
    404a:	08 95       	ret

0000404c <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to 
// appropriately set the pin logic according to setting for normal-high/normal-low operation 
// and the probing cycle modes for toward-workpiece/away-from-workpiece. 
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    404c:	10 92 22 06 	sts	0x0622, r1	; 0x800622 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    4050:	90 91 20 07 	lds	r25, 0x0720	; 0x800720 <settings+0x3d>
    4054:	99 23       	and	r25, r25
    4056:	1c f0       	brlt	.+6      	; 0x405e <probe_configure_invert_mask+0x12>
    4058:	90 e2       	ldi	r25, 0x20	; 32
    405a:	90 93 22 06 	sts	0x0622, r25	; 0x800622 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    405e:	88 23       	and	r24, r24
    4060:	31 f0       	breq	.+12     	; 0x406e <probe_configure_invert_mask+0x22>
    4062:	90 91 22 06 	lds	r25, 0x0622	; 0x800622 <probe_invert_mask>
    4066:	80 e2       	ldi	r24, 0x20	; 32
    4068:	89 27       	eor	r24, r25
    406a:	80 93 22 06 	sts	0x0622, r24	; 0x800622 <probe_invert_mask>
    406e:	08 95       	ret

00004070 <probe_get_state>:
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    4070:	86 b1       	in	r24, 0x06	; 6
    4072:	80 72       	andi	r24, 0x20	; 32
    4074:	90 91 22 06 	lds	r25, 0x0622	; 0x800622 <probe_invert_mask>
    4078:	89 27       	eor	r24, r25
    407a:	08 95       	ret

0000407c <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (sys_probe_state == PROBE_ACTIVE) {
    407c:	80 91 8a 05 	lds	r24, 0x058A	; 0x80058a <sys_probe_state>
    4080:	81 30       	cpi	r24, 0x01	; 1
    4082:	a1 f4       	brne	.+40     	; 0x40ac <probe_state_monitor+0x30>
    if (probe_get_state()) {
    4084:	0e 94 38 20 	call	0x4070	; 0x4070 <probe_get_state>
    4088:	88 23       	and	r24, r24
    408a:	81 f0       	breq	.+32     	; 0x40ac <probe_state_monitor+0x30>
      sys_probe_state = PROBE_OFF;
    408c:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys_probe_state>
      memcpy(sys.probe_position, sys.position, sizeof(sys.position));
    4090:	8c e0       	ldi	r24, 0x0C	; 12
    4092:	e8 e0       	ldi	r30, 0x08	; 8
    4094:	f6 e0       	ldi	r31, 0x06	; 6
    4096:	a4 e1       	ldi	r26, 0x14	; 20
    4098:	b6 e0       	ldi	r27, 0x06	; 6
    409a:	01 90       	ld	r0, Z+
    409c:	0d 92       	st	X+, r0
    409e:	8a 95       	dec	r24
    40a0:	e1 f7       	brne	.-8      	; 0x409a <probe_state_monitor+0x1e>
      bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    40a2:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    40a6:	80 64       	ori	r24, 0x40	; 64
    40a8:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    40ac:	08 95       	ret

000040ae <protocol_execute_realtime>:
// execute certain tasks without having two or more instances of the same task, such as the planner
// recalculating the buffer upon a feedhold or override.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    40ae:	af 92       	push	r10
    40b0:	bf 92       	push	r11
    40b2:	cf 92       	push	r12
    40b4:	df 92       	push	r13
    40b6:	ef 92       	push	r14
    40b8:	ff 92       	push	r15
    40ba:	0f 93       	push	r16
    40bc:	1f 93       	push	r17
    40be:	cf 93       	push	r28
    40c0:	df 93       	push	r29
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
  if (rt_exec) { // Enter only if any bit flag is true
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40c2:	c4 e0       	ldi	r28, 0x04	; 4
    40c4:	d6 e0       	ldi	r29, 0x06	; 6
    40c6:	01 e0       	ldi	r16, 0x01	; 1
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
            sys.state = STATE_CYCLE;
    40c8:	68 94       	set
    40ca:	aa 24       	eor	r10, r10
    40cc:	a3 f8       	bld	r10, 3
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    40ce:	0f 2e       	mov	r0, r31
    40d0:	fc e8       	ldi	r31, 0x8C	; 140
    40d2:	ef 2e       	mov	r14, r31
    40d4:	f5 e0       	ldi	r31, 0x05	; 5
    40d6:	ff 2e       	mov	r15, r31
    40d8:	f0 2d       	mov	r31, r0
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
          sys.suspend |= SUSPEND_ENERGIZE;
          sys.state = STATE_SAFETY_DOOR;
    40da:	68 94       	set
    40dc:	cc 24       	eor	r12, r12
    40de:	c5 f8       	bld	r12, 5
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    40e0:	68 94       	set
    40e2:	dd 24       	eor	r13, r13
    40e4:	d4 f8       	bld	r13, 4
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    40e6:	68 94       	set
    40e8:	bb 24       	eor	r11, r11
    40ea:	b6 f8       	bld	r11, 6
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.

  do { // If system is suspended, suspend loop restarts here.
    
  // Check and execute alarms. 
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    40ec:	10 91 8b 05 	lds	r17, 0x058B	; 0x80058b <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    40f0:	11 23       	and	r17, r17
    40f2:	b1 f1       	breq	.+108    	; 0x4160 <protocol_execute_realtime+0xb2>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    40f4:	09 83       	std	Y+1, r16	; 0x01
    if (rt_exec & EXEC_ALARM_HARD_LIMIT) {
    40f6:	11 ff       	sbrs	r17, 1
    40f8:	04 c0       	rjmp	.+8      	; 0x4102 <protocol_execute_realtime+0x54>
      report_alarm_message(ALARM_HARD_LIMIT_ERROR); 
    40fa:	80 2f       	mov	r24, r16
    40fc:	0e 94 bc 22 	call	0x4578	; 0x4578 <report_alarm_message>
    4100:	17 c0       	rjmp	.+46     	; 0x4130 <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_SOFT_LIMIT) {
    4102:	12 ff       	sbrs	r17, 2
    4104:	04 c0       	rjmp	.+8      	; 0x410e <protocol_execute_realtime+0x60>
      report_alarm_message(ALARM_SOFT_LIMIT_ERROR);
    4106:	82 e0       	ldi	r24, 0x02	; 2
    4108:	0e 94 bc 22 	call	0x4578	; 0x4578 <report_alarm_message>
    410c:	11 c0       	rjmp	.+34     	; 0x4130 <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_ABORT_CYCLE) {      
    410e:	13 ff       	sbrs	r17, 3
    4110:	04 c0       	rjmp	.+8      	; 0x411a <protocol_execute_realtime+0x6c>
      report_alarm_message(ALARM_ABORT_CYCLE);
    4112:	83 e0       	ldi	r24, 0x03	; 3
    4114:	0e 94 bc 22 	call	0x4578	; 0x4578 <report_alarm_message>
    4118:	0b c0       	rjmp	.+22     	; 0x4130 <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_PROBE_FAIL) {
    411a:	14 ff       	sbrs	r17, 4
    411c:	04 c0       	rjmp	.+8      	; 0x4126 <protocol_execute_realtime+0x78>
      report_alarm_message(ALARM_PROBE_FAIL);
    411e:	84 e0       	ldi	r24, 0x04	; 4
    4120:	0e 94 bc 22 	call	0x4578	; 0x4578 <report_alarm_message>
    4124:	05 c0       	rjmp	.+10     	; 0x4130 <protocol_execute_realtime+0x82>
    } else if (rt_exec & EXEC_ALARM_HOMING_FAIL) {
    4126:	15 ff       	sbrs	r17, 5
    4128:	03 c0       	rjmp	.+6      	; 0x4130 <protocol_execute_realtime+0x82>
      report_alarm_message(ALARM_HOMING_FAIL);
    412a:	85 e0       	ldi	r24, 0x05	; 5
    412c:	0e 94 bc 22 	call	0x4578	; 0x4578 <report_alarm_message>
    }
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if (rt_exec & EXEC_CRITICAL_EVENT) {
    4130:	10 ff       	sbrs	r17, 0
    4132:	0f c0       	rjmp	.+30     	; 0x4152 <protocol_execute_realtime+0xa4>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    4134:	80 2f       	mov	r24, r16
    4136:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
      bit_false_atomic(sys_rt_exec_state,EXEC_RESET); // Disable any existing reset
    413a:	9f b7       	in	r25, 0x3f	; 63
    413c:	f8 94       	cli
    413e:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    4142:	8f 7e       	andi	r24, 0xEF	; 239
    4144:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    4148:	9f bf       	out	0x3f, r25	; 63
        // TODO: Allow status reports during a critical alarm. Still need to think about implications of this.
//         if (sys_rt_exec_state & EXEC_STATUS_REPORT) { 
//           report_realtime_status();
//           bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT); 
//         }
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    414a:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    414e:	84 ff       	sbrs	r24, 4
    4150:	fc cf       	rjmp	.-8      	; 0x414a <protocol_execute_realtime+0x9c>
    }
    bit_false_atomic(sys_rt_exec_alarm,0xFF); // Clear all alarm flags
    4152:	8f b7       	in	r24, 0x3f	; 63
    4154:	f8 94       	cli
    4156:	90 91 8b 05 	lds	r25, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    415a:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys_rt_exec_alarm>
    415e:	8f bf       	out	0x3f, r24	; 63
  }
  
  // Check amd execute realtime commands
  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    4160:	10 91 89 05 	lds	r17, 0x0589	; 0x800589 <sys_rt_exec_state>
  if (rt_exec) { // Enter only if any bit flag is true
    4164:	11 23       	and	r17, r17
    4166:	09 f4       	brne	.+2      	; 0x416a <protocol_execute_realtime+0xbc>
    4168:	a5 c0       	rjmp	.+330    	; 0x42b4 <protocol_execute_realtime+0x206>
  
    // Execute system abort. 
    if (rt_exec & EXEC_RESET) {
    416a:	14 ff       	sbrs	r17, 4
    416c:	04 c0       	rjmp	.+8      	; 0x4176 <protocol_execute_realtime+0xc8>
      sys.abort = true;  // Only place this is set true.
    416e:	81 e0       	ldi	r24, 0x01	; 1
    4170:	80 93 04 06 	sts	0x0604, r24	; 0x800604 <sys>
      return; // Nothing else to do but exit.
    4174:	bf c0       	rjmp	.+382    	; 0x42f4 <protocol_execute_realtime+0x246>
    }
    
    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) { 
    4176:	10 ff       	sbrs	r17, 0
    4178:	0a c0       	rjmp	.+20     	; 0x418e <protocol_execute_realtime+0xe0>
      report_realtime_status();
    417a:	0e 94 17 27 	call	0x4e2e	; 0x4e2e <report_realtime_status>
      bit_false_atomic(sys_rt_exec_state,EXEC_STATUS_REPORT);
    417e:	9f b7       	in	r25, 0x3f	; 63
    4180:	f8 94       	cli
    4182:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    4186:	8e 7f       	andi	r24, 0xFE	; 254
    4188:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    418c:	9f bf       	out	0x3f, r25	; 63
  
    // Execute hold states.
    // NOTE: The math involved to calculate the hold should be low enough for most, if not all, 
    // operational scenarios. Once hold is initiated, the system enters a suspend state to block
    // all main program processes until either reset or resumed.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR)) {
    418e:	81 2f       	mov	r24, r17
    4190:	88 76       	andi	r24, 0x68	; 104
    4192:	09 f4       	brne	.+2      	; 0x4196 <protocol_execute_realtime+0xe8>
    4194:	a9 c0       	rjmp	.+338    	; 0x42e8 <protocol_execute_realtime+0x23a>
      
      // TODO: CHECK MODE? How to handle this? Likely nothing, since it only works when IDLE and then resets Grbl.
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {
    4196:	89 81       	ldd	r24, Y+1	; 0x01
    4198:	88 23       	and	r24, r24
    419a:	59 f0       	breq	.+22     	; 0x41b2 <protocol_execute_realtime+0x104>
    419c:	98 2f       	mov	r25, r24
    419e:	9c 77       	andi	r25, 0x7C	; 124
    41a0:	09 f0       	breq	.+2      	; 0x41a4 <protocol_execute_realtime+0xf6>
    41a2:	9f c0       	rjmp	.+318    	; 0x42e2 <protocol_execute_realtime+0x234>
    41a4:	23 c0       	rjmp	.+70     	; 0x41ec <protocol_execute_realtime+0x13e>

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
          st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    41a6:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <st_update_plan_block_parameters>
          sys.suspend = SUSPEND_ENABLE_HOLD; // Initiate holding cycle with flag.
    41aa:	0a 83       	std	Y+2, r16	; 0x02
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
    41ac:	89 81       	ldd	r24, Y+1	; 0x01
    41ae:	81 11       	cpse	r24, r1
    41b0:	05 c0       	rjmp	.+10     	; 0x41bc <protocol_execute_realtime+0x10e>
    41b2:	82 e0       	ldi	r24, 0x02	; 2
    41b4:	8a 83       	std	Y+2, r24	; 0x02
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    41b6:	16 fd       	sbrc	r17, 6
    41b8:	06 c0       	rjmp	.+12     	; 0x41c6 <protocol_execute_realtime+0x118>
    41ba:	99 c0       	rjmp	.+306    	; 0x42ee <protocol_execute_realtime+0x240>
    41bc:	16 ff       	sbrs	r17, 6
    41be:	06 c0       	rjmp	.+12     	; 0x41cc <protocol_execute_realtime+0x11e>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. If so, only flag that motion cancel is complete.
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
    41c0:	88 30       	cpi	r24, 0x08	; 8
    41c2:	09 f4       	brne	.+2      	; 0x41c6 <protocol_execute_realtime+0x118>
    41c4:	b9 82       	std	Y+1, r11	; 0x01
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
    41c6:	8a 81       	ldd	r24, Y+2	; 0x02
    41c8:	88 60       	ori	r24, 0x08	; 8
    41ca:	8a 83       	std	Y+2, r24	; 0x02
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    41cc:	13 ff       	sbrs	r17, 3
    41ce:	03 c0       	rjmp	.+6      	; 0x41d6 <protocol_execute_realtime+0x128>
          // Block SAFETY_DOOR state from prematurely changing back to HOLD.
          if (bit_isfalse(sys.state,STATE_SAFETY_DOOR)) { sys.state = STATE_HOLD; }
    41d0:	89 81       	ldd	r24, Y+1	; 0x01
    41d2:	85 ff       	sbrs	r24, 5
    41d4:	d9 82       	std	Y+1, r13	; 0x01
  
        // Execute a safety door stop with a feed hold, only during a cycle, and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged. The power-down is 
        // executed here, if IDLE, or when the CYCLE completes via the EXEC_CYCLE_STOP flag.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    41d6:	15 ff       	sbrs	r17, 5
    41d8:	09 c0       	rjmp	.+18     	; 0x41ec <protocol_execute_realtime+0x13e>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR); 
    41da:	86 e0       	ldi	r24, 0x06	; 6
    41dc:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
          // If already in active, ready-to-resume HOLD, set CYCLE_STOP flag to force de-energize.
          // NOTE: Only temporarily sets the 'rt_exec' variable, not the volatile 'rt_exec_state' variable.
          if (sys.suspend & SUSPEND_ENABLE_READY) { bit_true(rt_exec,EXEC_CYCLE_STOP); }
    41e0:	8a 81       	ldd	r24, Y+2	; 0x02
    41e2:	81 fd       	sbrc	r24, 1
    41e4:	14 60       	ori	r17, 0x04	; 4
          sys.suspend |= SUSPEND_ENERGIZE;
    41e6:	84 60       	ori	r24, 0x04	; 4
    41e8:	8a 83       	std	Y+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    41ea:	c9 82       	std	Y+1, r12	; 0x01
        }
         
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    41ec:	9f b7       	in	r25, 0x3f	; 63
    41ee:	f8 94       	cli
    41f0:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    41f4:	87 79       	andi	r24, 0x97	; 151
    41f6:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    41fa:	9f bf       	out	0x3f, r25	; 63
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    41fc:	11 ff       	sbrs	r17, 1
    41fe:	3d c0       	rjmp	.+122    	; 0x427a <protocol_execute_realtime+0x1cc>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) { 
    4200:	81 2f       	mov	r24, r17
    4202:	88 76       	andi	r24, 0x68	; 104
    4204:	91 f5       	brne	.+100    	; 0x426a <protocol_execute_realtime+0x1bc>
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        // NOTE: SAFETY_DOOR is implicitly blocked. It reverts to HOLD when the door is closed.
        if ((sys.state == STATE_IDLE) || ((sys.state & (STATE_HOLD | STATE_MOTION_CANCEL)) && (sys.suspend & SUSPEND_ENABLE_READY))) {
    4206:	89 81       	ldd	r24, Y+1	; 0x01
    4208:	88 23       	and	r24, r24
    420a:	29 f0       	breq	.+10     	; 0x4216 <protocol_execute_realtime+0x168>
    420c:	80 75       	andi	r24, 0x50	; 80
    420e:	69 f1       	breq	.+90     	; 0x426a <protocol_execute_realtime+0x1bc>
    4210:	8a 81       	ldd	r24, Y+2	; 0x02
    4212:	81 ff       	sbrs	r24, 1
    4214:	2a c0       	rjmp	.+84     	; 0x426a <protocol_execute_realtime+0x1bc>
          // Re-energize powered components, if disabled by SAFETY_DOOR.
          if (sys.suspend & SUSPEND_ENERGIZE) { 
    4216:	8a 81       	ldd	r24, Y+2	; 0x02
    4218:	82 ff       	sbrs	r24, 2
    421a:	18 c0       	rjmp	.+48     	; 0x424c <protocol_execute_realtime+0x19e>
            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    421c:	f7 01       	movw	r30, r14
    421e:	81 85       	ldd	r24, Z+9	; 0x09
    4220:	88 23       	and	r24, r24
    4222:	51 f0       	breq	.+20     	; 0x4238 <protocol_execute_realtime+0x18a>
              spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); 
    4224:	42 85       	ldd	r20, Z+10	; 0x0a
    4226:	53 85       	ldd	r21, Z+11	; 0x0b
    4228:	64 85       	ldd	r22, Z+12	; 0x0c
    422a:	75 85       	ldd	r23, Z+13	; 0x0d
    422c:	0e 94 cf 2b 	call	0x579e	; 0x579e <spindle_set_state>
              delay_ms(SAFETY_DOOR_SPINDLE_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    4230:	80 ea       	ldi	r24, 0xA0	; 160
    4232:	9f e0       	ldi	r25, 0x0F	; 15
    4234:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) { 
    4238:	f7 01       	movw	r30, r14
    423a:	80 85       	ldd	r24, Z+8	; 0x08
    423c:	88 23       	and	r24, r24
    423e:	31 f0       	breq	.+12     	; 0x424c <protocol_execute_realtime+0x19e>
              coolant_set_state(gc_state.modal.coolant); 
    4240:	0e 94 0a 05 	call	0xa14	; 0xa14 <coolant_set_state>
              delay_ms(SAFETY_DOOR_COOLANT_DELAY); // TODO: Blocking function call. Need a non-blocking one eventually.
    4244:	88 ee       	ldi	r24, 0xE8	; 232
    4246:	93 e0       	ldi	r25, 0x03	; 3
    4248:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>
            }
            // TODO: Install return to pre-park position.
          }
          // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
          if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    424c:	0e 94 05 1b 	call	0x360a	; 0x360a <plan_get_current_block>
    4250:	89 2b       	or	r24, r25
    4252:	49 f0       	breq	.+18     	; 0x4266 <protocol_execute_realtime+0x1b8>
    4254:	8a 81       	ldd	r24, Y+2	; 0x02
    4256:	83 fd       	sbrc	r24, 3
    4258:	06 c0       	rjmp	.+12     	; 0x4266 <protocol_execute_realtime+0x1b8>
            sys.state = STATE_CYCLE;
    425a:	a9 82       	std	Y+1, r10	; 0x01
            st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    425c:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <st_prep_buffer>
            st_wake_up();
    4260:	0e 94 45 2c 	call	0x588a	; 0x588a <st_wake_up>
    4264:	01 c0       	rjmp	.+2      	; 0x4268 <protocol_execute_realtime+0x1ba>
          } else { // Otherwise, do nothing. Set and resume IDLE state.
            sys.state = STATE_IDLE;
    4266:	19 82       	std	Y+1, r1	; 0x01
          }
          sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    4268:	1a 82       	std	Y+2, r1	; 0x02
        }
      }    
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_START);
    426a:	9f b7       	in	r25, 0x3f	; 63
    426c:	f8 94       	cli
    426e:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    4272:	8d 7f       	andi	r24, 0xFD	; 253
    4274:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    4278:	9f bf       	out	0x3f, r25	; 63
    // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by 
    // realtime command execution in the main program, ensuring that the planner re-plans safely.
    // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
    // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.   
    // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
    if (rt_exec & EXEC_CYCLE_STOP) {
    427a:	12 ff       	sbrs	r17, 2
    427c:	1b c0       	rjmp	.+54     	; 0x42b4 <protocol_execute_realtime+0x206>
      if (sys.state & (STATE_HOLD | STATE_SAFETY_DOOR) && !(sys.soft_limit)) {
    427e:	89 81       	ldd	r24, Y+1	; 0x01
    4280:	80 73       	andi	r24, 0x30	; 48
    4282:	71 f0       	breq	.+28     	; 0x42a0 <protocol_execute_realtime+0x1f2>
    4284:	8b 81       	ldd	r24, Y+3	; 0x03
    4286:	81 11       	cpse	r24, r1
    4288:	0b c0       	rjmp	.+22     	; 0x42a0 <protocol_execute_realtime+0x1f2>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        if (sys.suspend & SUSPEND_ENERGIZE) { // De-energize system if safety door has been opened.
    428a:	8a 81       	ldd	r24, Y+2	; 0x02
    428c:	82 ff       	sbrs	r24, 2
    428e:	04 c0       	rjmp	.+8      	; 0x4298 <protocol_execute_realtime+0x1ea>
          spindle_stop();
    4290:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
          coolant_stop();
    4294:	0e 94 04 05 	call	0xa08	; 0xa08 <coolant_stop>
        }
        bit_true(sys.suspend,SUSPEND_ENABLE_READY);
    4298:	8a 81       	ldd	r24, Y+2	; 0x02
    429a:	82 60       	ori	r24, 0x02	; 2
    429c:	8a 83       	std	Y+2, r24	; 0x02
    429e:	02 c0       	rjmp	.+4      	; 0x42a4 <protocol_execute_realtime+0x1f6>
      } else { // Motion is complete. Includes CYCLE, HOMING, and MOTION_CANCEL states.
        sys.suspend = SUSPEND_DISABLE;
    42a0:	1a 82       	std	Y+2, r1	; 0x02
        sys.state = STATE_IDLE;
    42a2:	19 82       	std	Y+1, r1	; 0x01
      }
      bit_false_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP);
    42a4:	9f b7       	in	r25, 0x3f	; 63
    42a6:	f8 94       	cli
    42a8:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    42ac:	8b 7f       	andi	r24, 0xFB	; 251
    42ae:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    42b2:	9f bf       	out	0x3f, r25	; 63

  // Overrides flag byte (sys.override) and execution should be installed here, since they 
  // are realtime and require a direct and controlled interface to the main stepper program.

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_MOTION_CANCEL | STATE_SAFETY_DOOR | STATE_HOMING)) { st_prep_buffer(); }  
    42b4:	89 81       	ldd	r24, Y+1	; 0x01
    42b6:	8c 77       	andi	r24, 0x7C	; 124
    42b8:	11 f0       	breq	.+4      	; 0x42be <protocol_execute_realtime+0x210>
    42ba:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <st_prep_buffer>
  
  // If safety door was opened, actively check when safety door is closed and ready to resume.
  // NOTE: This unlocks the SAFETY_DOOR state to a HOLD state, such that CYCLE_START can activate a resume.
  if (sys.state == STATE_SAFETY_DOOR) { 
    42be:	89 81       	ldd	r24, Y+1	; 0x01
    42c0:	80 32       	cpi	r24, 0x20	; 32
    42c2:	41 f4       	brne	.+16     	; 0x42d4 <protocol_execute_realtime+0x226>
    if (bit_istrue(sys.suspend,SUSPEND_ENABLE_READY)) { 
    42c4:	8a 81       	ldd	r24, Y+2	; 0x02
    42c6:	81 ff       	sbrs	r24, 1
    42c8:	05 c0       	rjmp	.+10     	; 0x42d4 <protocol_execute_realtime+0x226>
      if (!(system_check_safety_door_ajar())) {
    42ca:	0e 94 67 36 	call	0x6cce	; 0x6cce <system_check_safety_door_ajar>
    42ce:	81 11       	cpse	r24, r1
    42d0:	01 c0       	rjmp	.+2      	; 0x42d4 <protocol_execute_realtime+0x226>
        sys.state = STATE_HOLD; // Update to HOLD state to indicate door is closed and ready to resume.
    42d2:	d9 82       	std	Y+1, r13	; 0x01
      }
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
    42d4:	8a 81       	ldd	r24, Y+2	; 0x02
    42d6:	81 11       	cpse	r24, r1
    42d8:	09 cf       	rjmp	.-494    	; 0x40ec <protocol_execute_realtime+0x3e>
    42da:	0c c0       	rjmp	.+24     	; 0x42f4 <protocol_execute_realtime+0x246>
        // If IDLE, Grbl is not in motion. Simply indicate suspend ready state.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_ENABLE_READY; }
        
        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    42dc:	16 ff       	sbrs	r17, 6
    42de:	76 cf       	rjmp	.-276    	; 0x41cc <protocol_execute_realtime+0x11e>
    42e0:	72 cf       	rjmp	.-284    	; 0x41c6 <protocol_execute_realtime+0x118>
                
      // State check for allowable states for hold methods.
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOMING | STATE_MOTION_CANCEL | STATE_HOLD | STATE_SAFETY_DOOR))) {

        // If in CYCLE state, all hold states immediately initiate a motion HOLD.
        if (sys.state == STATE_CYCLE) {
    42e2:	88 30       	cpi	r24, 0x08	; 8
    42e4:	d9 f7       	brne	.-10     	; 0x42dc <protocol_execute_realtime+0x22e>
    42e6:	5f cf       	rjmp	.-322    	; 0x41a6 <protocol_execute_realtime+0xf8>
      }
      bit_false_atomic(sys_rt_exec_state,(EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR));      
    }
          
    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    42e8:	11 fd       	sbrc	r17, 1
    42ea:	8d cf       	rjmp	.-230    	; 0x4206 <protocol_execute_realtime+0x158>
    42ec:	c6 cf       	rjmp	.-116    	; 0x427a <protocol_execute_realtime+0x1cc>
          if (sys.state == STATE_CYCLE) { sys.state = STATE_MOTION_CANCEL; }
          sys.suspend |= SUSPEND_MOTION_CANCEL; // Indicate motion cancel when resuming. Special motion complete.
        }
    
        // Execute a feed hold with deceleration, only during cycle.
        if (rt_exec & EXEC_FEED_HOLD) {
    42ee:	13 fd       	sbrc	r17, 3
    42f0:	71 cf       	rjmp	.-286    	; 0x41d4 <protocol_execute_realtime+0x126>
    42f2:	71 cf       	rjmp	.-286    	; 0x41d6 <protocol_execute_realtime+0x128>
    }
  }

  } while(sys.suspend); // Check for system suspend state before exiting.
  
}  
    42f4:	df 91       	pop	r29
    42f6:	cf 91       	pop	r28
    42f8:	1f 91       	pop	r17
    42fa:	0f 91       	pop	r16
    42fc:	ff 90       	pop	r15
    42fe:	ef 90       	pop	r14
    4300:	df 90       	pop	r13
    4302:	cf 90       	pop	r12
    4304:	bf 90       	pop	r11
    4306:	af 90       	pop	r10
    4308:	08 95       	ret

0000430a <protocol_auto_cycle_start>:
// command in the planner queue.
// NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes 
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming 
// is finished, single commands), a command that needs to wait for the motions in the buffer to 
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start() { bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); } 
    430a:	9f b7       	in	r25, 0x3f	; 63
    430c:	f8 94       	cli
    430e:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    4312:	82 60       	ori	r24, 0x02	; 2
    4314:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    4318:	9f bf       	out	0x3f, r25	; 63
    431a:	08 95       	ret

0000431c <protocol_main_loop>:

/* 
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    431c:	bf 92       	push	r11
    431e:	cf 92       	push	r12
    4320:	df 92       	push	r13
    4322:	ef 92       	push	r14
    4324:	ff 92       	push	r15
    4326:	0f 93       	push	r16
    4328:	1f 93       	push	r17
    432a:	cf 93       	push	r28
    432c:	df 93       	push	r29
  // ------------------------------------------------------------
  // Complete initialization procedures upon a power-up or reset.
  // ------------------------------------------------------------
  
  // Print welcome message   
  report_init_message();
    432e:	0e 94 2f 23 	call	0x465e	; 0x465e <report_init_message>

  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    4332:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    4336:	81 30       	cpi	r24, 0x01	; 1
    4338:	81 f4       	brne	.+32     	; 0x435a <protocol_main_loop+0x3e>
    report_feedback_message(MESSAGE_ALARM_LOCK); 
    433a:	82 e0       	ldi	r24, 0x02	; 2
    433c:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    4340:	f1 2c       	mov	r15, r1
    4342:	e1 2c       	mov	r14, r1
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    4344:	c4 e0       	ldi	r28, 0x04	; 4
    4346:	d6 e0       	ldi	r29, 0x06	; 6
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    4348:	d1 2c       	mov	r13, r1

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    434a:	06 e6       	ldi	r16, 0x66	; 102
    434c:	14 e0       	ldi	r17, 0x04	; 4
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    434e:	cc 24       	eor	r12, r12
    4350:	c3 94       	inc	r12
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    4352:	68 94       	set
    4354:	bb 24       	eor	r11, r11
    4356:	b1 f8       	bld	r11, 1
    4358:	78 c0       	rjmp	.+240    	; 0x444a <protocol_main_loop+0x12e>
  // Check for and report alarm state after a reset, error, or an initial power up.
  if (sys.state == STATE_ALARM) {
    report_feedback_message(MESSAGE_ALARM_LOCK); 
  } else {
    // All systems go! But first check for safety door.
    if (system_check_safety_door_ajar()) {
    435a:	0e 94 67 36 	call	0x6cce	; 0x6cce <system_check_safety_door_ajar>
    435e:	88 23       	and	r24, r24
    4360:	41 f0       	breq	.+16     	; 0x4372 <protocol_main_loop+0x56>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    4362:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    4366:	80 62       	ori	r24, 0x20	; 32
    4368:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    436c:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    4370:	02 c0       	rjmp	.+4      	; 0x4376 <protocol_main_loop+0x5a>
    } else {
      sys.state = STATE_IDLE; // Set system to ready. Clear all state flags.
    4372:	10 92 05 06 	sts	0x0605, r1	; 0x800605 <sys+0x1>
    } 
    system_execute_startup(line); // Execute startup script.
    4376:	86 e6       	ldi	r24, 0x66	; 102
    4378:	94 e0       	ldi	r25, 0x04	; 4
    437a:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <system_execute_startup>
    437e:	e0 cf       	rjmp	.-64     	; 0x4340 <protocol_main_loop+0x24>
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
    4380:	8a 30       	cpi	r24, 0x0A	; 10
    4382:	11 f0       	breq	.+4      	; 0x4388 <protocol_main_loop+0x6c>
    4384:	8d 30       	cpi	r24, 0x0D	; 13
    4386:	79 f5       	brne	.+94     	; 0x43e6 <protocol_main_loop+0xca>
        line[char_counter] = 0; // Set string termination character.
    4388:	ef 2d       	mov	r30, r15
    438a:	f0 e0       	ldi	r31, 0x00	; 0
    438c:	ea 59       	subi	r30, 0x9A	; 154
    438e:	fb 4f       	sbci	r31, 0xFB	; 251
    4390:	10 82       	st	Z, r1
// Directs and executes one line of formatted input from protocol_process. While mostly
// incoming streaming g-code blocks, this also directs and executes Grbl internal commands,
// such as settings, initiating the homing cycle, and toggling switch states.
static void protocol_execute_line(char *line) 
{      
  protocol_execute_realtime(); // Runtime command check point.
    4392:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
  if (sys.abort) { return; } // Bail to calling function upon system abort  
    4396:	88 81       	ld	r24, Y
    4398:	81 11       	cpse	r24, r1
    439a:	51 c0       	rjmp	.+162    	; 0x443e <protocol_main_loop+0x122>

  #ifdef REPORT_ECHO_LINE_RECEIVED
    report_echo_line_received(line);
  #endif

  if (line[0] == 0) {
    439c:	f8 01       	movw	r30, r16
    439e:	80 81       	ld	r24, Z
    43a0:	81 11       	cpse	r24, r1
    43a2:	06 c0       	rjmp	.+12     	; 0x43b0 <protocol_main_loop+0x94>
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);
    43a4:	8d 2d       	mov	r24, r13
    43a6:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43aa:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43ac:	ed 2c       	mov	r14, r13
    43ae:	4d c0       	rjmp	.+154    	; 0x444a <protocol_main_loop+0x12e>

  if (line[0] == 0) {
    // Empty or comment line. Send status message for syncing purposes.
    report_status_message(STATUS_OK);

  } else if (line[0] == '$') {
    43b0:	84 32       	cpi	r24, 0x24	; 36
    43b2:	41 f4       	brne	.+16     	; 0x43c4 <protocol_main_loop+0xa8>
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    43b4:	c8 01       	movw	r24, r16
    43b6:	0e 94 8b 36 	call	0x6d16	; 0x6d16 <system_execute_line>
    43ba:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43be:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43c0:	ed 2c       	mov	r14, r13
    43c2:	43 c0       	rjmp	.+134    	; 0x444a <protocol_main_loop+0x12e>

  } else if (line[0] == '$') {
    // Grbl '$' system command
    report_status_message(system_execute_line(line));
    
  } else if (sys.state == STATE_ALARM) {
    43c4:	89 81       	ldd	r24, Y+1	; 0x01
    43c6:	81 30       	cpi	r24, 0x01	; 1
    43c8:	31 f4       	brne	.+12     	; 0x43d6 <protocol_main_loop+0xba>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);
    43ca:	89 e0       	ldi	r24, 0x09	; 9
    43cc:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43d0:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43d2:	ed 2c       	mov	r14, r13
    43d4:	3a c0       	rjmp	.+116    	; 0x444a <protocol_main_loop+0x12e>
    // Everything else is gcode. Block if in alarm mode.
    report_status_message(STATUS_ALARM_LOCK);

  } else {
    // Parse and execute g-code block!
    report_status_message(gc_execute_line(line));
    43d6:	c8 01       	movw	r24, r16
    43d8:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    43dc:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    43e0:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    43e2:	ed 2c       	mov	r14, r13
    43e4:	32 c0       	rjmp	.+100    	; 0x444a <protocol_main_loop+0x12e>
        char_counter = 0;
      } else {
        if (comment != COMMENT_NONE) {
    43e6:	ee 20       	and	r14, r14
    43e8:	39 f0       	breq	.+14     	; 0x43f8 <protocol_main_loop+0xdc>
          // Throw away all comment characters
          if (c == ')') {
    43ea:	89 32       	cpi	r24, 0x29	; 41
    43ec:	71 f5       	brne	.+92     	; 0x444a <protocol_main_loop+0x12e>
            // End of comment. Resume line. But, not if semicolon type comment.
            if (comment == COMMENT_TYPE_PARENTHESES) { comment = COMMENT_NONE; }
    43ee:	f1 e0       	ldi	r31, 0x01	; 1
    43f0:	ef 12       	cpse	r14, r31
    43f2:	2b c0       	rjmp	.+86     	; 0x444a <protocol_main_loop+0x12e>
    43f4:	ed 2c       	mov	r14, r13
    43f6:	29 c0       	rjmp	.+82     	; 0x444a <protocol_main_loop+0x12e>
          }
        } else {
          if (c <= ' ') { 
    43f8:	81 32       	cpi	r24, 0x21	; 33
    43fa:	38 f1       	brcs	.+78     	; 0x444a <protocol_main_loop+0x12e>
            // Throw away whitepace and control characters  
          } else if (c == '/') { 
    43fc:	8f 32       	cpi	r24, 0x2F	; 47
    43fe:	29 f1       	breq	.+74     	; 0x444a <protocol_main_loop+0x12e>
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } else if (c == '(') {
    4400:	88 32       	cpi	r24, 0x28	; 40
    4402:	01 f1       	breq	.+64     	; 0x4444 <protocol_main_loop+0x128>
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
          } else if (c == ';') {
    4404:	8b 33       	cpi	r24, 0x3B	; 59
    4406:	01 f1       	breq	.+64     	; 0x4448 <protocol_main_loop+0x12c>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute 
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.

          } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
    4408:	9e e4       	ldi	r25, 0x4E	; 78
    440a:	9f 15       	cp	r25, r15
    440c:	28 f4       	brcc	.+10     	; 0x4418 <protocol_main_loop+0xfc>
            // Detect line buffer overflow. Report error and reset line buffer.
            report_status_message(STATUS_OVERFLOW);
    440e:	8b e0       	ldi	r24, 0x0B	; 11
    4410:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
            comment = COMMENT_NONE;
            char_counter = 0;
    4414:	fd 2c       	mov	r15, r13
    4416:	19 c0       	rjmp	.+50     	; 0x444a <protocol_main_loop+0x12e>
          } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
    4418:	9f e9       	ldi	r25, 0x9F	; 159
    441a:	98 0f       	add	r25, r24
    441c:	9a 31       	cpi	r25, 0x1A	; 26
    441e:	40 f4       	brcc	.+16     	; 0x4430 <protocol_main_loop+0x114>
            line[char_counter++] = c-'a'+'A';
    4420:	ef 2d       	mov	r30, r15
    4422:	f0 e0       	ldi	r31, 0x00	; 0
    4424:	ea 59       	subi	r30, 0x9A	; 154
    4426:	fb 4f       	sbci	r31, 0xFB	; 251
    4428:	80 52       	subi	r24, 0x20	; 32
    442a:	80 83       	st	Z, r24
    442c:	f3 94       	inc	r15
    442e:	0d c0       	rjmp	.+26     	; 0x444a <protocol_main_loop+0x12e>
          } else {
            line[char_counter++] = c;
    4430:	ef 2d       	mov	r30, r15
    4432:	f0 e0       	ldi	r31, 0x00	; 0
    4434:	ea 59       	subi	r30, 0x9A	; 154
    4436:	fb 4f       	sbci	r31, 0xFB	; 251
    4438:	80 83       	st	Z, r24
    443a:	f3 94       	inc	r15
    443c:	06 c0       	rjmp	.+12     	; 0x444a <protocol_main_loop+0x12e>
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
        char_counter = 0;
    443e:	fd 2c       	mov	r15, r13
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
      if ((c == '\n') || (c == '\r')) { // End of line reached
        line[char_counter] = 0; // Set string termination character.
        protocol_execute_line(line); // Line is complete. Execute it!
        comment = COMMENT_NONE;
    4440:	ed 2c       	mov	r14, r13
    4442:	03 c0       	rjmp	.+6      	; 0x444a <protocol_main_loop+0x12e>
          } else if (c == '(') {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            comment = COMMENT_TYPE_PARENTHESES;
    4444:	ec 2c       	mov	r14, r12
    4446:	01 c0       	rjmp	.+2      	; 0x444a <protocol_main_loop+0x12e>
          } else if (c == ';') {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            comment = COMMENT_TYPE_SEMICOLON;
    4448:	eb 2c       	mov	r14, r11
    // line buffer, which is limited in size. The g-code standard actually states a line can't
    // exceed 256 characters, but the Arduino Uno does not have the memory space for this.
    // With a better processor, it would be very easy to pull this initial parsing out as a 
    // seperate task to be shared by the g-code parser and Grbl's system commands.
    
    while((c = serial_read()) != SERIAL_NO_DATA) {
    444a:	0e 94 71 28 	call	0x50e2	; 0x50e2 <serial_read>
    444e:	8f 3f       	cpi	r24, 0xFF	; 255
    4450:	09 f0       	breq	.+2      	; 0x4454 <protocol_main_loop+0x138>
    4452:	96 cf       	rjmp	.-212    	; 0x4380 <protocol_main_loop+0x64>
    }
    
    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has 
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    4454:	0e 94 85 21 	call	0x430a	; 0x430a <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    4458:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    445c:	88 81       	ld	r24, Y
    445e:	88 23       	and	r24, r24
    4460:	a1 f3       	breq	.-24     	; 0x444a <protocol_main_loop+0x12e>
              
  }
  
  return; /* Never reached */
}
    4462:	df 91       	pop	r29
    4464:	cf 91       	pop	r28
    4466:	1f 91       	pop	r17
    4468:	0f 91       	pop	r16
    446a:	ff 90       	pop	r15
    446c:	ef 90       	pop	r14
    446e:	df 90       	pop	r13
    4470:	cf 90       	pop	r12
    4472:	bf 90       	pop	r11
    4474:	08 95       	ret

00004476 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    4476:	cf 93       	push	r28
    4478:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    447a:	0e 94 85 21 	call	0x430a	; 0x430a <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    447e:	c4 e0       	ldi	r28, 0x04	; 4
    4480:	d6 e0       	ldi	r29, 0x06	; 6
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    4482:	0e 94 57 20 	call	0x40ae	; 0x40ae <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    4486:	88 81       	ld	r24, Y
    4488:	81 11       	cpse	r24, r1
    448a:	07 c0       	rjmp	.+14     	; 0x449a <protocol_buffer_synchronize+0x24>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    448c:	0e 94 05 1b 	call	0x360a	; 0x360a <plan_get_current_block>
    4490:	89 2b       	or	r24, r25
    4492:	b9 f7       	brne	.-18     	; 0x4482 <protocol_buffer_synchronize+0xc>
    4494:	89 81       	ldd	r24, Y+1	; 0x01
    4496:	88 30       	cpi	r24, 0x08	; 8
    4498:	a1 f3       	breq	.-24     	; 0x4482 <protocol_buffer_synchronize+0xc>
}
    449a:	df 91       	pop	r29
    449c:	cf 91       	pop	r28
    449e:	08 95       	ret

000044a0 <report_status_message>:
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
  printPgmString(PSTR("[echo: ")); printString(line);
  printPgmString(PSTR("]\r\n"));
}
    44a0:	cf 93       	push	r28
    44a2:	c8 2f       	mov	r28, r24
    44a4:	81 11       	cpse	r24, r1
    44a6:	05 c0       	rjmp	.+10     	; 0x44b2 <report_status_message+0x12>
    44a8:	84 ec       	ldi	r24, 0xC4	; 196
    44aa:	99 e0       	ldi	r25, 0x09	; 9
    44ac:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44b0:	61 c0       	rjmp	.+194    	; 0x4574 <report_status_message+0xd4>
    44b2:	8c eb       	ldi	r24, 0xBC	; 188
    44b4:	99 e0       	ldi	r25, 0x09	; 9
    44b6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44ba:	8c 2f       	mov	r24, r28
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	fc 01       	movw	r30, r24
    44c0:	31 97       	sbiw	r30, 0x01	; 1
    44c2:	e6 31       	cpi	r30, 0x16	; 22
    44c4:	f1 05       	cpc	r31, r1
    44c6:	08 f0       	brcs	.+2      	; 0x44ca <report_status_message+0x2a>
    44c8:	4a c0       	rjmp	.+148    	; 0x455e <report_status_message+0xbe>
    44ca:	e9 52       	subi	r30, 0x29	; 41
    44cc:	ff 4f       	sbci	r31, 0xFF	; 255
    44ce:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
    44d2:	84 ea       	ldi	r24, 0xA4	; 164
    44d4:	99 e0       	ldi	r25, 0x09	; 9
    44d6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44da:	48 c0       	rjmp	.+144    	; 0x456c <report_status_message+0xcc>
    44dc:	82 e9       	ldi	r24, 0x92	; 146
    44de:	99 e0       	ldi	r25, 0x09	; 9
    44e0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44e4:	43 c0       	rjmp	.+134    	; 0x456c <report_status_message+0xcc>
    44e6:	80 e8       	ldi	r24, 0x80	; 128
    44e8:	99 e0       	ldi	r25, 0x09	; 9
    44ea:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44ee:	3e c0       	rjmp	.+124    	; 0x456c <report_status_message+0xcc>
    44f0:	86 e7       	ldi	r24, 0x76	; 118
    44f2:	99 e0       	ldi	r25, 0x09	; 9
    44f4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    44f8:	39 c0       	rjmp	.+114    	; 0x456c <report_status_message+0xcc>
    44fa:	85 e6       	ldi	r24, 0x65	; 101
    44fc:	99 e0       	ldi	r25, 0x09	; 9
    44fe:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4502:	34 c0       	rjmp	.+104    	; 0x456c <report_status_message+0xcc>
    4504:	86 e5       	ldi	r24, 0x56	; 86
    4506:	99 e0       	ldi	r25, 0x09	; 9
    4508:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    450c:	2f c0       	rjmp	.+94     	; 0x456c <report_status_message+0xcc>
    450e:	85 e3       	ldi	r24, 0x35	; 53
    4510:	99 e0       	ldi	r25, 0x09	; 9
    4512:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4516:	2a c0       	rjmp	.+84     	; 0x456c <report_status_message+0xcc>
    4518:	8c e2       	ldi	r24, 0x2C	; 44
    451a:	99 e0       	ldi	r25, 0x09	; 9
    451c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4520:	25 c0       	rjmp	.+74     	; 0x456c <report_status_message+0xcc>
    4522:	81 e2       	ldi	r24, 0x21	; 33
    4524:	99 e0       	ldi	r25, 0x09	; 9
    4526:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    452a:	20 c0       	rjmp	.+64     	; 0x456c <report_status_message+0xcc>
    452c:	8e e0       	ldi	r24, 0x0E	; 14
    452e:	99 e0       	ldi	r25, 0x09	; 9
    4530:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4534:	1b c0       	rjmp	.+54     	; 0x456c <report_status_message+0xcc>
    4536:	80 e0       	ldi	r24, 0x00	; 0
    4538:	99 e0       	ldi	r25, 0x09	; 9
    453a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    453e:	16 c0       	rjmp	.+44     	; 0x456c <report_status_message+0xcc>
    4540:	8a ee       	ldi	r24, 0xEA	; 234
    4542:	98 e0       	ldi	r25, 0x08	; 8
    4544:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4548:	11 c0       	rjmp	.+34     	; 0x456c <report_status_message+0xcc>
    454a:	86 ed       	ldi	r24, 0xD6	; 214
    454c:	98 e0       	ldi	r25, 0x08	; 8
    454e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4552:	0c c0       	rjmp	.+24     	; 0x456c <report_status_message+0xcc>
    4554:	82 ec       	ldi	r24, 0xC2	; 194
    4556:	98 e0       	ldi	r25, 0x08	; 8
    4558:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    455c:	07 c0       	rjmp	.+14     	; 0x456c <report_status_message+0xcc>
    455e:	80 eb       	ldi	r24, 0xB0	; 176
    4560:	98 e0       	ldi	r25, 0x08	; 8
    4562:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4566:	8c 2f       	mov	r24, r28
    4568:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    456c:	8d ea       	ldi	r24, 0xAD	; 173
    456e:	98 e0       	ldi	r25, 0x08	; 8
    4570:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4574:	cf 91       	pop	r28
    4576:	08 95       	ret

00004578 <report_alarm_message>:
    4578:	cf 93       	push	r28
    457a:	c8 2f       	mov	r28, r24
    457c:	85 ea       	ldi	r24, 0xA5	; 165
    457e:	98 e0       	ldi	r25, 0x08	; 8
    4580:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4584:	c3 30       	cpi	r28, 0x03	; 3
    4586:	a9 f0       	breq	.+42     	; 0x45b2 <report_alarm_message+0x3a>
    4588:	2c f4       	brge	.+10     	; 0x4594 <report_alarm_message+0x1c>
    458a:	c1 30       	cpi	r28, 0x01	; 1
    458c:	41 f0       	breq	.+16     	; 0x459e <report_alarm_message+0x26>
    458e:	c2 30       	cpi	r28, 0x02	; 2
    4590:	59 f0       	breq	.+22     	; 0x45a8 <report_alarm_message+0x30>
    4592:	1d c0       	rjmp	.+58     	; 0x45ce <report_alarm_message+0x56>
    4594:	c4 30       	cpi	r28, 0x04	; 4
    4596:	91 f0       	breq	.+36     	; 0x45bc <report_alarm_message+0x44>
    4598:	c5 30       	cpi	r28, 0x05	; 5
    459a:	a9 f0       	breq	.+42     	; 0x45c6 <report_alarm_message+0x4e>
    459c:	18 c0       	rjmp	.+48     	; 0x45ce <report_alarm_message+0x56>
    459e:	8a e9       	ldi	r24, 0x9A	; 154
    45a0:	98 e0       	ldi	r25, 0x08	; 8
    45a2:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45a6:	13 c0       	rjmp	.+38     	; 0x45ce <report_alarm_message+0x56>
    45a8:	8f e8       	ldi	r24, 0x8F	; 143
    45aa:	98 e0       	ldi	r25, 0x08	; 8
    45ac:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45b0:	0e c0       	rjmp	.+28     	; 0x45ce <report_alarm_message+0x56>
    45b2:	8c e7       	ldi	r24, 0x7C	; 124
    45b4:	98 e0       	ldi	r25, 0x08	; 8
    45b6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45ba:	09 c0       	rjmp	.+18     	; 0x45ce <report_alarm_message+0x56>
    45bc:	81 e7       	ldi	r24, 0x71	; 113
    45be:	98 e0       	ldi	r25, 0x08	; 8
    45c0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45c4:	04 c0       	rjmp	.+8      	; 0x45ce <report_alarm_message+0x56>
    45c6:	85 e6       	ldi	r24, 0x65	; 101
    45c8:	98 e0       	ldi	r25, 0x08	; 8
    45ca:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45ce:	82 e6       	ldi	r24, 0x62	; 98
    45d0:	98 e0       	ldi	r25, 0x08	; 8
    45d2:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45d6:	84 ef       	ldi	r24, 0xF4	; 244
    45d8:	91 e0       	ldi	r25, 0x01	; 1
    45da:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>
    45de:	cf 91       	pop	r28
    45e0:	08 95       	ret

000045e2 <report_feedback_message>:
    45e2:	cf 93       	push	r28
    45e4:	c8 2f       	mov	r28, r24
    45e6:	80 e6       	ldi	r24, 0x60	; 96
    45e8:	98 e0       	ldi	r25, 0x08	; 8
    45ea:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    45ee:	8c 2f       	mov	r24, r28
    45f0:	90 e0       	ldi	r25, 0x00	; 0
    45f2:	fc 01       	movw	r30, r24
    45f4:	31 97       	sbiw	r30, 0x01	; 1
    45f6:	e8 30       	cpi	r30, 0x08	; 8
    45f8:	f1 05       	cpc	r31, r1
    45fa:	58 f5       	brcc	.+86     	; 0x4652 <report_feedback_message+0x70>
    45fc:	e3 51       	subi	r30, 0x13	; 19
    45fe:	ff 4f       	sbci	r31, 0xFF	; 255
    4600:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
    4604:	8e e4       	ldi	r24, 0x4E	; 78
    4606:	98 e0       	ldi	r25, 0x08	; 8
    4608:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    460c:	22 c0       	rjmp	.+68     	; 0x4652 <report_feedback_message+0x70>
    460e:	8a e3       	ldi	r24, 0x3A	; 58
    4610:	98 e0       	ldi	r25, 0x08	; 8
    4612:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4616:	1d c0       	rjmp	.+58     	; 0x4652 <report_feedback_message+0x70>
    4618:	88 e2       	ldi	r24, 0x28	; 40
    461a:	98 e0       	ldi	r25, 0x08	; 8
    461c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4620:	18 c0       	rjmp	.+48     	; 0x4652 <report_feedback_message+0x70>
    4622:	80 e2       	ldi	r24, 0x20	; 32
    4624:	98 e0       	ldi	r25, 0x08	; 8
    4626:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    462a:	13 c0       	rjmp	.+38     	; 0x4652 <report_feedback_message+0x70>
    462c:	87 e1       	ldi	r24, 0x17	; 23
    462e:	98 e0       	ldi	r25, 0x08	; 8
    4630:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4634:	0e c0       	rjmp	.+28     	; 0x4652 <report_feedback_message+0x70>
    4636:	8c e0       	ldi	r24, 0x0C	; 12
    4638:	98 e0       	ldi	r25, 0x08	; 8
    463a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    463e:	09 c0       	rjmp	.+18     	; 0x4652 <report_feedback_message+0x70>
    4640:	84 e0       	ldi	r24, 0x04	; 4
    4642:	98 e0       	ldi	r25, 0x08	; 8
    4644:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4648:	04 c0       	rjmp	.+8      	; 0x4652 <report_feedback_message+0x70>
    464a:	81 ef       	ldi	r24, 0xF1	; 241
    464c:	97 e0       	ldi	r25, 0x07	; 7
    464e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4652:	8d ee       	ldi	r24, 0xED	; 237
    4654:	97 e0       	ldi	r25, 0x07	; 7
    4656:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    465a:	cf 91       	pop	r28
    465c:	08 95       	ret

0000465e <report_init_message>:
    465e:	80 ed       	ldi	r24, 0xD0	; 208
    4660:	97 e0       	ldi	r25, 0x07	; 7
    4662:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4666:	08 95       	ret

00004668 <report_grbl_help>:
    4668:	8c e8       	ldi	r24, 0x8C	; 140
    466a:	96 e0       	ldi	r25, 0x06	; 6
    466c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4670:	08 95       	ret

00004672 <report_grbl_settings>:
    4672:	1f 93       	push	r17
    4674:	cf 93       	push	r28
    4676:	df 93       	push	r29
    4678:	88 e8       	ldi	r24, 0x88	; 136
    467a:	96 e0       	ldi	r25, 0x06	; 6
    467c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4680:	c3 ee       	ldi	r28, 0xE3	; 227
    4682:	d6 e0       	ldi	r29, 0x06	; 6
    4684:	88 a9       	ldd	r24, Y+48	; 0x30
    4686:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    468a:	8f e6       	ldi	r24, 0x6F	; 111
    468c:	96 e0       	ldi	r25, 0x06	; 6
    468e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4692:	8b a9       	ldd	r24, Y+51	; 0x33
    4694:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4698:	81 e5       	ldi	r24, 0x51	; 81
    469a:	96 e0       	ldi	r25, 0x06	; 6
    469c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46a0:	89 a9       	ldd	r24, Y+49	; 0x31
    46a2:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    46a6:	88 e3       	ldi	r24, 0x38	; 56
    46a8:	96 e0       	ldi	r25, 0x06	; 6
    46aa:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46ae:	89 a9       	ldd	r24, Y+49	; 0x31
    46b0:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <print_uint8_base2>
    46b4:	81 e3       	ldi	r24, 0x31	; 49
    46b6:	96 e0       	ldi	r25, 0x06	; 6
    46b8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46bc:	8a a9       	ldd	r24, Y+50	; 0x32
    46be:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    46c2:	89 e1       	ldi	r24, 0x19	; 25
    46c4:	96 e0       	ldi	r25, 0x06	; 6
    46c6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46ca:	8a a9       	ldd	r24, Y+50	; 0x32
    46cc:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <print_uint8_base2>
    46d0:	82 e1       	ldi	r24, 0x12	; 18
    46d2:	96 e0       	ldi	r25, 0x06	; 6
    46d4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46d8:	8d ad       	ldd	r24, Y+61	; 0x3d
    46da:	82 fb       	bst	r24, 2
    46dc:	88 27       	eor	r24, r24
    46de:	80 f9       	bld	r24, 0
    46e0:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    46e4:	81 ef       	ldi	r24, 0xF1	; 241
    46e6:	95 e0       	ldi	r25, 0x05	; 5
    46e8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    46ec:	8d ad       	ldd	r24, Y+61	; 0x3d
    46ee:	86 fb       	bst	r24, 6
    46f0:	88 27       	eor	r24, r24
    46f2:	80 f9       	bld	r24, 0
    46f4:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    46f8:	81 ed       	ldi	r24, 0xD1	; 209
    46fa:	95 e0       	ldi	r25, 0x05	; 5
    46fc:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4700:	8d ad       	ldd	r24, Y+61	; 0x3d
    4702:	88 1f       	adc	r24, r24
    4704:	88 27       	eor	r24, r24
    4706:	88 1f       	adc	r24, r24
    4708:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    470c:	81 eb       	ldi	r24, 0xB1	; 177
    470e:	95 e0       	ldi	r25, 0x05	; 5
    4710:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4714:	8c a9       	ldd	r24, Y+52	; 0x34
    4716:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    471a:	8b e9       	ldi	r24, 0x9B	; 155
    471c:	95 e0       	ldi	r25, 0x05	; 5
    471e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4722:	8c a9       	ldd	r24, Y+52	; 0x34
    4724:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <print_uint8_base2>
    4728:	83 e9       	ldi	r24, 0x93	; 147
    472a:	95 e0       	ldi	r25, 0x05	; 5
    472c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4730:	6d a9       	ldd	r22, Y+53	; 0x35
    4732:	7e a9       	ldd	r23, Y+54	; 0x36
    4734:	8f a9       	ldd	r24, Y+55	; 0x37
    4736:	98 ad       	ldd	r25, Y+56	; 0x38
    4738:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    473c:	83 e7       	ldi	r24, 0x73	; 115
    473e:	95 e0       	ldi	r25, 0x05	; 5
    4740:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4744:	69 ad       	ldd	r22, Y+57	; 0x39
    4746:	7a ad       	ldd	r23, Y+58	; 0x3a
    4748:	8b ad       	ldd	r24, Y+59	; 0x3b
    474a:	9c ad       	ldd	r25, Y+60	; 0x3c
    474c:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    4750:	88 e5       	ldi	r24, 0x58	; 88
    4752:	95 e0       	ldi	r25, 0x05	; 5
    4754:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4758:	8d ad       	ldd	r24, Y+61	; 0x3d
    475a:	81 70       	andi	r24, 0x01	; 1
    475c:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4760:	8b e3       	ldi	r24, 0x3B	; 59
    4762:	95 e0       	ldi	r25, 0x05	; 5
    4764:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4768:	8d ad       	ldd	r24, Y+61	; 0x3d
    476a:	85 fb       	bst	r24, 5
    476c:	88 27       	eor	r24, r24
    476e:	80 f9       	bld	r24, 0
    4770:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4774:	80 e2       	ldi	r24, 0x20	; 32
    4776:	95 e0       	ldi	r25, 0x05	; 5
    4778:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    477c:	8d ad       	ldd	r24, Y+61	; 0x3d
    477e:	83 fb       	bst	r24, 3
    4780:	88 27       	eor	r24, r24
    4782:	80 f9       	bld	r24, 0
    4784:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4788:	85 e0       	ldi	r24, 0x05	; 5
    478a:	95 e0       	ldi	r25, 0x05	; 5
    478c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4790:	8d ad       	ldd	r24, Y+61	; 0x3d
    4792:	82 95       	swap	r24
    4794:	81 70       	andi	r24, 0x01	; 1
    4796:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    479a:	89 ee       	ldi	r24, 0xE9	; 233
    479c:	94 e0       	ldi	r25, 0x04	; 4
    479e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    47a2:	8e ad       	ldd	r24, Y+62	; 0x3e
    47a4:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    47a8:	8f ec       	ldi	r24, 0xCF	; 207
    47aa:	94 e0       	ldi	r25, 0x04	; 4
    47ac:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    47b0:	8e ad       	ldd	r24, Y+62	; 0x3e
    47b2:	0e 94 32 1f 	call	0x3e64	; 0x3e64 <print_uint8_base2>
    47b6:	87 ec       	ldi	r24, 0xC7	; 199
    47b8:	94 e0       	ldi	r25, 0x04	; 4
    47ba:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    47be:	60 91 22 07 	lds	r22, 0x0722	; 0x800722 <settings+0x3f>
    47c2:	70 91 23 07 	lds	r23, 0x0723	; 0x800723 <settings+0x40>
    47c6:	80 91 24 07 	lds	r24, 0x0724	; 0x800724 <settings+0x41>
    47ca:	90 91 25 07 	lds	r25, 0x0725	; 0x800725 <settings+0x42>
    47ce:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    47d2:	8a ea       	ldi	r24, 0xAA	; 170
    47d4:	94 e0       	ldi	r25, 0x04	; 4
    47d6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    47da:	60 91 26 07 	lds	r22, 0x0726	; 0x800726 <settings+0x43>
    47de:	70 91 27 07 	lds	r23, 0x0727	; 0x800727 <settings+0x44>
    47e2:	80 91 28 07 	lds	r24, 0x0728	; 0x800728 <settings+0x45>
    47e6:	90 91 29 07 	lds	r25, 0x0729	; 0x800729 <settings+0x46>
    47ea:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    47ee:	8d e8       	ldi	r24, 0x8D	; 141
    47f0:	94 e0       	ldi	r25, 0x04	; 4
    47f2:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    47f6:	80 91 2a 07 	lds	r24, 0x072A	; 0x80072a <settings+0x47>
    47fa:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    47fe:	8e e6       	ldi	r24, 0x6E	; 110
    4800:	94 e0       	ldi	r25, 0x04	; 4
    4802:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4806:	60 91 2c 07 	lds	r22, 0x072C	; 0x80072c <settings+0x49>
    480a:	70 91 2d 07 	lds	r23, 0x072D	; 0x80072d <settings+0x4a>
    480e:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <settings+0x4b>
    4812:	90 91 2f 07 	lds	r25, 0x072F	; 0x80072f <settings+0x4c>
    4816:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    481a:	85 e5       	ldi	r24, 0x55	; 85
    481c:	94 e0       	ldi	r25, 0x04	; 4
    481e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4822:	14 e6       	ldi	r17, 0x64	; 100
    4824:	d0 e0       	ldi	r29, 0x00	; 0
    4826:	f2 c0       	rjmp	.+484    	; 0x4a0c <report_grbl_settings+0x39a>
    4828:	83 e5       	ldi	r24, 0x53	; 83
    482a:	94 e0       	ldi	r25, 0x04	; 4
    482c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4830:	8c 2f       	mov	r24, r28
    4832:	81 0f       	add	r24, r17
    4834:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4838:	81 e5       	ldi	r24, 0x51	; 81
    483a:	94 e0       	ldi	r25, 0x04	; 4
    483c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4840:	d1 30       	cpi	r29, 0x01	; 1
    4842:	11 f1       	breq	.+68     	; 0x4888 <report_grbl_settings+0x216>
    4844:	30 f0       	brcs	.+12     	; 0x4852 <report_grbl_settings+0x1e0>
    4846:	d2 30       	cpi	r29, 0x02	; 2
    4848:	d1 f1       	breq	.+116    	; 0x48be <report_grbl_settings+0x24c>
    484a:	d3 30       	cpi	r29, 0x03	; 3
    484c:	09 f0       	breq	.+2      	; 0x4850 <report_grbl_settings+0x1de>
    484e:	70 c0       	rjmp	.+224    	; 0x4930 <report_grbl_settings+0x2be>
    4850:	54 c0       	rjmp	.+168    	; 0x48fa <report_grbl_settings+0x288>
    4852:	ec 2f       	mov	r30, r28
    4854:	f0 e0       	ldi	r31, 0x00	; 0
    4856:	ee 0f       	add	r30, r30
    4858:	ff 1f       	adc	r31, r31
    485a:	ee 0f       	add	r30, r30
    485c:	ff 1f       	adc	r31, r31
    485e:	ed 51       	subi	r30, 0x1D	; 29
    4860:	f9 4f       	sbci	r31, 0xF9	; 249
    4862:	60 81       	ld	r22, Z
    4864:	71 81       	ldd	r23, Z+1	; 0x01
    4866:	82 81       	ldd	r24, Z+2	; 0x02
    4868:	93 81       	ldd	r25, Z+3	; 0x03
    486a:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    486e:	8e e4       	ldi	r24, 0x4E	; 78
    4870:	94 e0       	ldi	r25, 0x04	; 4
    4872:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4876:	c1 30       	cpi	r28, 0x01	; 1
    4878:	09 f4       	brne	.+2      	; 0x487c <report_grbl_settings+0x20a>
    487a:	6a c0       	rjmp	.+212    	; 0x4950 <report_grbl_settings+0x2de>
    487c:	08 f4       	brcc	.+2      	; 0x4880 <report_grbl_settings+0x20e>
    487e:	62 c0       	rjmp	.+196    	; 0x4944 <report_grbl_settings+0x2d2>
    4880:	c2 30       	cpi	r28, 0x02	; 2
    4882:	09 f4       	brne	.+2      	; 0x4886 <report_grbl_settings+0x214>
    4884:	6b c0       	rjmp	.+214    	; 0x495c <report_grbl_settings+0x2ea>
    4886:	7f c0       	rjmp	.+254    	; 0x4986 <report_grbl_settings+0x314>
    4888:	ec 2f       	mov	r30, r28
    488a:	f0 e0       	ldi	r31, 0x00	; 0
    488c:	ee 0f       	add	r30, r30
    488e:	ff 1f       	adc	r31, r31
    4890:	ee 0f       	add	r30, r30
    4892:	ff 1f       	adc	r31, r31
    4894:	e1 51       	subi	r30, 0x11	; 17
    4896:	f9 4f       	sbci	r31, 0xF9	; 249
    4898:	60 81       	ld	r22, Z
    489a:	71 81       	ldd	r23, Z+1	; 0x01
    489c:	82 81       	ldd	r24, Z+2	; 0x02
    489e:	93 81       	ldd	r25, Z+3	; 0x03
    48a0:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    48a4:	8e e4       	ldi	r24, 0x4E	; 78
    48a6:	94 e0       	ldi	r25, 0x04	; 4
    48a8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    48ac:	c1 30       	cpi	r28, 0x01	; 1
    48ae:	09 f4       	brne	.+2      	; 0x48b2 <report_grbl_settings+0x240>
    48b0:	4f c0       	rjmp	.+158    	; 0x4950 <report_grbl_settings+0x2de>
    48b2:	08 f4       	brcc	.+2      	; 0x48b6 <report_grbl_settings+0x244>
    48b4:	47 c0       	rjmp	.+142    	; 0x4944 <report_grbl_settings+0x2d2>
    48b6:	c2 30       	cpi	r28, 0x02	; 2
    48b8:	09 f4       	brne	.+2      	; 0x48bc <report_grbl_settings+0x24a>
    48ba:	50 c0       	rjmp	.+160    	; 0x495c <report_grbl_settings+0x2ea>
    48bc:	72 c0       	rjmp	.+228    	; 0x49a2 <report_grbl_settings+0x330>
    48be:	ec 2f       	mov	r30, r28
    48c0:	f0 e0       	ldi	r31, 0x00	; 0
    48c2:	ee 0f       	add	r30, r30
    48c4:	ff 1f       	adc	r31, r31
    48c6:	ee 0f       	add	r30, r30
    48c8:	ff 1f       	adc	r31, r31
    48ca:	e5 50       	subi	r30, 0x05	; 5
    48cc:	f9 4f       	sbci	r31, 0xF9	; 249
    48ce:	20 e0       	ldi	r18, 0x00	; 0
    48d0:	30 e0       	ldi	r19, 0x00	; 0
    48d2:	41 e6       	ldi	r20, 0x61	; 97
    48d4:	55 e4       	ldi	r21, 0x45	; 69
    48d6:	60 81       	ld	r22, Z
    48d8:	71 81       	ldd	r23, Z+1	; 0x01
    48da:	82 81       	ldd	r24, Z+2	; 0x02
    48dc:	93 81       	ldd	r25, Z+3	; 0x03
    48de:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    48e2:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    48e6:	8e e4       	ldi	r24, 0x4E	; 78
    48e8:	94 e0       	ldi	r25, 0x04	; 4
    48ea:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    48ee:	c1 30       	cpi	r28, 0x01	; 1
    48f0:	79 f1       	breq	.+94     	; 0x4950 <report_grbl_settings+0x2de>
    48f2:	40 f1       	brcs	.+80     	; 0x4944 <report_grbl_settings+0x2d2>
    48f4:	c2 30       	cpi	r28, 0x02	; 2
    48f6:	91 f1       	breq	.+100    	; 0x495c <report_grbl_settings+0x2ea>
    48f8:	62 c0       	rjmp	.+196    	; 0x49be <report_grbl_settings+0x34c>
    48fa:	ec 2f       	mov	r30, r28
    48fc:	f0 e0       	ldi	r31, 0x00	; 0
    48fe:	ee 0f       	add	r30, r30
    4900:	ff 1f       	adc	r31, r31
    4902:	ee 0f       	add	r30, r30
    4904:	ff 1f       	adc	r31, r31
    4906:	e9 5f       	subi	r30, 0xF9	; 249
    4908:	f8 4f       	sbci	r31, 0xF8	; 248
    490a:	80 81       	ld	r24, Z
    490c:	91 81       	ldd	r25, Z+1	; 0x01
    490e:	a2 81       	ldd	r26, Z+2	; 0x02
    4910:	b3 81       	ldd	r27, Z+3	; 0x03
    4912:	bc 01       	movw	r22, r24
    4914:	cd 01       	movw	r24, r26
    4916:	90 58       	subi	r25, 0x80	; 128
    4918:	0e 94 1f 20 	call	0x403e	; 0x403e <printFloat_SettingValue>
    491c:	8e e4       	ldi	r24, 0x4E	; 78
    491e:	94 e0       	ldi	r25, 0x04	; 4
    4920:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4924:	c1 30       	cpi	r28, 0x01	; 1
    4926:	a1 f0       	breq	.+40     	; 0x4950 <report_grbl_settings+0x2de>
    4928:	68 f0       	brcs	.+26     	; 0x4944 <report_grbl_settings+0x2d2>
    492a:	c2 30       	cpi	r28, 0x02	; 2
    492c:	b9 f0       	breq	.+46     	; 0x495c <report_grbl_settings+0x2ea>
    492e:	55 c0       	rjmp	.+170    	; 0x49da <report_grbl_settings+0x368>
    4930:	8e e4       	ldi	r24, 0x4E	; 78
    4932:	94 e0       	ldi	r25, 0x04	; 4
    4934:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4938:	c1 30       	cpi	r28, 0x01	; 1
    493a:	51 f0       	breq	.+20     	; 0x4950 <report_grbl_settings+0x2de>
    493c:	18 f0       	brcs	.+6      	; 0x4944 <report_grbl_settings+0x2d2>
    493e:	c2 30       	cpi	r28, 0x02	; 2
    4940:	69 f0       	breq	.+26     	; 0x495c <report_grbl_settings+0x2ea>
    4942:	19 c0       	rjmp	.+50     	; 0x4976 <report_grbl_settings+0x304>
    4944:	8c e4       	ldi	r24, 0x4C	; 76
    4946:	94 e0       	ldi	r25, 0x04	; 4
    4948:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    494c:	c0 e0       	ldi	r28, 0x00	; 0
    494e:	66 c0       	rjmp	.+204    	; 0x4a1c <report_grbl_settings+0x3aa>
    4950:	8a e4       	ldi	r24, 0x4A	; 74
    4952:	94 e0       	ldi	r25, 0x04	; 4
    4954:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4958:	c1 e0       	ldi	r28, 0x01	; 1
    495a:	60 c0       	rjmp	.+192    	; 0x4a1c <report_grbl_settings+0x3aa>
    495c:	88 e4       	ldi	r24, 0x48	; 72
    495e:	94 e0       	ldi	r25, 0x04	; 4
    4960:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4964:	c2 e0       	ldi	r28, 0x02	; 2
    4966:	d1 30       	cpi	r29, 0x01	; 1
    4968:	d9 f0       	breq	.+54     	; 0x49a0 <report_grbl_settings+0x32e>
    496a:	68 f0       	brcs	.+26     	; 0x4986 <report_grbl_settings+0x314>
    496c:	d2 30       	cpi	r29, 0x02	; 2
    496e:	31 f1       	breq	.+76     	; 0x49bc <report_grbl_settings+0x34a>
    4970:	d3 30       	cpi	r29, 0x03	; 3
    4972:	91 f1       	breq	.+100    	; 0x49d8 <report_grbl_settings+0x366>
    4974:	90 c0       	rjmp	.+288    	; 0x4a96 <report_grbl_settings+0x424>
    4976:	d1 30       	cpi	r29, 0x01	; 1
    4978:	a1 f0       	breq	.+40     	; 0x49a2 <report_grbl_settings+0x330>
    497a:	28 f0       	brcs	.+10     	; 0x4986 <report_grbl_settings+0x314>
    497c:	d2 30       	cpi	r29, 0x02	; 2
    497e:	f9 f0       	breq	.+62     	; 0x49be <report_grbl_settings+0x34c>
    4980:	d3 30       	cpi	r29, 0x03	; 3
    4982:	b9 f5       	brne	.+110    	; 0x49f2 <report_grbl_settings+0x380>
    4984:	2a c0       	rjmp	.+84     	; 0x49da <report_grbl_settings+0x368>
    4986:	8e e3       	ldi	r24, 0x3E	; 62
    4988:	94 e0       	ldi	r25, 0x04	; 4
    498a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    498e:	87 e0       	ldi	r24, 0x07	; 7
    4990:	94 e0       	ldi	r25, 0x04	; 4
    4992:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4996:	cf 5f       	subi	r28, 0xFF	; 255
    4998:	c3 30       	cpi	r28, 0x03	; 3
    499a:	08 f4       	brcc	.+2      	; 0x499e <report_grbl_settings+0x32c>
    499c:	55 c0       	rjmp	.+170    	; 0x4a48 <report_grbl_settings+0x3d6>
    499e:	31 c0       	rjmp	.+98     	; 0x4a02 <report_grbl_settings+0x390>
    49a0:	c2 e0       	ldi	r28, 0x02	; 2
    49a2:	8c e2       	ldi	r24, 0x2C	; 44
    49a4:	94 e0       	ldi	r25, 0x04	; 4
    49a6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49aa:	87 e0       	ldi	r24, 0x07	; 7
    49ac:	94 e0       	ldi	r25, 0x04	; 4
    49ae:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49b2:	cf 5f       	subi	r28, 0xFF	; 255
    49b4:	c3 30       	cpi	r28, 0x03	; 3
    49b6:	08 f4       	brcc	.+2      	; 0x49ba <report_grbl_settings+0x348>
    49b8:	54 c0       	rjmp	.+168    	; 0x4a62 <report_grbl_settings+0x3f0>
    49ba:	23 c0       	rjmp	.+70     	; 0x4a02 <report_grbl_settings+0x390>
    49bc:	c2 e0       	ldi	r28, 0x02	; 2
    49be:	8b e1       	ldi	r24, 0x1B	; 27
    49c0:	94 e0       	ldi	r25, 0x04	; 4
    49c2:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49c6:	87 e0       	ldi	r24, 0x07	; 7
    49c8:	94 e0       	ldi	r25, 0x04	; 4
    49ca:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49ce:	cf 5f       	subi	r28, 0xFF	; 255
    49d0:	c3 30       	cpi	r28, 0x03	; 3
    49d2:	08 f4       	brcc	.+2      	; 0x49d6 <report_grbl_settings+0x364>
    49d4:	53 c0       	rjmp	.+166    	; 0x4a7c <report_grbl_settings+0x40a>
    49d6:	15 c0       	rjmp	.+42     	; 0x4a02 <report_grbl_settings+0x390>
    49d8:	c2 e0       	ldi	r28, 0x02	; 2
    49da:	8b e0       	ldi	r24, 0x0B	; 11
    49dc:	94 e0       	ldi	r25, 0x04	; 4
    49de:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49e2:	87 e0       	ldi	r24, 0x07	; 7
    49e4:	94 e0       	ldi	r25, 0x04	; 4
    49e6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49ea:	cf 5f       	subi	r28, 0xFF	; 255
    49ec:	c3 30       	cpi	r28, 0x03	; 3
    49ee:	f8 f0       	brcs	.+62     	; 0x4a2e <report_grbl_settings+0x3bc>
    49f0:	08 c0       	rjmp	.+16     	; 0x4a02 <report_grbl_settings+0x390>
    49f2:	87 e0       	ldi	r24, 0x07	; 7
    49f4:	94 e0       	ldi	r25, 0x04	; 4
    49f6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    49fa:	cf 5f       	subi	r28, 0xFF	; 255
    49fc:	c3 30       	cpi	r28, 0x03	; 3
    49fe:	08 f4       	brcc	.+2      	; 0x4a02 <report_grbl_settings+0x390>
    4a00:	13 cf       	rjmp	.-474    	; 0x4828 <report_grbl_settings+0x1b6>
    4a02:	16 5f       	subi	r17, 0xF6	; 246
    4a04:	df 5f       	subi	r29, 0xFF	; 255
    4a06:	1c 38       	cpi	r17, 0x8C	; 140
    4a08:	09 f4       	brne	.+2      	; 0x4a0c <report_grbl_settings+0x39a>
    4a0a:	4a c0       	rjmp	.+148    	; 0x4aa0 <report_grbl_settings+0x42e>
    4a0c:	c0 e0       	ldi	r28, 0x00	; 0
    4a0e:	0c cf       	rjmp	.-488    	; 0x4828 <report_grbl_settings+0x1b6>
    4a10:	87 e0       	ldi	r24, 0x07	; 7
    4a12:	94 e0       	ldi	r25, 0x04	; 4
    4a14:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a18:	cf 5f       	subi	r28, 0xFF	; 255
    4a1a:	06 cf       	rjmp	.-500    	; 0x4828 <report_grbl_settings+0x1b6>
    4a1c:	d1 30       	cpi	r29, 0x01	; 1
    4a1e:	09 f2       	breq	.-126    	; 0x49a2 <report_grbl_settings+0x330>
    4a20:	08 f4       	brcc	.+2      	; 0x4a24 <report_grbl_settings+0x3b2>
    4a22:	b1 cf       	rjmp	.-158    	; 0x4986 <report_grbl_settings+0x314>
    4a24:	d2 30       	cpi	r29, 0x02	; 2
    4a26:	59 f2       	breq	.-106    	; 0x49be <report_grbl_settings+0x34c>
    4a28:	d3 30       	cpi	r29, 0x03	; 3
    4a2a:	91 f7       	brne	.-28     	; 0x4a10 <report_grbl_settings+0x39e>
    4a2c:	d6 cf       	rjmp	.-84     	; 0x49da <report_grbl_settings+0x368>
    4a2e:	83 e5       	ldi	r24, 0x53	; 83
    4a30:	94 e0       	ldi	r25, 0x04	; 4
    4a32:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a36:	81 2f       	mov	r24, r17
    4a38:	8c 0f       	add	r24, r28
    4a3a:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4a3e:	81 e5       	ldi	r24, 0x51	; 81
    4a40:	94 e0       	ldi	r25, 0x04	; 4
    4a42:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a46:	59 cf       	rjmp	.-334    	; 0x48fa <report_grbl_settings+0x288>
    4a48:	83 e5       	ldi	r24, 0x53	; 83
    4a4a:	94 e0       	ldi	r25, 0x04	; 4
    4a4c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a50:	81 2f       	mov	r24, r17
    4a52:	8c 0f       	add	r24, r28
    4a54:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4a58:	81 e5       	ldi	r24, 0x51	; 81
    4a5a:	94 e0       	ldi	r25, 0x04	; 4
    4a5c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a60:	f8 ce       	rjmp	.-528    	; 0x4852 <report_grbl_settings+0x1e0>
    4a62:	83 e5       	ldi	r24, 0x53	; 83
    4a64:	94 e0       	ldi	r25, 0x04	; 4
    4a66:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a6a:	81 2f       	mov	r24, r17
    4a6c:	8c 0f       	add	r24, r28
    4a6e:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4a72:	81 e5       	ldi	r24, 0x51	; 81
    4a74:	94 e0       	ldi	r25, 0x04	; 4
    4a76:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a7a:	06 cf       	rjmp	.-500    	; 0x4888 <report_grbl_settings+0x216>
    4a7c:	83 e5       	ldi	r24, 0x53	; 83
    4a7e:	94 e0       	ldi	r25, 0x04	; 4
    4a80:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a84:	81 2f       	mov	r24, r17
    4a86:	8c 0f       	add	r24, r28
    4a88:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4a8c:	81 e5       	ldi	r24, 0x51	; 81
    4a8e:	94 e0       	ldi	r25, 0x04	; 4
    4a90:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a94:	14 cf       	rjmp	.-472    	; 0x48be <report_grbl_settings+0x24c>
    4a96:	87 e0       	ldi	r24, 0x07	; 7
    4a98:	94 e0       	ldi	r25, 0x04	; 4
    4a9a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4a9e:	b1 cf       	rjmp	.-158    	; 0x4a02 <report_grbl_settings+0x390>
    4aa0:	df 91       	pop	r29
    4aa2:	cf 91       	pop	r28
    4aa4:	1f 91       	pop	r17
    4aa6:	08 95       	ret

00004aa8 <report_probe_parameters>:
    4aa8:	cf 93       	push	r28
    4aaa:	81 e0       	ldi	r24, 0x01	; 1
    4aac:	94 e0       	ldi	r25, 0x04	; 4
    4aae:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ab2:	c0 e0       	ldi	r28, 0x00	; 0
    4ab4:	6c 2f       	mov	r22, r28
    4ab6:	84 e1       	ldi	r24, 0x14	; 20
    4ab8:	96 e0       	ldi	r25, 0x06	; 6
    4aba:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <system_convert_axis_steps_to_mpos>
    4abe:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
    4ac2:	c2 30       	cpi	r28, 0x02	; 2
    4ac4:	20 f4       	brcc	.+8      	; 0x4ace <report_probe_parameters+0x26>
    4ac6:	8f ef       	ldi	r24, 0xFF	; 255
    4ac8:	93 e0       	ldi	r25, 0x03	; 3
    4aca:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ace:	cf 5f       	subi	r28, 0xFF	; 255
    4ad0:	c3 30       	cpi	r28, 0x03	; 3
    4ad2:	81 f7       	brne	.-32     	; 0x4ab4 <report_probe_parameters+0xc>
    4ad4:	8d ef       	ldi	r24, 0xFD	; 253
    4ad6:	93 e0       	ldi	r25, 0x03	; 3
    4ad8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4adc:	80 91 20 06 	lds	r24, 0x0620	; 0x800620 <sys+0x1c>
    4ae0:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4ae4:	89 ef       	ldi	r24, 0xF9	; 249
    4ae6:	93 e0       	ldi	r25, 0x03	; 3
    4ae8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4aec:	cf 91       	pop	r28
    4aee:	08 95       	ret

00004af0 <report_ngc_parameters>:
    4af0:	ef 92       	push	r14
    4af2:	ff 92       	push	r15
    4af4:	0f 93       	push	r16
    4af6:	1f 93       	push	r17
    4af8:	cf 93       	push	r28
    4afa:	df 93       	push	r29
    4afc:	cd b7       	in	r28, 0x3d	; 61
    4afe:	de b7       	in	r29, 0x3e	; 62
    4b00:	2c 97       	sbiw	r28, 0x0c	; 12
    4b02:	0f b6       	in	r0, 0x3f	; 63
    4b04:	f8 94       	cli
    4b06:	de bf       	out	0x3e, r29	; 62
    4b08:	0f be       	out	0x3f, r0	; 63
    4b0a:	cd bf       	out	0x3d, r28	; 61
    4b0c:	00 e0       	ldi	r16, 0x00	; 0
    4b0e:	be 01       	movw	r22, r28
    4b10:	6f 5f       	subi	r22, 0xFF	; 255
    4b12:	7f 4f       	sbci	r23, 0xFF	; 255
    4b14:	80 2f       	mov	r24, r16
    4b16:	0e 94 13 2a 	call	0x5426	; 0x5426 <settings_read_coord_data>
    4b1a:	81 11       	cpse	r24, r1
    4b1c:	04 c0       	rjmp	.+8      	; 0x4b26 <report_ngc_parameters+0x36>
    4b1e:	87 e0       	ldi	r24, 0x07	; 7
    4b20:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    4b24:	6e c0       	rjmp	.+220    	; 0x4c02 <report_ngc_parameters+0x112>
    4b26:	86 ef       	ldi	r24, 0xF6	; 246
    4b28:	93 e0       	ldi	r25, 0x03	; 3
    4b2a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b2e:	06 30       	cpi	r16, 0x06	; 6
    4b30:	19 f0       	breq	.+6      	; 0x4b38 <report_ngc_parameters+0x48>
    4b32:	07 30       	cpi	r16, 0x07	; 7
    4b34:	31 f0       	breq	.+12     	; 0x4b42 <report_ngc_parameters+0x52>
    4b36:	0a c0       	rjmp	.+20     	; 0x4b4c <report_ngc_parameters+0x5c>
    4b38:	83 ef       	ldi	r24, 0xF3	; 243
    4b3a:	93 e0       	ldi	r25, 0x03	; 3
    4b3c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b40:	09 c0       	rjmp	.+18     	; 0x4b54 <report_ngc_parameters+0x64>
    4b42:	80 ef       	ldi	r24, 0xF0	; 240
    4b44:	93 e0       	ldi	r25, 0x03	; 3
    4b46:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b4a:	04 c0       	rjmp	.+8      	; 0x4b54 <report_ngc_parameters+0x64>
    4b4c:	86 e3       	ldi	r24, 0x36	; 54
    4b4e:	80 0f       	add	r24, r16
    4b50:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4b54:	8e ee       	ldi	r24, 0xEE	; 238
    4b56:	93 e0       	ldi	r25, 0x03	; 3
    4b58:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b5c:	ce 01       	movw	r24, r28
    4b5e:	01 96       	adiw	r24, 0x01	; 1
    4b60:	7c 01       	movw	r14, r24
    4b62:	10 e0       	ldi	r17, 0x00	; 0
    4b64:	f7 01       	movw	r30, r14
    4b66:	61 91       	ld	r22, Z+
    4b68:	71 91       	ld	r23, Z+
    4b6a:	81 91       	ld	r24, Z+
    4b6c:	91 91       	ld	r25, Z+
    4b6e:	7f 01       	movw	r14, r30
    4b70:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
    4b74:	12 30       	cpi	r17, 0x02	; 2
    4b76:	28 f4       	brcc	.+10     	; 0x4b82 <report_ngc_parameters+0x92>
    4b78:	8c ee       	ldi	r24, 0xEC	; 236
    4b7a:	93 e0       	ldi	r25, 0x03	; 3
    4b7c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b80:	04 c0       	rjmp	.+8      	; 0x4b8a <report_ngc_parameters+0x9a>
    4b82:	88 ee       	ldi	r24, 0xE8	; 232
    4b84:	93 e0       	ldi	r25, 0x03	; 3
    4b86:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4b8a:	1f 5f       	subi	r17, 0xFF	; 255
    4b8c:	13 30       	cpi	r17, 0x03	; 3
    4b8e:	51 f7       	brne	.-44     	; 0x4b64 <report_ngc_parameters+0x74>
    4b90:	0f 5f       	subi	r16, 0xFF	; 255
    4b92:	08 30       	cpi	r16, 0x08	; 8
    4b94:	09 f0       	breq	.+2      	; 0x4b98 <report_ngc_parameters+0xa8>
    4b96:	bb cf       	rjmp	.-138    	; 0x4b0e <report_ngc_parameters+0x1e>
    4b98:	82 ee       	ldi	r24, 0xE2	; 226
    4b9a:	93 e0       	ldi	r25, 0x03	; 3
    4b9c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ba0:	0f 2e       	mov	r0, r31
    4ba2:	fb eb       	ldi	r31, 0xBB	; 187
    4ba4:	ef 2e       	mov	r14, r31
    4ba6:	f5 e0       	ldi	r31, 0x05	; 5
    4ba8:	ff 2e       	mov	r15, r31
    4baa:	f0 2d       	mov	r31, r0
    4bac:	10 e0       	ldi	r17, 0x00	; 0
    4bae:	f7 01       	movw	r30, r14
    4bb0:	61 91       	ld	r22, Z+
    4bb2:	71 91       	ld	r23, Z+
    4bb4:	81 91       	ld	r24, Z+
    4bb6:	91 91       	ld	r25, Z+
    4bb8:	7f 01       	movw	r14, r30
    4bba:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
    4bbe:	12 30       	cpi	r17, 0x02	; 2
    4bc0:	28 f4       	brcc	.+10     	; 0x4bcc <report_ngc_parameters+0xdc>
    4bc2:	80 ee       	ldi	r24, 0xE0	; 224
    4bc4:	93 e0       	ldi	r25, 0x03	; 3
    4bc6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4bca:	04 c0       	rjmp	.+8      	; 0x4bd4 <report_ngc_parameters+0xe4>
    4bcc:	8c ed       	ldi	r24, 0xDC	; 220
    4bce:	93 e0       	ldi	r25, 0x03	; 3
    4bd0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4bd4:	1f 5f       	subi	r17, 0xFF	; 255
    4bd6:	13 30       	cpi	r17, 0x03	; 3
    4bd8:	51 f7       	brne	.-44     	; 0x4bae <report_ngc_parameters+0xbe>
    4bda:	86 ed       	ldi	r24, 0xD6	; 214
    4bdc:	93 e0       	ldi	r25, 0x03	; 3
    4bde:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4be2:	60 91 c7 05 	lds	r22, 0x05C7	; 0x8005c7 <gc_state+0x3b>
    4be6:	70 91 c8 05 	lds	r23, 0x05C8	; 0x8005c8 <gc_state+0x3c>
    4bea:	80 91 c9 05 	lds	r24, 0x05C9	; 0x8005c9 <gc_state+0x3d>
    4bee:	90 91 ca 05 	lds	r25, 0x05CA	; 0x8005ca <gc_state+0x3e>
    4bf2:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
    4bf6:	82 ed       	ldi	r24, 0xD2	; 210
    4bf8:	93 e0       	ldi	r25, 0x03	; 3
    4bfa:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4bfe:	0e 94 54 25 	call	0x4aa8	; 0x4aa8 <report_probe_parameters>
    4c02:	2c 96       	adiw	r28, 0x0c	; 12
    4c04:	0f b6       	in	r0, 0x3f	; 63
    4c06:	f8 94       	cli
    4c08:	de bf       	out	0x3e, r29	; 62
    4c0a:	0f be       	out	0x3f, r0	; 63
    4c0c:	cd bf       	out	0x3d, r28	; 61
    4c0e:	df 91       	pop	r29
    4c10:	cf 91       	pop	r28
    4c12:	1f 91       	pop	r17
    4c14:	0f 91       	pop	r16
    4c16:	ff 90       	pop	r15
    4c18:	ef 90       	pop	r14
    4c1a:	08 95       	ret

00004c1c <report_gcode_modes>:
    4c1c:	cf 93       	push	r28
    4c1e:	df 93       	push	r29
    4c20:	80 ed       	ldi	r24, 0xD0	; 208
    4c22:	93 e0       	ldi	r25, 0x03	; 3
    4c24:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c28:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <gc_state>
    4c2c:	82 30       	cpi	r24, 0x02	; 2
    4c2e:	a9 f0       	breq	.+42     	; 0x4c5a <report_gcode_modes+0x3e>
    4c30:	28 f4       	brcc	.+10     	; 0x4c3c <report_gcode_modes+0x20>
    4c32:	88 23       	and	r24, r24
    4c34:	41 f0       	breq	.+16     	; 0x4c46 <report_gcode_modes+0x2a>
    4c36:	81 30       	cpi	r24, 0x01	; 1
    4c38:	59 f0       	breq	.+22     	; 0x4c50 <report_gcode_modes+0x34>
    4c3a:	1e c0       	rjmp	.+60     	; 0x4c78 <report_gcode_modes+0x5c>
    4c3c:	83 30       	cpi	r24, 0x03	; 3
    4c3e:	91 f0       	breq	.+36     	; 0x4c64 <report_gcode_modes+0x48>
    4c40:	88 30       	cpi	r24, 0x08	; 8
    4c42:	a9 f0       	breq	.+42     	; 0x4c6e <report_gcode_modes+0x52>
    4c44:	19 c0       	rjmp	.+50     	; 0x4c78 <report_gcode_modes+0x5c>
    4c46:	8d ec       	ldi	r24, 0xCD	; 205
    4c48:	93 e0       	ldi	r25, 0x03	; 3
    4c4a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c4e:	1d c0       	rjmp	.+58     	; 0x4c8a <report_gcode_modes+0x6e>
    4c50:	8a ec       	ldi	r24, 0xCA	; 202
    4c52:	93 e0       	ldi	r25, 0x03	; 3
    4c54:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c58:	18 c0       	rjmp	.+48     	; 0x4c8a <report_gcode_modes+0x6e>
    4c5a:	87 ec       	ldi	r24, 0xC7	; 199
    4c5c:	93 e0       	ldi	r25, 0x03	; 3
    4c5e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c62:	13 c0       	rjmp	.+38     	; 0x4c8a <report_gcode_modes+0x6e>
    4c64:	84 ec       	ldi	r24, 0xC4	; 196
    4c66:	93 e0       	ldi	r25, 0x03	; 3
    4c68:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c6c:	0e c0       	rjmp	.+28     	; 0x4c8a <report_gcode_modes+0x6e>
    4c6e:	80 ec       	ldi	r24, 0xC0	; 192
    4c70:	93 e0       	ldi	r25, 0x03	; 3
    4c72:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c76:	09 c0       	rjmp	.+18     	; 0x4c8a <report_gcode_modes+0x6e>
    4c78:	8b eb       	ldi	r24, 0xBB	; 187
    4c7a:	93 e0       	ldi	r25, 0x03	; 3
    4c7c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c80:	80 91 8c 05 	lds	r24, 0x058C	; 0x80058c <gc_state>
    4c84:	82 50       	subi	r24, 0x02	; 2
    4c86:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4c8a:	88 eb       	ldi	r24, 0xB8	; 184
    4c8c:	93 e0       	ldi	r25, 0x03	; 3
    4c8e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4c92:	cc e8       	ldi	r28, 0x8C	; 140
    4c94:	d5 e0       	ldi	r29, 0x05	; 5
    4c96:	8e 81       	ldd	r24, Y+6	; 0x06
    4c98:	8a 5c       	subi	r24, 0xCA	; 202
    4c9a:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4c9e:	8c 81       	ldd	r24, Y+4	; 0x04
    4ca0:	81 30       	cpi	r24, 0x01	; 1
    4ca2:	49 f0       	breq	.+18     	; 0x4cb6 <report_gcode_modes+0x9a>
    4ca4:	18 f0       	brcs	.+6      	; 0x4cac <report_gcode_modes+0x90>
    4ca6:	82 30       	cpi	r24, 0x02	; 2
    4ca8:	59 f0       	breq	.+22     	; 0x4cc0 <report_gcode_modes+0xa4>
    4caa:	0e c0       	rjmp	.+28     	; 0x4cc8 <report_gcode_modes+0xac>
    4cac:	83 eb       	ldi	r24, 0xB3	; 179
    4cae:	93 e0       	ldi	r25, 0x03	; 3
    4cb0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cb4:	09 c0       	rjmp	.+18     	; 0x4cc8 <report_gcode_modes+0xac>
    4cb6:	8e ea       	ldi	r24, 0xAE	; 174
    4cb8:	93 e0       	ldi	r25, 0x03	; 3
    4cba:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cbe:	04 c0       	rjmp	.+8      	; 0x4cc8 <report_gcode_modes+0xac>
    4cc0:	89 ea       	ldi	r24, 0xA9	; 169
    4cc2:	93 e0       	ldi	r25, 0x03	; 3
    4cc4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cc8:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <gc_state+0x2>
    4ccc:	81 11       	cpse	r24, r1
    4cce:	05 c0       	rjmp	.+10     	; 0x4cda <report_gcode_modes+0xbe>
    4cd0:	84 ea       	ldi	r24, 0xA4	; 164
    4cd2:	93 e0       	ldi	r25, 0x03	; 3
    4cd4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cd8:	04 c0       	rjmp	.+8      	; 0x4ce2 <report_gcode_modes+0xc6>
    4cda:	8f e9       	ldi	r24, 0x9F	; 159
    4cdc:	93 e0       	ldi	r25, 0x03	; 3
    4cde:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ce2:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <gc_state+0x3>
    4ce6:	81 11       	cpse	r24, r1
    4ce8:	05 c0       	rjmp	.+10     	; 0x4cf4 <report_gcode_modes+0xd8>
    4cea:	8a e9       	ldi	r24, 0x9A	; 154
    4cec:	93 e0       	ldi	r25, 0x03	; 3
    4cee:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cf2:	04 c0       	rjmp	.+8      	; 0x4cfc <report_gcode_modes+0xe0>
    4cf4:	85 e9       	ldi	r24, 0x95	; 149
    4cf6:	93 e0       	ldi	r25, 0x03	; 3
    4cf8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4cfc:	80 91 8d 05 	lds	r24, 0x058D	; 0x80058d <gc_state+0x1>
    4d00:	81 30       	cpi	r24, 0x01	; 1
    4d02:	29 f4       	brne	.+10     	; 0x4d0e <report_gcode_modes+0xf2>
    4d04:	80 e9       	ldi	r24, 0x90	; 144
    4d06:	93 e0       	ldi	r25, 0x03	; 3
    4d08:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d0c:	04 c0       	rjmp	.+8      	; 0x4d16 <report_gcode_modes+0xfa>
    4d0e:	8b e8       	ldi	r24, 0x8B	; 139
    4d10:	93 e0       	ldi	r25, 0x03	; 3
    4d12:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d16:	80 91 93 05 	lds	r24, 0x0593	; 0x800593 <gc_state+0x7>
    4d1a:	81 30       	cpi	r24, 0x01	; 1
    4d1c:	49 f0       	breq	.+18     	; 0x4d30 <report_gcode_modes+0x114>
    4d1e:	18 f0       	brcs	.+6      	; 0x4d26 <report_gcode_modes+0x10a>
    4d20:	82 30       	cpi	r24, 0x02	; 2
    4d22:	59 f0       	breq	.+22     	; 0x4d3a <report_gcode_modes+0x11e>
    4d24:	0e c0       	rjmp	.+28     	; 0x4d42 <report_gcode_modes+0x126>
    4d26:	87 e8       	ldi	r24, 0x87	; 135
    4d28:	93 e0       	ldi	r25, 0x03	; 3
    4d2a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d2e:	09 c0       	rjmp	.+18     	; 0x4d42 <report_gcode_modes+0x126>
    4d30:	83 e8       	ldi	r24, 0x83	; 131
    4d32:	93 e0       	ldi	r25, 0x03	; 3
    4d34:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d38:	04 c0       	rjmp	.+8      	; 0x4d42 <report_gcode_modes+0x126>
    4d3a:	8f e7       	ldi	r24, 0x7F	; 127
    4d3c:	93 e0       	ldi	r25, 0x03	; 3
    4d3e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d42:	80 91 95 05 	lds	r24, 0x0595	; 0x800595 <gc_state+0x9>
    4d46:	81 30       	cpi	r24, 0x01	; 1
    4d48:	21 f0       	breq	.+8      	; 0x4d52 <report_gcode_modes+0x136>
    4d4a:	68 f0       	brcs	.+26     	; 0x4d66 <report_gcode_modes+0x14a>
    4d4c:	82 30       	cpi	r24, 0x02	; 2
    4d4e:	31 f0       	breq	.+12     	; 0x4d5c <report_gcode_modes+0x140>
    4d50:	0e c0       	rjmp	.+28     	; 0x4d6e <report_gcode_modes+0x152>
    4d52:	8b e7       	ldi	r24, 0x7B	; 123
    4d54:	93 e0       	ldi	r25, 0x03	; 3
    4d56:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d5a:	09 c0       	rjmp	.+18     	; 0x4d6e <report_gcode_modes+0x152>
    4d5c:	87 e7       	ldi	r24, 0x77	; 119
    4d5e:	93 e0       	ldi	r25, 0x03	; 3
    4d60:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d64:	04 c0       	rjmp	.+8      	; 0x4d6e <report_gcode_modes+0x152>
    4d66:	83 e7       	ldi	r24, 0x73	; 115
    4d68:	93 e0       	ldi	r25, 0x03	; 3
    4d6a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d6e:	80 91 94 05 	lds	r24, 0x0594	; 0x800594 <gc_state+0x8>
    4d72:	88 23       	and	r24, r24
    4d74:	19 f0       	breq	.+6      	; 0x4d7c <report_gcode_modes+0x160>
    4d76:	82 30       	cpi	r24, 0x02	; 2
    4d78:	31 f0       	breq	.+12     	; 0x4d86 <report_gcode_modes+0x16a>
    4d7a:	09 c0       	rjmp	.+18     	; 0x4d8e <report_gcode_modes+0x172>
    4d7c:	8f e6       	ldi	r24, 0x6F	; 111
    4d7e:	93 e0       	ldi	r25, 0x03	; 3
    4d80:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d84:	04 c0       	rjmp	.+8      	; 0x4d8e <report_gcode_modes+0x172>
    4d86:	8b e6       	ldi	r24, 0x6B	; 107
    4d88:	93 e0       	ldi	r25, 0x03	; 3
    4d8a:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d8e:	88 e6       	ldi	r24, 0x68	; 104
    4d90:	93 e0       	ldi	r25, 0x03	; 3
    4d92:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4d96:	cc e8       	ldi	r28, 0x8C	; 140
    4d98:	d5 e0       	ldi	r29, 0x05	; 5
    4d9a:	8a 89       	ldd	r24, Y+18	; 0x12
    4d9c:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4da0:	85 e6       	ldi	r24, 0x65	; 101
    4da2:	93 e0       	ldi	r25, 0x03	; 3
    4da4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4da8:	6e 85       	ldd	r22, Y+14	; 0x0e
    4daa:	7f 85       	ldd	r23, Y+15	; 0x0f
    4dac:	88 89       	ldd	r24, Y+16	; 0x10
    4dae:	99 89       	ldd	r25, Y+17	; 0x11
    4db0:	0e 94 0d 20 	call	0x401a	; 0x401a <printFloat_RateValue>
    4db4:	82 e6       	ldi	r24, 0x62	; 98
    4db6:	93 e0       	ldi	r25, 0x03	; 3
    4db8:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4dbc:	6a 85       	ldd	r22, Y+10	; 0x0a
    4dbe:	7b 85       	ldd	r23, Y+11	; 0x0b
    4dc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    4dc2:	9d 85       	ldd	r25, Y+13	; 0x0d
    4dc4:	0e 94 0d 20 	call	0x401a	; 0x401a <printFloat_RateValue>
    4dc8:	8e e5       	ldi	r24, 0x5E	; 94
    4dca:	93 e0       	ldi	r25, 0x03	; 3
    4dcc:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4dd0:	df 91       	pop	r29
    4dd2:	cf 91       	pop	r28
    4dd4:	08 95       	ret

00004dd6 <report_startup_line>:
    4dd6:	1f 93       	push	r17
    4dd8:	cf 93       	push	r28
    4dda:	df 93       	push	r29
    4ddc:	18 2f       	mov	r17, r24
    4dde:	eb 01       	movw	r28, r22
    4de0:	8b e5       	ldi	r24, 0x5B	; 91
    4de2:	93 e0       	ldi	r25, 0x03	; 3
    4de4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4de8:	81 2f       	mov	r24, r17
    4dea:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    4dee:	89 e5       	ldi	r24, 0x59	; 89
    4df0:	93 e0       	ldi	r25, 0x03	; 3
    4df2:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4df6:	ce 01       	movw	r24, r28
    4df8:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <printString>
    4dfc:	86 e5       	ldi	r24, 0x56	; 86
    4dfe:	93 e0       	ldi	r25, 0x03	; 3
    4e00:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e04:	df 91       	pop	r29
    4e06:	cf 91       	pop	r28
    4e08:	1f 91       	pop	r17
    4e0a:	08 95       	ret

00004e0c <report_build_info>:
    4e0c:	cf 93       	push	r28
    4e0e:	df 93       	push	r29
    4e10:	ec 01       	movw	r28, r24
    4e12:	86 e4       	ldi	r24, 0x46	; 70
    4e14:	93 e0       	ldi	r25, 0x03	; 3
    4e16:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e1a:	ce 01       	movw	r24, r28
    4e1c:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <printString>
    4e20:	82 e4       	ldi	r24, 0x42	; 66
    4e22:	93 e0       	ldi	r25, 0x03	; 3
    4e24:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e28:	df 91       	pop	r29
    4e2a:	cf 91       	pop	r28
    4e2c:	08 95       	ret

00004e2e <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly, 
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    4e2e:	af 92       	push	r10
    4e30:	bf 92       	push	r11
    4e32:	cf 92       	push	r12
    4e34:	df 92       	push	r13
    4e36:	ff 92       	push	r15
    4e38:	0f 93       	push	r16
    4e3a:	1f 93       	push	r17
    4e3c:	cf 93       	push	r28
    4e3e:	df 93       	push	r29
    4e40:	cd b7       	in	r28, 0x3d	; 61
    4e42:	de b7       	in	r29, 0x3e	; 62
    4e44:	68 97       	sbiw	r28, 0x18	; 24
    4e46:	0f b6       	in	r0, 0x3f	; 63
    4e48:	f8 94       	cli
    4e4a:	de bf       	out	0x3e, r29	; 62
    4e4c:	0f be       	out	0x3f, r0	; 63
    4e4e:	cd bf       	out	0x3d, r28	; 61
  // the system power on location (0,0,0) and work coordinate position (G54 and G92 applied). Eventually
  // to be added are distance to go on block, processed block id, and feed rate. Also a settings bitmask
  // for a user to select the desired real-time data.
  uint8_t idx;
  int32_t current_position[N_AXIS]; // Copy current state of the system position variable
  memcpy(current_position,sys.position,sizeof(sys.position));
    4e50:	8c e0       	ldi	r24, 0x0C	; 12
    4e52:	e8 e0       	ldi	r30, 0x08	; 8
    4e54:	f6 e0       	ldi	r31, 0x06	; 6
    4e56:	de 01       	movw	r26, r28
    4e58:	11 96       	adiw	r26, 0x01	; 1
    4e5a:	01 90       	ld	r0, Z+
    4e5c:	0d 92       	st	X+, r0
    4e5e:	8a 95       	dec	r24
    4e60:	e1 f7       	brne	.-8      	; 0x4e5a <report_realtime_status+0x2c>
  float print_position[N_AXIS];
 
  // Report current machine state
  switch (sys.state) {
    4e62:	e0 91 05 06 	lds	r30, 0x0605	; 0x800605 <sys+0x1>
    4e66:	8e 2f       	mov	r24, r30
    4e68:	90 e0       	ldi	r25, 0x00	; 0
    4e6a:	81 34       	cpi	r24, 0x41	; 65
    4e6c:	91 05       	cpc	r25, r1
    4e6e:	38 f5       	brcc	.+78     	; 0x4ebe <report_realtime_status+0x90>
    4e70:	fc 01       	movw	r30, r24
    4e72:	eb 50       	subi	r30, 0x0B	; 11
    4e74:	ff 4f       	sbci	r31, 0xFF	; 255
    4e76:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
    case STATE_IDLE: printPgmString(PSTR("<Idle")); break;
    4e7a:	8c e3       	ldi	r24, 0x3C	; 60
    4e7c:	93 e0       	ldi	r25, 0x03	; 3
    4e7e:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e82:	1d c0       	rjmp	.+58     	; 0x4ebe <report_realtime_status+0x90>
    case STATE_MOTION_CANCEL: // Report run state.
    case STATE_CYCLE: printPgmString(PSTR("<Run")); break;
    4e84:	87 e3       	ldi	r24, 0x37	; 55
    4e86:	93 e0       	ldi	r25, 0x03	; 3
    4e88:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e8c:	18 c0       	rjmp	.+48     	; 0x4ebe <report_realtime_status+0x90>
    case STATE_HOLD: printPgmString(PSTR("<Hold")); break;
    4e8e:	81 e3       	ldi	r24, 0x31	; 49
    4e90:	93 e0       	ldi	r25, 0x03	; 3
    4e92:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4e96:	13 c0       	rjmp	.+38     	; 0x4ebe <report_realtime_status+0x90>
    case STATE_HOMING: printPgmString(PSTR("<Home")); break;
    4e98:	8b e2       	ldi	r24, 0x2B	; 43
    4e9a:	93 e0       	ldi	r25, 0x03	; 3
    4e9c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ea0:	0e c0       	rjmp	.+28     	; 0x4ebe <report_realtime_status+0x90>
    case STATE_ALARM: printPgmString(PSTR("<Alarm")); break;
    4ea2:	84 e2       	ldi	r24, 0x24	; 36
    4ea4:	93 e0       	ldi	r25, 0x03	; 3
    4ea6:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4eaa:	09 c0       	rjmp	.+18     	; 0x4ebe <report_realtime_status+0x90>
    case STATE_CHECK_MODE: printPgmString(PSTR("<Check")); break;
    4eac:	8d e1       	ldi	r24, 0x1D	; 29
    4eae:	93 e0       	ldi	r25, 0x03	; 3
    4eb0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4eb4:	04 c0       	rjmp	.+8      	; 0x4ebe <report_realtime_status+0x90>
    case STATE_SAFETY_DOOR: printPgmString(PSTR("<Door")); break;
    4eb6:	87 e1       	ldi	r24, 0x17	; 23
    4eb8:	93 e0       	ldi	r25, 0x03	; 3
    4eba:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
  }
 
  // If reporting a position, convert the current step count (current_position) to millimeters.
  if (bit_istrue(settings.status_report_mask,(BITFLAG_RT_STATUS_MACHINE_POSITION | BITFLAG_RT_STATUS_WORK_POSITION))) {
    4ebe:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4ec2:	83 70       	andi	r24, 0x03	; 3
    4ec4:	39 f0       	breq	.+14     	; 0x4ed4 <report_realtime_status+0xa6>
    system_convert_array_steps_to_mpos(print_position,current_position);
    4ec6:	be 01       	movw	r22, r28
    4ec8:	6f 5f       	subi	r22, 0xFF	; 255
    4eca:	7f 4f       	sbci	r23, 0xFF	; 255
    4ecc:	ce 01       	movw	r24, r28
    4ece:	0d 96       	adiw	r24, 0x0d	; 13
    4ed0:	0e 94 97 38 	call	0x712e	; 0x712e <system_convert_array_steps_to_mpos>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    4ed4:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4ed8:	80 ff       	sbrs	r24, 0
    4eda:	1a c0       	rjmp	.+52     	; 0x4f10 <report_realtime_status+0xe2>
    printPgmString(PSTR(",MPos:")); 
    4edc:	80 e1       	ldi	r24, 0x10	; 16
    4ede:	93 e0       	ldi	r25, 0x03	; 3
    4ee0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4ee4:	6e 01       	movw	r12, r28
    4ee6:	2d e0       	ldi	r18, 0x0D	; 13
    4ee8:	c2 0e       	add	r12, r18
    4eea:	d1 1c       	adc	r13, r1
    for (idx=0; idx< N_AXIS; idx++) {
    4eec:	10 e0       	ldi	r17, 0x00	; 0
      printFloat_CoordValue(print_position[idx]);
    4eee:	f6 01       	movw	r30, r12
    4ef0:	61 91       	ld	r22, Z+
    4ef2:	71 91       	ld	r23, Z+
    4ef4:	81 91       	ld	r24, Z+
    4ef6:	91 91       	ld	r25, Z+
    4ef8:	6f 01       	movw	r12, r30
    4efa:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4efe:	12 30       	cpi	r17, 0x02	; 2
    4f00:	20 f4       	brcc	.+8      	; 0x4f0a <report_realtime_status+0xdc>
    4f02:	8e e0       	ldi	r24, 0x0E	; 14
    4f04:	93 e0       	ldi	r25, 0x03	; 3
    4f06:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
  }
  
  // Report machine position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_MACHINE_POSITION)) {
    printPgmString(PSTR(",MPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4f0a:	1f 5f       	subi	r17, 0xFF	; 255
    4f0c:	13 30       	cpi	r17, 0x03	; 3
    4f0e:	79 f7       	brne	.-34     	; 0x4eee <report_realtime_status+0xc0>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    4f10:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4f14:	81 ff       	sbrs	r24, 1
    4f16:	4c c0       	rjmp	.+152    	; 0x4fb0 <report_realtime_status+0x182>
    printPgmString(PSTR(",WPos:")); 
    4f18:	87 e0       	ldi	r24, 0x07	; 7
    4f1a:	93 e0       	ldi	r25, 0x03	; 3
    4f1c:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    4f20:	8e 01       	movw	r16, r28
    4f22:	03 5f       	subi	r16, 0xF3	; 243
    4f24:	1f 4f       	sbci	r17, 0xFF	; 255
    4f26:	0f 2e       	mov	r0, r31
    4f28:	ff ea       	ldi	r31, 0xAF	; 175
    4f2a:	cf 2e       	mov	r12, r31
    4f2c:	f5 e0       	ldi	r31, 0x05	; 5
    4f2e:	df 2e       	mov	r13, r31
    4f30:	f0 2d       	mov	r31, r0
    for (idx=0; idx< N_AXIS; idx++) {
    4f32:	f1 2c       	mov	r15, r1
      // Apply work coordinate offsets and tool length offset to current position.
      print_position[idx] -= gc_state.coord_system[idx]+gc_state.coord_offset[idx];
    4f34:	f6 01       	movw	r30, r12
    4f36:	61 91       	ld	r22, Z+
    4f38:	71 91       	ld	r23, Z+
    4f3a:	81 91       	ld	r24, Z+
    4f3c:	91 91       	ld	r25, Z+
    4f3e:	6f 01       	movw	r12, r30
    4f40:	20 85       	ldd	r18, Z+8	; 0x08
    4f42:	31 85       	ldd	r19, Z+9	; 0x09
    4f44:	42 85       	ldd	r20, Z+10	; 0x0a
    4f46:	53 85       	ldd	r21, Z+11	; 0x0b
    4f48:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    4f4c:	9b 01       	movw	r18, r22
    4f4e:	ac 01       	movw	r20, r24
    4f50:	f8 01       	movw	r30, r16
    4f52:	60 81       	ld	r22, Z
    4f54:	71 81       	ldd	r23, Z+1	; 0x01
    4f56:	82 81       	ldd	r24, Z+2	; 0x02
    4f58:	93 81       	ldd	r25, Z+3	; 0x03
    4f5a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    4f5e:	f8 01       	movw	r30, r16
    4f60:	60 83       	st	Z, r22
    4f62:	71 83       	std	Z+1, r23	; 0x01
    4f64:	82 83       	std	Z+2, r24	; 0x02
    4f66:	93 83       	std	Z+3, r25	; 0x03
      if (idx == TOOL_LENGTH_OFFSET_AXIS) { print_position[idx] -= gc_state.tool_length_offset; }    
    4f68:	f2 e0       	ldi	r31, 0x02	; 2
    4f6a:	ff 12       	cpse	r15, r31
    4f6c:	12 c0       	rjmp	.+36     	; 0x4f92 <report_realtime_status+0x164>
    4f6e:	20 91 c7 05 	lds	r18, 0x05C7	; 0x8005c7 <gc_state+0x3b>
    4f72:	30 91 c8 05 	lds	r19, 0x05C8	; 0x8005c8 <gc_state+0x3c>
    4f76:	40 91 c9 05 	lds	r20, 0x05C9	; 0x8005c9 <gc_state+0x3d>
    4f7a:	50 91 ca 05 	lds	r21, 0x05CA	; 0x8005ca <gc_state+0x3e>
    4f7e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    4f82:	f8 01       	movw	r30, r16
    4f84:	60 83       	st	Z, r22
    4f86:	71 83       	std	Z+1, r23	; 0x01
    4f88:	82 83       	std	Z+2, r24	; 0x02
    4f8a:	93 83       	std	Z+3, r25	; 0x03
      printFloat_CoordValue(print_position[idx]);
    4f8c:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
    4f90:	0f c0       	rjmp	.+30     	; 0x4fb0 <report_realtime_status+0x182>
    4f92:	0e 94 fb 1f 	call	0x3ff6	; 0x3ff6 <printFloat_CoordValue>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    4f96:	f1 e0       	ldi	r31, 0x01	; 1
    4f98:	ff 15       	cp	r31, r15
    4f9a:	20 f0       	brcs	.+8      	; 0x4fa4 <report_realtime_status+0x176>
    4f9c:	85 e0       	ldi	r24, 0x05	; 5
    4f9e:	93 e0       	ldi	r25, 0x03	; 3
    4fa0:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
  }
  
  // Report work position
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_WORK_POSITION)) {
    printPgmString(PSTR(",WPos:")); 
    for (idx=0; idx< N_AXIS; idx++) {
    4fa4:	f3 94       	inc	r15
    4fa6:	0c 5f       	subi	r16, 0xFC	; 252
    4fa8:	1f 4f       	sbci	r17, 0xFF	; 255
    4faa:	23 e0       	ldi	r18, 0x03	; 3
    4fac:	f2 12       	cpse	r15, r18
    4fae:	c2 cf       	rjmp	.-124    	; 0x4f34 <report_realtime_status+0x106>
      if (idx < (N_AXIS-1)) { printPgmString(PSTR(",")); }
    }
  }
        
  // Returns the number of active blocks are in the planner buffer.
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_PLANNER_BUFFER)) {
    4fb0:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4fb4:	82 ff       	sbrs	r24, 2
    4fb6:	08 c0       	rjmp	.+16     	; 0x4fc8 <report_realtime_status+0x19a>
    printPgmString(PSTR(",Buf:"));
    4fb8:	8f ef       	ldi	r24, 0xFF	; 255
    4fba:	92 e0       	ldi	r25, 0x02	; 2
    4fbc:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    print_uint8_base10(plan_get_block_buffer_count());
    4fc0:	0e 94 b9 1e 	call	0x3d72	; 0x3d72 <plan_get_block_buffer_count>
    4fc4:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
  }

  // Report serial read buffer status
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_SERIAL_RX)) {
    4fc8:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4fcc:	83 ff       	sbrs	r24, 3
    4fce:	08 c0       	rjmp	.+16     	; 0x4fe0 <report_realtime_status+0x1b2>
    printPgmString(PSTR(",RX:"));
    4fd0:	8a ef       	ldi	r24, 0xFA	; 250
    4fd2:	92 e0       	ldi	r25, 0x02	; 2
    4fd4:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    print_uint8_base10(serial_get_rx_buffer_count());
    4fd8:	0e 94 12 28 	call	0x5024	; 0x5024 <serial_get_rx_buffer_count>
    4fdc:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <print_uint8_base10>
    // Report realtime rate 
    printPgmString(PSTR(",F:")); 
    printFloat_RateValue(st_get_realtime_rate());
  #endif    
  
  if (bit_istrue(settings.status_report_mask,BITFLAG_RT_STATUS_LIMIT_PINS)) {
    4fe0:	80 91 17 07 	lds	r24, 0x0717	; 0x800717 <settings+0x34>
    4fe4:	84 ff       	sbrs	r24, 4
    4fe6:	0a c0       	rjmp	.+20     	; 0x4ffc <report_realtime_status+0x1ce>
    printPgmString(PSTR(",Lim:"));
    4fe8:	84 ef       	ldi	r24, 0xF4	; 244
    4fea:	92 e0       	ldi	r25, 0x02	; 2
    4fec:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
    print_unsigned_int8(limits_get_state(),2,N_AXIS);
    4ff0:	0e 94 29 11 	call	0x2252	; 0x2252 <limits_get_state>
    4ff4:	43 e0       	ldi	r20, 0x03	; 3
    4ff6:	62 e0       	ldi	r22, 0x02	; 2
    4ff8:	0e 94 ee 1e 	call	0x3ddc	; 0x3ddc <print_unsigned_int8>
  #ifdef REPORT_CONTROL_PIN_STATE 
    printPgmString(PSTR(",Ctl:"));
    print_uint8_base2(CONTROL_PIN & CONTROL_MASK);
  #endif
  
  printPgmString(PSTR(">\r\n"));
    4ffc:	80 ef       	ldi	r24, 0xF0	; 240
    4ffe:	92 e0       	ldi	r25, 0x02	; 2
    5000:	0e 94 dc 1e 	call	0x3db8	; 0x3db8 <printPgmString>
}
    5004:	68 96       	adiw	r28, 0x18	; 24
    5006:	0f b6       	in	r0, 0x3f	; 63
    5008:	f8 94       	cli
    500a:	de bf       	out	0x3e, r29	; 62
    500c:	0f be       	out	0x3f, r0	; 63
    500e:	cd bf       	out	0x3d, r28	; 61
    5010:	df 91       	pop	r29
    5012:	cf 91       	pop	r28
    5014:	1f 91       	pop	r17
    5016:	0f 91       	pop	r16
    5018:	ff 90       	pop	r15
    501a:	df 90       	pop	r13
    501c:	cf 90       	pop	r12
    501e:	bf 90       	pop	r11
    5020:	af 90       	pop	r10
    5022:	08 95       	ret

00005024 <serial_get_rx_buffer_count>:
uint8_t serial_get_tx_buffer_count()
{
  uint8_t ttail = serial_tx_buffer_tail; // Copy to limit multiple calls to volatile
  if (serial_tx_buffer_head >= ttail) { return(serial_tx_buffer_head-ttail); }
  return (TX_BUFFER_SIZE - (ttail-serial_tx_buffer_head));
}
    5024:	90 91 b8 04 	lds	r25, 0x04B8	; 0x8004b8 <serial_rx_buffer_tail>
    5028:	80 91 b9 04 	lds	r24, 0x04B9	; 0x8004b9 <serial_rx_buffer_head>
    502c:	89 17       	cp	r24, r25
    502e:	10 f0       	brcs	.+4      	; 0x5034 <serial_get_rx_buffer_count+0x10>
    5030:	89 1b       	sub	r24, r25
    5032:	08 95       	ret
    5034:	80 58       	subi	r24, 0x80	; 128
    5036:	89 1b       	sub	r24, r25
    5038:	08 95       	ret

0000503a <serial_write>:
// Writes one byte to the TX serial buffer. Called by main program.
// TODO: Check if we can speed this up for writing strings, rather than single bytes.
void serial_write(uint8_t data) {
	
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
    503a:	e0 91 b7 04 	lds	r30, 0x04B7	; 0x8004b7 <serial_tx_buffer_head>
    503e:	21 e0       	ldi	r18, 0x01	; 1
    5040:	2e 0f       	add	r18, r30
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }
    5042:	20 34       	cpi	r18, 0x40	; 64
    5044:	31 f4       	brne	.+12     	; 0x5052 <serial_write+0x18>
    5046:	20 e0       	ldi	r18, 0x00	; 0
    5048:	04 c0       	rjmp	.+8      	; 0x5052 <serial_write+0x18>

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
    504a:	90 91 89 05 	lds	r25, 0x0589	; 0x800589 <sys_rt_exec_state>
    504e:	94 fd       	sbrc	r25, 4
    5050:	0e c0       	rjmp	.+28     	; 0x506e <serial_write+0x34>
  // Calculate next head
  uint8_t next_head = serial_tx_buffer_head + 1;
  if (next_head == TX_BUFFER_SIZE) { next_head = 0; }

  // Wait until there is space in the buffer
  while (next_head == serial_tx_buffer_tail) { 
    5052:	90 91 b6 04 	lds	r25, 0x04B6	; 0x8004b6 <serial_tx_buffer_tail>
    5056:	92 17       	cp	r25, r18
    5058:	c1 f3       	breq	.-16     	; 0x504a <serial_write+0x10>
    // TODO: Restructure st_prep_buffer() calls to be executed here during a long print.    
    if (sys_rt_exec_state & EXEC_RESET) { return; } // Only check for abort to avoid an endless loop.
  }

  // Store data and advance head
  serial_tx_buffer[serial_tx_buffer_head] = data;
    505a:	f0 e0       	ldi	r31, 0x00	; 0
    505c:	ed 5d       	subi	r30, 0xDD	; 221
    505e:	f9 4f       	sbci	r31, 0xF9	; 249
    5060:	80 83       	st	Z, r24
  serial_tx_buffer_head = next_head;
    5062:	20 93 b7 04 	sts	0x04B7, r18	; 0x8004b7 <serial_tx_buffer_head>
  
  // Enable Data Register Empty Interrupt to make sure tx-streaming is running
  //UCSR0B |=  (1 << UDRIE0); 
  
  /*		HAL replacement of UCSR0B |=  (1 << UDRIE0);		*/
  Uart_interruptTrigger(UART_0, DATA_EMPTY); 
    5066:	62 e0       	ldi	r22, 0x02	; 2
    5068:	80 e0       	ldi	r24, 0x00	; 0
    506a:	0e 94 82 39 	call	0x7304	; 0x7304 <Uart_interruptTrigger>
    506e:	08 95       	ret

00005070 <__vector_19>:
}


// Data Register Empty Interrupt handler
ISR(SERIAL_UDRE)
{
    5070:	1f 92       	push	r1
    5072:	0f 92       	push	r0
    5074:	0f b6       	in	r0, 0x3f	; 63
    5076:	0f 92       	push	r0
    5078:	11 24       	eor	r1, r1
    507a:	2f 93       	push	r18
    507c:	3f 93       	push	r19
    507e:	4f 93       	push	r20
    5080:	5f 93       	push	r21
    5082:	6f 93       	push	r22
    5084:	7f 93       	push	r23
    5086:	8f 93       	push	r24
    5088:	9f 93       	push	r25
    508a:	af 93       	push	r26
    508c:	bf 93       	push	r27
    508e:	ef 93       	push	r30
    5090:	ff 93       	push	r31
  uint8_t tail = serial_tx_buffer_tail; // Temporary serial_tx_buffer_tail (to optimize for volatile)
    5092:	80 91 b6 04 	lds	r24, 0x04B6	; 0x8004b6 <serial_tx_buffer_tail>
      flow_ctrl = XON_SENT; 
    } else
  #endif
  { 
    // Send a byte from the buffer	
    UDR0 = serial_tx_buffer[tail];
    5096:	e8 2f       	mov	r30, r24
    5098:	f0 e0       	ldi	r31, 0x00	; 0
    509a:	ed 5d       	subi	r30, 0xDD	; 221
    509c:	f9 4f       	sbci	r31, 0xF9	; 249
    509e:	90 81       	ld	r25, Z
    50a0:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  
    // Update tail position
    tail++;
    50a4:	8f 5f       	subi	r24, 0xFF	; 255
    if (tail == TX_BUFFER_SIZE) { tail = 0; }
    50a6:	80 34       	cpi	r24, 0x40	; 64
    50a8:	09 f4       	brne	.+2      	; 0x50ac <__vector_19+0x3c>
    50aa:	80 e0       	ldi	r24, 0x00	; 0
  
    serial_tx_buffer_tail = tail;
    50ac:	80 93 b6 04 	sts	0x04B6, r24	; 0x8004b6 <serial_tx_buffer_tail>
  }
  
  // Turn off Data Register Empty Interrupt to stop tx-streaming if this concludes the transfer
  if (tail == serial_tx_buffer_head) { 
    50b0:	90 91 b7 04 	lds	r25, 0x04B7	; 0x8004b7 <serial_tx_buffer_head>
    50b4:	89 13       	cpse	r24, r25
    50b6:	04 c0       	rjmp	.+8      	; 0x50c0 <__vector_19+0x50>
	  //UCSR0B &= ~(1 << UDRIE0); 
	  
	  /*		HAL replacement of UCSR0B &= ~(1 << UDRIE0)		*/
	  Uart_interruptClear(UART_0, DATA_EMPTY);
    50b8:	62 e0       	ldi	r22, 0x02	; 2
    50ba:	80 e0       	ldi	r24, 0x00	; 0
    50bc:	0e 94 9a 39 	call	0x7334	; 0x7334 <Uart_interruptClear>
  }
}
    50c0:	ff 91       	pop	r31
    50c2:	ef 91       	pop	r30
    50c4:	bf 91       	pop	r27
    50c6:	af 91       	pop	r26
    50c8:	9f 91       	pop	r25
    50ca:	8f 91       	pop	r24
    50cc:	7f 91       	pop	r23
    50ce:	6f 91       	pop	r22
    50d0:	5f 91       	pop	r21
    50d2:	4f 91       	pop	r20
    50d4:	3f 91       	pop	r19
    50d6:	2f 91       	pop	r18
    50d8:	0f 90       	pop	r0
    50da:	0f be       	out	0x3f, r0	; 63
    50dc:	0f 90       	pop	r0
    50de:	1f 90       	pop	r1
    50e0:	18 95       	reti

000050e2 <serial_read>:

// Fetches the first byte in the serial read buffer. Called by main program.
uint8_t serial_read()
{
	
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
    50e2:	90 91 b8 04 	lds	r25, 0x04B8	; 0x8004b8 <serial_rx_buffer_tail>
  if (serial_rx_buffer_head == tail) {
    50e6:	80 91 b9 04 	lds	r24, 0x04B9	; 0x8004b9 <serial_rx_buffer_head>
    50ea:	98 17       	cp	r25, r24
    50ec:	61 f0       	breq	.+24     	; 0x5106 <serial_read+0x24>
    return SERIAL_NO_DATA;
  } else {
    uint8_t data = serial_rx_buffer[tail];
    50ee:	e9 2f       	mov	r30, r25
    50f0:	f0 e0       	ldi	r31, 0x00	; 0
    50f2:	ed 59       	subi	r30, 0x9D	; 157
    50f4:	f9 4f       	sbci	r31, 0xF9	; 249
    50f6:	80 81       	ld	r24, Z
    
    tail++;
    50f8:	9f 5f       	subi	r25, 0xFF	; 255
    if (tail == RX_BUFFER_SIZE) { tail = 0; }
    50fa:	90 38       	cpi	r25, 0x80	; 128
    50fc:	09 f4       	brne	.+2      	; 0x5100 <serial_read+0x1e>
    50fe:	90 e0       	ldi	r25, 0x00	; 0
    serial_rx_buffer_tail = tail;
    5100:	90 93 b8 04 	sts	0x04B8, r25	; 0x8004b8 <serial_rx_buffer_tail>
		/*		HAL replacement of UCSR0B |=  (1 << UDRIE0);		*/
		Uart_interruptTrigger(UART_0, DATA_EMPTY); 
      }
    #endif
    
    return data;
    5104:	08 95       	ret
uint8_t serial_read()
{
	
  uint8_t tail = serial_rx_buffer_tail; // Temporary serial_rx_buffer_tail (to optimize for volatile)
  if (serial_rx_buffer_head == tail) {
    return SERIAL_NO_DATA;
    5106:	8f ef       	ldi	r24, 0xFF	; 255
    
    return data;
	
  }
  
}
    5108:	08 95       	ret

0000510a <__vector_18>:


ISR(SERIAL_RX)
{
    510a:	1f 92       	push	r1
    510c:	0f 92       	push	r0
    510e:	0f b6       	in	r0, 0x3f	; 63
    5110:	0f 92       	push	r0
    5112:	11 24       	eor	r1, r1
    5114:	2f 93       	push	r18
    5116:	3f 93       	push	r19
    5118:	4f 93       	push	r20
    511a:	5f 93       	push	r21
    511c:	6f 93       	push	r22
    511e:	7f 93       	push	r23
    5120:	8f 93       	push	r24
    5122:	9f 93       	push	r25
    5124:	af 93       	push	r26
    5126:	bf 93       	push	r27
    5128:	ef 93       	push	r30
    512a:	ff 93       	push	r31
  uint8_t data = UDR0;
    512c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
  uint8_t next_head;
  
  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    5130:	8f 33       	cpi	r24, 0x3F	; 63
    5132:	59 f0       	breq	.+22     	; 0x514a <__vector_18+0x40>
    5134:	28 f4       	brcc	.+10     	; 0x5140 <__vector_18+0x36>
    5136:	88 31       	cpi	r24, 0x18	; 24
    5138:	61 f1       	breq	.+88     	; 0x5192 <__vector_18+0x88>
    513a:	81 32       	cpi	r24, 0x21	; 33
    513c:	c1 f0       	breq	.+48     	; 0x516e <__vector_18+0x64>
    513e:	2c c0       	rjmp	.+88     	; 0x5198 <__vector_18+0x8e>
    5140:	80 34       	cpi	r24, 0x40	; 64
    5142:	f1 f0       	breq	.+60     	; 0x5180 <__vector_18+0x76>
    5144:	8e 37       	cpi	r24, 0x7E	; 126
    5146:	51 f0       	breq	.+20     	; 0x515c <__vector_18+0x52>
    5148:	27 c0       	rjmp	.+78     	; 0x5198 <__vector_18+0x8e>
    case CMD_STATUS_REPORT: bit_true_atomic(sys_rt_exec_state, EXEC_STATUS_REPORT); break; // Set as true
    514a:	9f b7       	in	r25, 0x3f	; 63
    514c:	f8 94       	cli
    514e:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    5152:	81 60       	ori	r24, 0x01	; 1
    5154:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    5158:	9f bf       	out	0x3f, r25	; 63
    515a:	2f c0       	rjmp	.+94     	; 0x51ba <__vector_18+0xb0>
    case CMD_CYCLE_START:   bit_true_atomic(sys_rt_exec_state, EXEC_CYCLE_START); break; // Set as true
    515c:	9f b7       	in	r25, 0x3f	; 63
    515e:	f8 94       	cli
    5160:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    5164:	82 60       	ori	r24, 0x02	; 2
    5166:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    516a:	9f bf       	out	0x3f, r25	; 63
    516c:	26 c0       	rjmp	.+76     	; 0x51ba <__vector_18+0xb0>
    case CMD_FEED_HOLD:     bit_true_atomic(sys_rt_exec_state, EXEC_FEED_HOLD); break; // Set as true
    516e:	9f b7       	in	r25, 0x3f	; 63
    5170:	f8 94       	cli
    5172:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    5176:	88 60       	ori	r24, 0x08	; 8
    5178:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    517c:	9f bf       	out	0x3f, r25	; 63
    517e:	1d c0       	rjmp	.+58     	; 0x51ba <__vector_18+0xb0>
    case CMD_SAFETY_DOOR:   bit_true_atomic(sys_rt_exec_state, EXEC_SAFETY_DOOR); break; // Set as true
    5180:	9f b7       	in	r25, 0x3f	; 63
    5182:	f8 94       	cli
    5184:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    5188:	80 62       	ori	r24, 0x20	; 32
    518a:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    518e:	9f bf       	out	0x3f, r25	; 63
    5190:	14 c0       	rjmp	.+40     	; 0x51ba <__vector_18+0xb0>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    5192:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
    5196:	11 c0       	rjmp	.+34     	; 0x51ba <__vector_18+0xb0>
    default: // Write character to buffer    
      next_head = serial_rx_buffer_head + 1;
    5198:	e0 91 b9 04 	lds	r30, 0x04B9	; 0x8004b9 <serial_rx_buffer_head>
    519c:	91 e0       	ldi	r25, 0x01	; 1
    519e:	9e 0f       	add	r25, r30
      if (next_head == RX_BUFFER_SIZE) { next_head = 0; }
    51a0:	90 38       	cpi	r25, 0x80	; 128
    51a2:	09 f4       	brne	.+2      	; 0x51a6 <__vector_18+0x9c>
    51a4:	90 e0       	ldi	r25, 0x00	; 0
    
      // Write data to buffer unless it is full.
      if (next_head != serial_rx_buffer_tail) {
    51a6:	20 91 b8 04 	lds	r18, 0x04B8	; 0x8004b8 <serial_rx_buffer_tail>
    51aa:	92 17       	cp	r25, r18
    51ac:	31 f0       	breq	.+12     	; 0x51ba <__vector_18+0xb0>
        serial_rx_buffer[serial_rx_buffer_head] = data;
    51ae:	f0 e0       	ldi	r31, 0x00	; 0
    51b0:	ed 59       	subi	r30, 0x9D	; 157
    51b2:	f9 4f       	sbci	r31, 0xF9	; 249
    51b4:	80 83       	st	Z, r24
        serial_rx_buffer_head = next_head;    
    51b6:	90 93 b9 04 	sts	0x04B9, r25	; 0x8004b9 <serial_rx_buffer_head>
        #endif
        
      }
      //TODO: else alarm on overflow?
  }
}
    51ba:	ff 91       	pop	r31
    51bc:	ef 91       	pop	r30
    51be:	bf 91       	pop	r27
    51c0:	af 91       	pop	r26
    51c2:	9f 91       	pop	r25
    51c4:	8f 91       	pop	r24
    51c6:	7f 91       	pop	r23
    51c8:	6f 91       	pop	r22
    51ca:	5f 91       	pop	r21
    51cc:	4f 91       	pop	r20
    51ce:	3f 91       	pop	r19
    51d0:	2f 91       	pop	r18
    51d2:	0f 90       	pop	r0
    51d4:	0f be       	out	0x3f, r0	; 63
    51d6:	0f 90       	pop	r0
    51d8:	1f 90       	pop	r1
    51da:	18 95       	reti

000051dc <serial_reset_read_buffer>:


void serial_reset_read_buffer() 
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    51dc:	80 91 b9 04 	lds	r24, 0x04B9	; 0x8004b9 <serial_rx_buffer_head>
    51e0:	80 93 b8 04 	sts	0x04B8, r24	; 0x8004b8 <serial_rx_buffer_tail>
    51e4:	08 95       	ret

000051e6 <settings_store_startup_line>:

// Method to store startup lines into EEPROM
void settings_store_startup_line(uint8_t n, char *line)
{
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  memcpy_to_eeprom_with_checksum(addr,(char*)line, LINE_BUFFER_SIZE);
    51e6:	21 e5       	ldi	r18, 0x51	; 81
    51e8:	82 9f       	mul	r24, r18
    51ea:	c0 01       	movw	r24, r0
    51ec:	11 24       	eor	r1, r1
    51ee:	40 e5       	ldi	r20, 0x50	; 80
    51f0:	50 e0       	ldi	r21, 0x00	; 0
    51f2:	9d 5f       	subi	r25, 0xFD	; 253
    51f4:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    51f8:	08 95       	ret

000051fa <settings_store_build_info>:


// Method to store build info into EEPROM
void settings_store_build_info(char *line)
{
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_BUILD_INFO,(char*)line, LINE_BUFFER_SIZE);
    51fa:	40 e5       	ldi	r20, 0x50	; 80
    51fc:	50 e0       	ldi	r21, 0x00	; 0
    51fe:	bc 01       	movw	r22, r24
    5200:	8e ea       	ldi	r24, 0xAE	; 174
    5202:	93 e0       	ldi	r25, 0x03	; 3
    5204:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    5208:	08 95       	ret

0000520a <settings_write_coord_data>:

// Method to store coord data parameters into EEPROM
void settings_write_coord_data(uint8_t coord_select, float *coord_data)
{  
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  memcpy_to_eeprom_with_checksum(addr,(char*)coord_data, sizeof(float)*N_AXIS);
    520a:	2d e0       	ldi	r18, 0x0D	; 13
    520c:	82 9f       	mul	r24, r18
    520e:	c0 01       	movw	r24, r0
    5210:	11 24       	eor	r1, r1
    5212:	4c e0       	ldi	r20, 0x0C	; 12
    5214:	50 e0       	ldi	r21, 0x00	; 0
    5216:	9e 5f       	subi	r25, 0xFE	; 254
    5218:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    521c:	08 95       	ret

0000521e <write_global_settings>:


// Method to store Grbl global settings struct and version number into EEPROM
void write_global_settings() 
{
  eeprom_put_char(0, SETTINGS_VERSION);
    521e:	69 e0       	ldi	r22, 0x09	; 9
    5220:	80 e0       	ldi	r24, 0x00	; 0
    5222:	90 e0       	ldi	r25, 0x00	; 0
    5224:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
  memcpy_to_eeprom_with_checksum(EEPROM_ADDR_GLOBAL, (char*)&settings, sizeof(settings_t));
    5228:	4d e4       	ldi	r20, 0x4D	; 77
    522a:	50 e0       	ldi	r21, 0x00	; 0
    522c:	63 ee       	ldi	r22, 0xE3	; 227
    522e:	76 e0       	ldi	r23, 0x06	; 6
    5230:	81 e0       	ldi	r24, 0x01	; 1
    5232:	90 e0       	ldi	r25, 0x00	; 0
    5234:	0e 94 45 05 	call	0xa8a	; 0xa8a <memcpy_to_eeprom_with_checksum>
    5238:	08 95       	ret

0000523a <settings_restore>:
}


// Method to restore EEPROM-saved Grbl global settings back to defaults. 
void settings_restore(uint8_t restore_flag) {  
    523a:	0f 93       	push	r16
    523c:	1f 93       	push	r17
    523e:	cf 93       	push	r28
    5240:	df 93       	push	r29
    5242:	cd b7       	in	r28, 0x3d	; 61
    5244:	de b7       	in	r29, 0x3e	; 62
    5246:	2c 97       	sbiw	r28, 0x0c	; 12
    5248:	0f b6       	in	r0, 0x3f	; 63
    524a:	f8 94       	cli
    524c:	de bf       	out	0x3e, r29	; 62
    524e:	0f be       	out	0x3f, r0	; 63
    5250:	cd bf       	out	0x3d, r28	; 61
    5252:	08 2f       	mov	r16, r24
  if (restore_flag & SETTINGS_RESTORE_DEFAULTS) {
    5254:	80 ff       	sbrs	r24, 0
    5256:	84 c0       	rjmp	.+264    	; 0x5360 <settings_restore+0x126>
	settings.pulse_microseconds = DEFAULT_STEP_PULSE_MICROSECONDS;
    5258:	e3 ee       	ldi	r30, 0xE3	; 227
    525a:	f6 e0       	ldi	r31, 0x06	; 6
    525c:	8a e0       	ldi	r24, 0x0A	; 10
    525e:	80 ab       	std	Z+48, r24	; 0x30
	settings.stepper_idle_lock_time = DEFAULT_STEPPER_IDLE_LOCK_TIME;
    5260:	89 e1       	ldi	r24, 0x19	; 25
    5262:	83 ab       	std	Z+51, r24	; 0x33
	settings.step_invert_mask = DEFAULT_STEPPING_INVERT_MASK;
    5264:	11 aa       	std	Z+49, r1	; 0x31
	settings.dir_invert_mask = DEFAULT_DIRECTION_INVERT_MASK;
    5266:	12 aa       	std	Z+50, r1	; 0x32
	settings.status_report_mask = DEFAULT_STATUS_REPORT_MASK;
    5268:	83 e0       	ldi	r24, 0x03	; 3
    526a:	84 ab       	std	Z+52, r24	; 0x34
	settings.junction_deviation = DEFAULT_JUNCTION_DEVIATION;
    526c:	8a e0       	ldi	r24, 0x0A	; 10
    526e:	97 ed       	ldi	r25, 0xD7	; 215
    5270:	a3 e2       	ldi	r26, 0x23	; 35
    5272:	bc e3       	ldi	r27, 0x3C	; 60
    5274:	85 ab       	std	Z+53, r24	; 0x35
    5276:	96 ab       	std	Z+54, r25	; 0x36
    5278:	a7 ab       	std	Z+55, r26	; 0x37
    527a:	b0 af       	std	Z+56, r27	; 0x38
	settings.arc_tolerance = DEFAULT_ARC_TOLERANCE;
    527c:	8f e6       	ldi	r24, 0x6F	; 111
    527e:	92 e1       	ldi	r25, 0x12	; 18
    5280:	a3 e0       	ldi	r26, 0x03	; 3
    5282:	bb e3       	ldi	r27, 0x3B	; 59
    5284:	81 af       	std	Z+57, r24	; 0x39
    5286:	92 af       	std	Z+58, r25	; 0x3a
    5288:	a3 af       	std	Z+59, r26	; 0x3b
    528a:	b4 af       	std	Z+60, r27	; 0x3c
	settings.homing_dir_mask = DEFAULT_HOMING_DIR_MASK;
    528c:	16 ae       	std	Z+62, r1	; 0x3e
	settings.homing_feed_rate = DEFAULT_HOMING_FEED_RATE;
    528e:	80 e0       	ldi	r24, 0x00	; 0
    5290:	90 e0       	ldi	r25, 0x00	; 0
    5292:	a8 ec       	ldi	r26, 0xC8	; 200
    5294:	b1 e4       	ldi	r27, 0x41	; 65
    5296:	80 93 22 07 	sts	0x0722, r24	; 0x800722 <settings+0x3f>
    529a:	90 93 23 07 	sts	0x0723, r25	; 0x800723 <settings+0x40>
    529e:	a0 93 24 07 	sts	0x0724, r26	; 0x800724 <settings+0x41>
    52a2:	b0 93 25 07 	sts	0x0725, r27	; 0x800725 <settings+0x42>
	settings.homing_seek_rate = DEFAULT_HOMING_SEEK_RATE;
    52a6:	80 e0       	ldi	r24, 0x00	; 0
    52a8:	90 e0       	ldi	r25, 0x00	; 0
    52aa:	aa ef       	ldi	r26, 0xFA	; 250
    52ac:	b3 e4       	ldi	r27, 0x43	; 67
    52ae:	80 93 26 07 	sts	0x0726, r24	; 0x800726 <settings+0x43>
    52b2:	90 93 27 07 	sts	0x0727, r25	; 0x800727 <settings+0x44>
    52b6:	a0 93 28 07 	sts	0x0728, r26	; 0x800728 <settings+0x45>
    52ba:	b0 93 29 07 	sts	0x0729, r27	; 0x800729 <settings+0x46>
	settings.homing_debounce_delay = DEFAULT_HOMING_DEBOUNCE_DELAY;
    52be:	2a ef       	ldi	r18, 0xFA	; 250
    52c0:	30 e0       	ldi	r19, 0x00	; 0
    52c2:	30 93 2b 07 	sts	0x072B, r19	; 0x80072b <settings+0x48>
    52c6:	20 93 2a 07 	sts	0x072A, r18	; 0x80072a <settings+0x47>
	settings.homing_pulloff = DEFAULT_HOMING_PULLOFF;
    52ca:	40 e0       	ldi	r20, 0x00	; 0
    52cc:	50 e0       	ldi	r21, 0x00	; 0
    52ce:	60 e8       	ldi	r22, 0x80	; 128
    52d0:	7f e3       	ldi	r23, 0x3F	; 63
    52d2:	40 93 2c 07 	sts	0x072C, r20	; 0x80072c <settings+0x49>
    52d6:	50 93 2d 07 	sts	0x072D, r21	; 0x80072d <settings+0x4a>
    52da:	60 93 2e 07 	sts	0x072E, r22	; 0x80072e <settings+0x4b>
    52de:	70 93 2f 07 	sts	0x072F, r23	; 0x80072f <settings+0x4c>

	settings.flags = 0;
    52e2:	15 ae       	std	Z+61, r1	; 0x3d
	if (DEFAULT_INVERT_LIMIT_PINS) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
	if (DEFAULT_SOFT_LIMIT_ENABLE) { settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; }
	if (DEFAULT_HARD_LIMIT_ENABLE) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
	if (DEFAULT_HOMING_ENABLE) { settings.flags |= BITFLAG_HOMING_ENABLE; }
  
	settings.steps_per_mm[X_AXIS] = DEFAULT_X_STEPS_PER_MM;
    52e4:	40 e0       	ldi	r20, 0x00	; 0
    52e6:	50 e0       	ldi	r21, 0x00	; 0
    52e8:	6a e7       	ldi	r22, 0x7A	; 122
    52ea:	73 e4       	ldi	r23, 0x43	; 67
    52ec:	40 83       	st	Z, r20
    52ee:	51 83       	std	Z+1, r21	; 0x01
    52f0:	62 83       	std	Z+2, r22	; 0x02
    52f2:	73 83       	std	Z+3, r23	; 0x03
	settings.steps_per_mm[Y_AXIS] = DEFAULT_Y_STEPS_PER_MM;
    52f4:	44 83       	std	Z+4, r20	; 0x04
    52f6:	55 83       	std	Z+5, r21	; 0x05
    52f8:	66 83       	std	Z+6, r22	; 0x06
    52fa:	77 83       	std	Z+7, r23	; 0x07
	settings.steps_per_mm[Z_AXIS] = DEFAULT_Z_STEPS_PER_MM;
    52fc:	40 87       	std	Z+8, r20	; 0x08
    52fe:	51 87       	std	Z+9, r21	; 0x09
    5300:	62 87       	std	Z+10, r22	; 0x0a
    5302:	73 87       	std	Z+11, r23	; 0x0b
	settings.max_rate[X_AXIS] = DEFAULT_X_MAX_RATE;
    5304:	84 87       	std	Z+12, r24	; 0x0c
    5306:	95 87       	std	Z+13, r25	; 0x0d
    5308:	a6 87       	std	Z+14, r26	; 0x0e
    530a:	b7 87       	std	Z+15, r27	; 0x0f
	settings.max_rate[Y_AXIS] = DEFAULT_Y_MAX_RATE;
    530c:	80 8b       	std	Z+16, r24	; 0x10
    530e:	91 8b       	std	Z+17, r25	; 0x11
    5310:	a2 8b       	std	Z+18, r26	; 0x12
    5312:	b3 8b       	std	Z+19, r27	; 0x13
	settings.max_rate[Z_AXIS] = DEFAULT_Z_MAX_RATE;
    5314:	84 8b       	std	Z+20, r24	; 0x14
    5316:	95 8b       	std	Z+21, r25	; 0x15
    5318:	a6 8b       	std	Z+22, r26	; 0x16
    531a:	b7 8b       	std	Z+23, r27	; 0x17
	settings.acceleration[X_AXIS] = DEFAULT_X_ACCELERATION;
    531c:	80 e0       	ldi	r24, 0x00	; 0
    531e:	90 ea       	ldi	r25, 0xA0	; 160
    5320:	ac e0       	ldi	r26, 0x0C	; 12
    5322:	b7 e4       	ldi	r27, 0x47	; 71
    5324:	80 8f       	std	Z+24, r24	; 0x18
    5326:	91 8f       	std	Z+25, r25	; 0x19
    5328:	a2 8f       	std	Z+26, r26	; 0x1a
    532a:	b3 8f       	std	Z+27, r27	; 0x1b
	settings.acceleration[Y_AXIS] = DEFAULT_Y_ACCELERATION;
    532c:	84 8f       	std	Z+28, r24	; 0x1c
    532e:	95 8f       	std	Z+29, r25	; 0x1d
    5330:	a6 8f       	std	Z+30, r26	; 0x1e
    5332:	b7 8f       	std	Z+31, r27	; 0x1f
	settings.acceleration[Z_AXIS] = DEFAULT_Z_ACCELERATION;
    5334:	80 a3       	std	Z+32, r24	; 0x20
    5336:	91 a3       	std	Z+33, r25	; 0x21
    5338:	a2 a3       	std	Z+34, r26	; 0x22
    533a:	b3 a3       	std	Z+35, r27	; 0x23
	settings.max_travel[X_AXIS] = (-DEFAULT_X_MAX_TRAVEL);
    533c:	80 e0       	ldi	r24, 0x00	; 0
    533e:	90 e0       	ldi	r25, 0x00	; 0
    5340:	a8 e4       	ldi	r26, 0x48	; 72
    5342:	b3 ec       	ldi	r27, 0xC3	; 195
    5344:	84 a3       	std	Z+36, r24	; 0x24
    5346:	95 a3       	std	Z+37, r25	; 0x25
    5348:	a6 a3       	std	Z+38, r26	; 0x26
    534a:	b7 a3       	std	Z+39, r27	; 0x27
	settings.max_travel[Y_AXIS] = (-DEFAULT_Y_MAX_TRAVEL);
    534c:	80 a7       	std	Z+40, r24	; 0x28
    534e:	91 a7       	std	Z+41, r25	; 0x29
    5350:	a2 a7       	std	Z+42, r26	; 0x2a
    5352:	b3 a7       	std	Z+43, r27	; 0x2b
	settings.max_travel[Z_AXIS] = (-DEFAULT_Z_MAX_TRAVEL);    
    5354:	84 a7       	std	Z+44, r24	; 0x2c
    5356:	95 a7       	std	Z+45, r25	; 0x2d
    5358:	a6 a7       	std	Z+46, r26	; 0x2e
    535a:	b7 a7       	std	Z+47, r27	; 0x2f

	write_global_settings();
    535c:	0e 94 0f 29 	call	0x521e	; 0x521e <write_global_settings>
  }
  
  if (restore_flag & SETTINGS_RESTORE_PARAMETERS) {
    5360:	01 ff       	sbrs	r16, 1
    5362:	11 c0       	rjmp	.+34     	; 0x5386 <settings_restore+0x14c>
	uint8_t idx;
	float coord_data[N_AXIS];
	memset(&coord_data, 0, sizeof(coord_data));
    5364:	fe 01       	movw	r30, r28
    5366:	31 96       	adiw	r30, 0x01	; 1
    5368:	8c e0       	ldi	r24, 0x0C	; 12
    536a:	df 01       	movw	r26, r30
    536c:	1d 92       	st	X+, r1
    536e:	8a 95       	dec	r24
    5370:	e9 f7       	brne	.-6      	; 0x536c <settings_restore+0x132>
	for (idx=0; idx <= SETTING_INDEX_NCOORD; idx++) { settings_write_coord_data(idx, coord_data); }
    5372:	10 e0       	ldi	r17, 0x00	; 0
    5374:	be 01       	movw	r22, r28
    5376:	6f 5f       	subi	r22, 0xFF	; 255
    5378:	7f 4f       	sbci	r23, 0xFF	; 255
    537a:	81 2f       	mov	r24, r17
    537c:	0e 94 05 29 	call	0x520a	; 0x520a <settings_write_coord_data>
    5380:	1f 5f       	subi	r17, 0xFF	; 255
    5382:	18 30       	cpi	r17, 0x08	; 8
    5384:	b9 f7       	brne	.-18     	; 0x5374 <settings_restore+0x13a>
  }
  
  if (restore_flag & SETTINGS_RESTORE_STARTUP_LINES) {
    5386:	02 ff       	sbrs	r16, 2
    5388:	0a c0       	rjmp	.+20     	; 0x539e <settings_restore+0x164>
	#if N_STARTUP_LINE > 0
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK, 0);
    538a:	60 e0       	ldi	r22, 0x00	; 0
    538c:	80 e0       	ldi	r24, 0x00	; 0
    538e:	93 e0       	ldi	r25, 0x03	; 3
    5390:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
	#endif
	#if N_STARTUP_LINE > 1
	eeprom_put_char(EEPROM_ADDR_STARTUP_BLOCK+(LINE_BUFFER_SIZE+1), 0);
    5394:	60 e0       	ldi	r22, 0x00	; 0
    5396:	81 e5       	ldi	r24, 0x51	; 81
    5398:	93 e0       	ldi	r25, 0x03	; 3
    539a:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
	#endif
  }
  
  if (restore_flag & SETTINGS_RESTORE_BUILD_INFO) { eeprom_put_char(EEPROM_ADDR_BUILD_INFO , 0); }
    539e:	03 ff       	sbrs	r16, 3
    53a0:	05 c0       	rjmp	.+10     	; 0x53ac <settings_restore+0x172>
    53a2:	60 e0       	ldi	r22, 0x00	; 0
    53a4:	8e ea       	ldi	r24, 0xAE	; 174
    53a6:	93 e0       	ldi	r25, 0x03	; 3
    53a8:	0e 94 26 05 	call	0xa4c	; 0xa4c <eeprom_put_char>
}
    53ac:	2c 96       	adiw	r28, 0x0c	; 12
    53ae:	0f b6       	in	r0, 0x3f	; 63
    53b0:	f8 94       	cli
    53b2:	de bf       	out	0x3e, r29	; 62
    53b4:	0f be       	out	0x3f, r0	; 63
    53b6:	cd bf       	out	0x3d, r28	; 61
    53b8:	df 91       	pop	r29
    53ba:	cf 91       	pop	r28
    53bc:	1f 91       	pop	r17
    53be:	0f 91       	pop	r16
    53c0:	08 95       	ret

000053c2 <settings_read_startup_line>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_startup_line(uint8_t n, char *line)
{
    53c2:	1f 93       	push	r17
    53c4:	cf 93       	push	r28
    53c6:	df 93       	push	r29
    53c8:	18 2f       	mov	r17, r24
    53ca:	eb 01       	movw	r28, r22
  uint32_t addr = n*(LINE_BUFFER_SIZE+1)+EEPROM_ADDR_STARTUP_BLOCK;
  if (!(memcpy_from_eeprom_with_checksum((char*)line, addr, LINE_BUFFER_SIZE))) {
    53cc:	81 e5       	ldi	r24, 0x51	; 81
    53ce:	18 9f       	mul	r17, r24
    53d0:	b0 01       	movw	r22, r0
    53d2:	11 24       	eor	r1, r1
    53d4:	7d 5f       	subi	r23, 0xFD	; 253
    53d6:	40 e5       	ldi	r20, 0x50	; 80
    53d8:	50 e0       	ldi	r21, 0x00	; 0
    53da:	ce 01       	movw	r24, r28
    53dc:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    53e0:	89 2b       	or	r24, r25
    53e2:	39 f4       	brne	.+14     	; 0x53f2 <settings_read_startup_line+0x30>
    // Reset line with default value
    line[0] = 0; // Empty line
    53e4:	18 82       	st	Y, r1
    settings_store_startup_line(n, line);
    53e6:	be 01       	movw	r22, r28
    53e8:	81 2f       	mov	r24, r17
    53ea:	0e 94 f3 28 	call	0x51e6	; 0x51e6 <settings_store_startup_line>
    return(false);
    53ee:	80 e0       	ldi	r24, 0x00	; 0
    53f0:	01 c0       	rjmp	.+2      	; 0x53f4 <settings_read_startup_line+0x32>
  }
  return(true);
    53f2:	81 e0       	ldi	r24, 0x01	; 1
}
    53f4:	df 91       	pop	r29
    53f6:	cf 91       	pop	r28
    53f8:	1f 91       	pop	r17
    53fa:	08 95       	ret

000053fc <settings_read_build_info>:


// Reads startup line from EEPROM. Updated pointed line string data.
uint8_t settings_read_build_info(char *line)
{
    53fc:	cf 93       	push	r28
    53fe:	df 93       	push	r29
    5400:	ec 01       	movw	r28, r24
  if (!(memcpy_from_eeprom_with_checksum((char*)line, EEPROM_ADDR_BUILD_INFO, LINE_BUFFER_SIZE))) {
    5402:	40 e5       	ldi	r20, 0x50	; 80
    5404:	50 e0       	ldi	r21, 0x00	; 0
    5406:	6e ea       	ldi	r22, 0xAE	; 174
    5408:	73 e0       	ldi	r23, 0x03	; 3
    540a:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    540e:	89 2b       	or	r24, r25
    5410:	31 f4       	brne	.+12     	; 0x541e <settings_read_build_info+0x22>
    // Reset line with default value
    line[0] = 0; // Empty line
    5412:	18 82       	st	Y, r1
    settings_store_build_info(line);
    5414:	ce 01       	movw	r24, r28
    5416:	0e 94 fd 28 	call	0x51fa	; 0x51fa <settings_store_build_info>
    return(false);
    541a:	80 e0       	ldi	r24, 0x00	; 0
    541c:	01 c0       	rjmp	.+2      	; 0x5420 <settings_read_build_info+0x24>
  }
  return(true);
    541e:	81 e0       	ldi	r24, 0x01	; 1
}
    5420:	df 91       	pop	r29
    5422:	cf 91       	pop	r28
    5424:	08 95       	ret

00005426 <settings_read_coord_data>:


// Read selected coordinate data from EEPROM. Updates pointed coord_data value.
uint8_t settings_read_coord_data(uint8_t coord_select, float *coord_data)
{
    5426:	1f 93       	push	r17
    5428:	cf 93       	push	r28
    542a:	df 93       	push	r29
    542c:	18 2f       	mov	r17, r24
    542e:	eb 01       	movw	r28, r22
  uint32_t addr = coord_select*(sizeof(float)*N_AXIS+1) + EEPROM_ADDR_PARAMETERS;
  if (!(memcpy_from_eeprom_with_checksum((char*)coord_data, addr, sizeof(float)*N_AXIS))) {
    5430:	8d e0       	ldi	r24, 0x0D	; 13
    5432:	18 9f       	mul	r17, r24
    5434:	b0 01       	movw	r22, r0
    5436:	11 24       	eor	r1, r1
    5438:	7e 5f       	subi	r23, 0xFE	; 254
    543a:	4c e0       	ldi	r20, 0x0C	; 12
    543c:	50 e0       	ldi	r21, 0x00	; 0
    543e:	ce 01       	movw	r24, r28
    5440:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
    5444:	89 2b       	or	r24, r25
    5446:	59 f4       	brne	.+22     	; 0x545e <settings_read_coord_data+0x38>
    // Reset with default zero vector
    clear_vector_float(coord_data); 
    5448:	8c e0       	ldi	r24, 0x0C	; 12
    544a:	fe 01       	movw	r30, r28
    544c:	11 92       	st	Z+, r1
    544e:	8a 95       	dec	r24
    5450:	e9 f7       	brne	.-6      	; 0x544c <settings_read_coord_data+0x26>
    settings_write_coord_data(coord_select,coord_data);
    5452:	be 01       	movw	r22, r28
    5454:	81 2f       	mov	r24, r17
    5456:	0e 94 05 29 	call	0x520a	; 0x520a <settings_write_coord_data>
    return(false);
    545a:	80 e0       	ldi	r24, 0x00	; 0
    545c:	01 c0       	rjmp	.+2      	; 0x5460 <settings_read_coord_data+0x3a>
  }
  return(true);
    545e:	81 e0       	ldi	r24, 0x01	; 1
}  
    5460:	df 91       	pop	r29
    5462:	cf 91       	pop	r28
    5464:	1f 91       	pop	r17
    5466:	08 95       	ret

00005468 <read_global_settings>:


// Reads Grbl global settings struct from EEPROM.
uint8_t read_global_settings() {
  // Check version-byte of eeprom
  uint8_t version = eeprom_get_char(0);
    5468:	80 e0       	ldi	r24, 0x00	; 0
    546a:	90 e0       	ldi	r25, 0x00	; 0
    546c:	0e 94 1e 05 	call	0xa3c	; 0xa3c <eeprom_get_char>
  if (version == SETTINGS_VERSION) {
    5470:	89 30       	cpi	r24, 0x09	; 9
    5472:	69 f4       	brne	.+26     	; 0x548e <read_global_settings+0x26>
    // Read settings-record and check checksum
    if (!(memcpy_from_eeprom_with_checksum((char*)&settings, EEPROM_ADDR_GLOBAL, sizeof(settings_t)))) {
    5474:	4d e4       	ldi	r20, 0x4D	; 77
    5476:	50 e0       	ldi	r21, 0x00	; 0
    5478:	61 e0       	ldi	r22, 0x01	; 1
    547a:	70 e0       	ldi	r23, 0x00	; 0
    547c:	83 ee       	ldi	r24, 0xE3	; 227
    547e:	96 e0       	ldi	r25, 0x06	; 6
    5480:	0e 94 8a 05 	call	0xb14	; 0xb14 <memcpy_from_eeprom_with_checksum>
      return(false);
    5484:	21 e0       	ldi	r18, 0x01	; 1
    5486:	89 2b       	or	r24, r25
    5488:	19 f4       	brne	.+6      	; 0x5490 <read_global_settings+0x28>
    548a:	20 e0       	ldi	r18, 0x00	; 0
    548c:	01 c0       	rjmp	.+2      	; 0x5490 <read_global_settings+0x28>
    }
  } else {
    return(false); 
    548e:	20 e0       	ldi	r18, 0x00	; 0
  }
  return(true);
}
    5490:	82 2f       	mov	r24, r18
    5492:	08 95       	ret

00005494 <settings_store_global_setting>:


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
    5494:	cf 92       	push	r12
    5496:	df 92       	push	r13
    5498:	ef 92       	push	r14
    549a:	ff 92       	push	r15
    549c:	cf 93       	push	r28
    549e:	df 93       	push	r29
    54a0:	c8 2f       	mov	r28, r24
    54a2:	6a 01       	movw	r12, r20
    54a4:	7b 01       	movw	r14, r22
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    54a6:	20 e0       	ldi	r18, 0x00	; 0
    54a8:	30 e0       	ldi	r19, 0x00	; 0
    54aa:	a9 01       	movw	r20, r18
    54ac:	c7 01       	movw	r24, r14
    54ae:	b6 01       	movw	r22, r12
    54b0:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    54b4:	88 23       	and	r24, r24
    54b6:	0c f4       	brge	.+2      	; 0x54ba <settings_store_global_setting+0x26>
    54b8:	dd c0       	rjmp	.+442    	; 0x5674 <settings_store_global_setting+0x1e0>
  if (parameter >= AXIS_SETTINGS_START_VAL) {
    54ba:	c4 36       	cpi	r28, 0x64	; 100
    54bc:	a0 f0       	brcs	.+40     	; 0x54e6 <settings_store_global_setting+0x52>
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    54be:	ec e9       	ldi	r30, 0x9C	; 156
    54c0:	ec 0f       	add	r30, r28
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    54c2:	e3 30       	cpi	r30, 0x03	; 3
    54c4:	20 f0       	brcs	.+8      	; 0x54ce <settings_store_global_setting+0x3a>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    54c6:	ea 30       	cpi	r30, 0x0A	; 10
    54c8:	08 f0       	brcs	.+2      	; 0x54cc <settings_store_global_setting+0x38>
    54ca:	e2 c0       	rjmp	.+452    	; 0x5690 <settings_store_global_setting+0x1fc>
    54cc:	d5 c0       	rjmp	.+426    	; 0x5678 <settings_store_global_setting+0x1e4>
        switch (set_idx) {
          case 0:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.max_rate[parameter] > (MAX_STEP_RATE_HZ*60.0)) { return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.steps_per_mm[parameter] = value;
    54ce:	f0 e0       	ldi	r31, 0x00	; 0
    54d0:	ee 0f       	add	r30, r30
    54d2:	ff 1f       	adc	r31, r31
    54d4:	ee 0f       	add	r30, r30
    54d6:	ff 1f       	adc	r31, r31
    54d8:	ed 51       	subi	r30, 0x1D	; 29
    54da:	f9 4f       	sbci	r31, 0xF9	; 249
    54dc:	c0 82       	st	Z, r12
    54de:	d1 82       	std	Z+1, r13	; 0x01
    54e0:	e2 82       	std	Z+2, r14	; 0x02
    54e2:	f3 82       	std	Z+3, r15	; 0x03
            break;
    54e4:	c3 c0       	rjmp	.+390    	; 0x566c <settings_store_global_setting+0x1d8>
        parameter -= AXIS_SETTINGS_INCREMENT;
      }
    }
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    54e6:	c7 01       	movw	r24, r14
    54e8:	b6 01       	movw	r22, r12
    54ea:	0e 94 f0 3d 	call	0x7be0	; 0x7be0 <trunc>
    54ee:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    switch(parameter) {
    54f2:	8c 2f       	mov	r24, r28
    54f4:	90 e0       	ldi	r25, 0x00	; 0
    54f6:	8c 31       	cpi	r24, 0x1C	; 28
    54f8:	91 05       	cpc	r25, r1
    54fa:	08 f0       	brcs	.+2      	; 0x54fe <settings_store_global_setting+0x6a>
    54fc:	bf c0       	rjmp	.+382    	; 0x567c <settings_store_global_setting+0x1e8>
    54fe:	fc 01       	movw	r30, r24
    5500:	ea 5c       	subi	r30, 0xCA	; 202
    5502:	fe 4f       	sbci	r31, 0xFE	; 254
    5504:	0c 94 44 3e 	jmp	0x7c88	; 0x7c88 <__tablejump2__>
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    5508:	63 30       	cpi	r22, 0x03	; 3
    550a:	08 f4       	brcc	.+2      	; 0x550e <settings_store_global_setting+0x7a>
    550c:	b9 c0       	rjmp	.+370    	; 0x5680 <settings_store_global_setting+0x1ec>
        settings.pulse_microseconds = int_value; break;
    550e:	60 93 13 07 	sts	0x0713, r22	; 0x800713 <settings+0x30>
    5512:	ac c0       	rjmp	.+344    	; 0x566c <settings_store_global_setting+0x1d8>
      case 1: settings.stepper_idle_lock_time = int_value; break;
    5514:	60 93 16 07 	sts	0x0716, r22	; 0x800716 <settings+0x33>
    5518:	a9 c0       	rjmp	.+338    	; 0x566c <settings_store_global_setting+0x1d8>
      case 2: 
        settings.step_invert_mask = int_value; 
    551a:	60 93 14 07 	sts	0x0714, r22	; 0x800714 <settings+0x31>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    551e:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <st_generate_step_dir_invert_masks>
        break;
    5522:	a4 c0       	rjmp	.+328    	; 0x566c <settings_store_global_setting+0x1d8>
      case 3: 
        settings.dir_invert_mask = int_value; 
    5524:	60 93 15 07 	sts	0x0715, r22	; 0x800715 <settings+0x32>
        st_generate_step_dir_invert_masks(); // Regenerate step and direction port invert masks.
    5528:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <st_generate_step_dir_invert_masks>
        break;
    552c:	9f c0       	rjmp	.+318    	; 0x566c <settings_store_global_setting+0x1d8>
      case 4: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_ST_ENABLE; }
    552e:	66 23       	and	r22, r22
    5530:	31 f0       	breq	.+12     	; 0x553e <settings_store_global_setting+0xaa>
    5532:	e3 ee       	ldi	r30, 0xE3	; 227
    5534:	f6 e0       	ldi	r31, 0x06	; 6
    5536:	85 ad       	ldd	r24, Z+61	; 0x3d
    5538:	84 60       	ori	r24, 0x04	; 4
    553a:	85 af       	std	Z+61, r24	; 0x3d
    553c:	97 c0       	rjmp	.+302    	; 0x566c <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_ST_ENABLE; }
    553e:	e3 ee       	ldi	r30, 0xE3	; 227
    5540:	f6 e0       	ldi	r31, 0x06	; 6
    5542:	85 ad       	ldd	r24, Z+61	; 0x3d
    5544:	8b 7f       	andi	r24, 0xFB	; 251
    5546:	85 af       	std	Z+61, r24	; 0x3d
    5548:	91 c0       	rjmp	.+290    	; 0x566c <settings_store_global_setting+0x1d8>
        break;
      case 5: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_LIMIT_PINS; }
    554a:	66 23       	and	r22, r22
    554c:	31 f0       	breq	.+12     	; 0x555a <settings_store_global_setting+0xc6>
    554e:	e3 ee       	ldi	r30, 0xE3	; 227
    5550:	f6 e0       	ldi	r31, 0x06	; 6
    5552:	85 ad       	ldd	r24, Z+61	; 0x3d
    5554:	80 64       	ori	r24, 0x40	; 64
    5556:	85 af       	std	Z+61, r24	; 0x3d
    5558:	89 c0       	rjmp	.+274    	; 0x566c <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_LIMIT_PINS; }
    555a:	e3 ee       	ldi	r30, 0xE3	; 227
    555c:	f6 e0       	ldi	r31, 0x06	; 6
    555e:	85 ad       	ldd	r24, Z+61	; 0x3d
    5560:	8f 7b       	andi	r24, 0xBF	; 191
    5562:	85 af       	std	Z+61, r24	; 0x3d
    5564:	83 c0       	rjmp	.+262    	; 0x566c <settings_store_global_setting+0x1d8>
        break;
      case 6: // Reset to ensure change. Immediate re-init may cause problems.
        if (int_value) { settings.flags |= BITFLAG_INVERT_PROBE_PIN; }
    5566:	66 23       	and	r22, r22
    5568:	31 f0       	breq	.+12     	; 0x5576 <settings_store_global_setting+0xe2>
    556a:	e3 ee       	ldi	r30, 0xE3	; 227
    556c:	f6 e0       	ldi	r31, 0x06	; 6
    556e:	85 ad       	ldd	r24, Z+61	; 0x3d
    5570:	80 68       	ori	r24, 0x80	; 128
    5572:	85 af       	std	Z+61, r24	; 0x3d
    5574:	7b c0       	rjmp	.+246    	; 0x566c <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_INVERT_PROBE_PIN; }
    5576:	e3 ee       	ldi	r30, 0xE3	; 227
    5578:	f6 e0       	ldi	r31, 0x06	; 6
    557a:	85 ad       	ldd	r24, Z+61	; 0x3d
    557c:	8f 77       	andi	r24, 0x7F	; 127
    557e:	85 af       	std	Z+61, r24	; 0x3d
    5580:	75 c0       	rjmp	.+234    	; 0x566c <settings_store_global_setting+0x1d8>
        break;
      case 10: settings.status_report_mask = int_value; break;
    5582:	60 93 17 07 	sts	0x0717, r22	; 0x800717 <settings+0x34>
    5586:	72 c0       	rjmp	.+228    	; 0x566c <settings_store_global_setting+0x1d8>
      case 11: settings.junction_deviation = value; break;
    5588:	c0 92 18 07 	sts	0x0718, r12	; 0x800718 <settings+0x35>
    558c:	d0 92 19 07 	sts	0x0719, r13	; 0x800719 <settings+0x36>
    5590:	e0 92 1a 07 	sts	0x071A, r14	; 0x80071a <settings+0x37>
    5594:	f0 92 1b 07 	sts	0x071B, r15	; 0x80071b <settings+0x38>
    5598:	69 c0       	rjmp	.+210    	; 0x566c <settings_store_global_setting+0x1d8>
      case 12: settings.arc_tolerance = value; break;
    559a:	c0 92 1c 07 	sts	0x071C, r12	; 0x80071c <settings+0x39>
    559e:	d0 92 1d 07 	sts	0x071D, r13	; 0x80071d <settings+0x3a>
    55a2:	e0 92 1e 07 	sts	0x071E, r14	; 0x80071e <settings+0x3b>
    55a6:	f0 92 1f 07 	sts	0x071F, r15	; 0x80071f <settings+0x3c>
    55aa:	60 c0       	rjmp	.+192    	; 0x566c <settings_store_global_setting+0x1d8>
      case 13:
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
    55ac:	66 23       	and	r22, r22
    55ae:	31 f0       	breq	.+12     	; 0x55bc <settings_store_global_setting+0x128>
    55b0:	e3 ee       	ldi	r30, 0xE3	; 227
    55b2:	f6 e0       	ldi	r31, 0x06	; 6
    55b4:	85 ad       	ldd	r24, Z+61	; 0x3d
    55b6:	81 60       	ori	r24, 0x01	; 1
    55b8:	85 af       	std	Z+61, r24	; 0x3d
    55ba:	58 c0       	rjmp	.+176    	; 0x566c <settings_store_global_setting+0x1d8>
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
    55bc:	e3 ee       	ldi	r30, 0xE3	; 227
    55be:	f6 e0       	ldi	r31, 0x06	; 6
    55c0:	85 ad       	ldd	r24, Z+61	; 0x3d
    55c2:	8e 7f       	andi	r24, 0xFE	; 254
    55c4:	85 af       	std	Z+61, r24	; 0x3d
    55c6:	52 c0       	rjmp	.+164    	; 0x566c <settings_store_global_setting+0x1d8>
        break;
      case 20:
        if (int_value) { 
    55c8:	66 23       	and	r22, r22
    55ca:	41 f0       	breq	.+16     	; 0x55dc <settings_store_global_setting+0x148>
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    55cc:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    55d0:	84 ff       	sbrs	r24, 4
    55d2:	58 c0       	rjmp	.+176    	; 0x5684 <settings_store_global_setting+0x1f0>
          settings.flags |= BITFLAG_SOFT_LIMIT_ENABLE; 
    55d4:	80 62       	ori	r24, 0x20	; 32
    55d6:	80 93 20 07 	sts	0x0720, r24	; 0x800720 <settings+0x3d>
    55da:	48 c0       	rjmp	.+144    	; 0x566c <settings_store_global_setting+0x1d8>
        } else { settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; }
    55dc:	e3 ee       	ldi	r30, 0xE3	; 227
    55de:	f6 e0       	ldi	r31, 0x06	; 6
    55e0:	85 ad       	ldd	r24, Z+61	; 0x3d
    55e2:	8f 7d       	andi	r24, 0xDF	; 223
    55e4:	85 af       	std	Z+61, r24	; 0x3d
    55e6:	42 c0       	rjmp	.+132    	; 0x566c <settings_store_global_setting+0x1d8>
        break;
      case 21:
        if (int_value) { settings.flags |= BITFLAG_HARD_LIMIT_ENABLE; }
    55e8:	66 23       	and	r22, r22
    55ea:	31 f0       	breq	.+12     	; 0x55f8 <settings_store_global_setting+0x164>
    55ec:	e3 ee       	ldi	r30, 0xE3	; 227
    55ee:	f6 e0       	ldi	r31, 0x06	; 6
    55f0:	85 ad       	ldd	r24, Z+61	; 0x3d
    55f2:	88 60       	ori	r24, 0x08	; 8
    55f4:	85 af       	std	Z+61, r24	; 0x3d
    55f6:	05 c0       	rjmp	.+10     	; 0x5602 <settings_store_global_setting+0x16e>
        else { settings.flags &= ~BITFLAG_HARD_LIMIT_ENABLE; }
    55f8:	e3 ee       	ldi	r30, 0xE3	; 227
    55fa:	f6 e0       	ldi	r31, 0x06	; 6
    55fc:	85 ad       	ldd	r24, Z+61	; 0x3d
    55fe:	87 7f       	andi	r24, 0xF7	; 247
    5600:	85 af       	std	Z+61, r24	; 0x3d
        limits_init(); // Re-init to immediately change. NOTE: Nice to have but could be problematic later.
    5602:	0e 94 11 11 	call	0x2222	; 0x2222 <limits_init>
        break;
    5606:	32 c0       	rjmp	.+100    	; 0x566c <settings_store_global_setting+0x1d8>
      case 22:
        if (int_value) { settings.flags |= BITFLAG_HOMING_ENABLE; }
    5608:	66 23       	and	r22, r22
    560a:	31 f0       	breq	.+12     	; 0x5618 <settings_store_global_setting+0x184>
    560c:	e3 ee       	ldi	r30, 0xE3	; 227
    560e:	f6 e0       	ldi	r31, 0x06	; 6
    5610:	85 ad       	ldd	r24, Z+61	; 0x3d
    5612:	80 61       	ori	r24, 0x10	; 16
    5614:	85 af       	std	Z+61, r24	; 0x3d
    5616:	2a c0       	rjmp	.+84     	; 0x566c <settings_store_global_setting+0x1d8>
        else { 
          settings.flags &= ~BITFLAG_HOMING_ENABLE; 
          settings.flags &= ~BITFLAG_SOFT_LIMIT_ENABLE; // Force disable soft-limits.
    5618:	e3 ee       	ldi	r30, 0xE3	; 227
    561a:	f6 e0       	ldi	r31, 0x06	; 6
    561c:	85 ad       	ldd	r24, Z+61	; 0x3d
    561e:	8f 7c       	andi	r24, 0xCF	; 207
    5620:	85 af       	std	Z+61, r24	; 0x3d
    5622:	24 c0       	rjmp	.+72     	; 0x566c <settings_store_global_setting+0x1d8>
        }
        break;
      case 23: settings.homing_dir_mask = int_value; break;
    5624:	60 93 21 07 	sts	0x0721, r22	; 0x800721 <settings+0x3e>
    5628:	21 c0       	rjmp	.+66     	; 0x566c <settings_store_global_setting+0x1d8>
      case 24: settings.homing_feed_rate = value; break;
    562a:	c0 92 22 07 	sts	0x0722, r12	; 0x800722 <settings+0x3f>
    562e:	d0 92 23 07 	sts	0x0723, r13	; 0x800723 <settings+0x40>
    5632:	e0 92 24 07 	sts	0x0724, r14	; 0x800724 <settings+0x41>
    5636:	f0 92 25 07 	sts	0x0725, r15	; 0x800725 <settings+0x42>
    563a:	18 c0       	rjmp	.+48     	; 0x566c <settings_store_global_setting+0x1d8>
      case 25: settings.homing_seek_rate = value; break;
    563c:	c0 92 26 07 	sts	0x0726, r12	; 0x800726 <settings+0x43>
    5640:	d0 92 27 07 	sts	0x0727, r13	; 0x800727 <settings+0x44>
    5644:	e0 92 28 07 	sts	0x0728, r14	; 0x800728 <settings+0x45>
    5648:	f0 92 29 07 	sts	0x0729, r15	; 0x800729 <settings+0x46>
    564c:	0f c0       	rjmp	.+30     	; 0x566c <settings_store_global_setting+0x1d8>
      case 26: settings.homing_debounce_delay = int_value; break;
    564e:	86 2f       	mov	r24, r22
    5650:	90 e0       	ldi	r25, 0x00	; 0
    5652:	90 93 2b 07 	sts	0x072B, r25	; 0x80072b <settings+0x48>
    5656:	80 93 2a 07 	sts	0x072A, r24	; 0x80072a <settings+0x47>
    565a:	08 c0       	rjmp	.+16     	; 0x566c <settings_store_global_setting+0x1d8>
      case 27: settings.homing_pulloff = value; break;
    565c:	c0 92 2c 07 	sts	0x072C, r12	; 0x80072c <settings+0x49>
    5660:	d0 92 2d 07 	sts	0x072D, r13	; 0x80072d <settings+0x4a>
    5664:	e0 92 2e 07 	sts	0x072E, r14	; 0x80072e <settings+0x4b>
    5668:	f0 92 2f 07 	sts	0x072F, r15	; 0x80072f <settings+0x4c>
      default: 
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
    566c:	0e 94 0f 29 	call	0x521e	; 0x521e <write_global_settings>
  return(STATUS_OK);
    5670:	80 e0       	ldi	r24, 0x00	; 0
    5672:	58 c0       	rjmp	.+176    	; 0x5724 <settings_store_global_setting+0x290>
}


// A helper method to set settings from command line
uint8_t settings_store_global_setting(uint8_t parameter, float value) {
  if (value < 0.0) { return(STATUS_NEGATIVE_VALUE); } 
    5674:	84 e0       	ldi	r24, 0x04	; 4
    5676:	56 c0       	rjmp	.+172    	; 0x5724 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5678:	83 e0       	ldi	r24, 0x03	; 3
    567a:	54 c0       	rjmp	.+168    	; 0x5724 <settings_store_global_setting+0x290>
      case 24: settings.homing_feed_rate = value; break;
      case 25: settings.homing_seek_rate = value; break;
      case 26: settings.homing_debounce_delay = int_value; break;
      case 27: settings.homing_pulloff = value; break;
      default: 
        return(STATUS_INVALID_STATEMENT);
    567c:	83 e0       	ldi	r24, 0x03	; 3
    567e:	52 c0       	rjmp	.+164    	; 0x5724 <settings_store_global_setting+0x290>
  } else {
    // Store non-axis Grbl settings
    uint8_t int_value = trunc(value);
    switch(parameter) {
      case 0: 
        if (int_value < 3) { return(STATUS_SETTING_STEP_PULSE_MIN); }
    5680:	86 e0       	ldi	r24, 0x06	; 6
    5682:	50 c0       	rjmp	.+160    	; 0x5724 <settings_store_global_setting+0x290>
        if (int_value) { settings.flags |= BITFLAG_REPORT_INCHES; }
        else { settings.flags &= ~BITFLAG_REPORT_INCHES; }
        break;
      case 20:
        if (int_value) { 
          if (bit_isfalse(settings.flags, BITFLAG_HOMING_ENABLE)) { return(STATUS_SOFT_LIMIT_ERROR); }
    5684:	8a e0       	ldi	r24, 0x0A	; 10
    5686:	4e c0       	rjmp	.+156    	; 0x5724 <settings_store_global_setting+0x290>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5688:	83 e0       	ldi	r24, 0x03	; 3
    568a:	4c c0       	rjmp	.+152    	; 0x5724 <settings_store_global_setting+0x290>
    568c:	83 e0       	ldi	r24, 0x03	; 3
    568e:	4a c0       	rjmp	.+148    	; 0x5724 <settings_store_global_setting+0x290>
        parameter -= AXIS_SETTINGS_INCREMENT;
    5690:	e2 e9       	ldi	r30, 0x92	; 146
    5692:	ec 0f       	add	r30, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    5694:	e3 30       	cpi	r30, 0x03	; 3
    5696:	70 f0       	brcs	.+28     	; 0x56b4 <settings_store_global_setting+0x220>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    5698:	ea 30       	cpi	r30, 0x0A	; 10
    569a:	b0 f3       	brcs	.-20     	; 0x5688 <settings_store_global_setting+0x1f4>
        parameter -= AXIS_SETTINGS_INCREMENT;
    569c:	88 e8       	ldi	r24, 0x88	; 136
    569e:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    56a0:	83 30       	cpi	r24, 0x03	; 3
    56a2:	a0 f0       	brcs	.+40     	; 0x56cc <settings_store_global_setting+0x238>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56a4:	8a 30       	cpi	r24, 0x0A	; 10
    56a6:	90 f3       	brcs	.-28     	; 0x568c <settings_store_global_setting+0x1f8>
        parameter -= AXIS_SETTINGS_INCREMENT;
    56a8:	8e e7       	ldi	r24, 0x7E	; 126
    56aa:	8c 0f       	add	r24, r28
    // Store axis configuration. Axis numbering sequence set by AXIS_SETTING defines.
    // NOTE: Ensure the setting index corresponds to the report.c settings printout.
    parameter -= AXIS_SETTINGS_START_VAL;
    uint8_t set_idx = 0;
    while (set_idx < AXIS_N_SETTINGS) {
      if (parameter < N_AXIS) {
    56ac:	83 30       	cpi	r24, 0x03	; 3
    56ae:	48 f1       	brcs	.+82     	; 0x5702 <settings_store_global_setting+0x26e>
        }
        break; // Exit while-loop after setting has been configured and proceed to the EEPROM write call.
      } else {
        set_idx++;
        // If axis index greater than N_AXIS or setting index greater than number of axis settings, error out.
        if ((parameter < AXIS_SETTINGS_INCREMENT) || (set_idx == AXIS_N_SETTINGS)) { return(STATUS_INVALID_STATEMENT); }
    56b0:	83 e0       	ldi	r24, 0x03	; 3
    56b2:	38 c0       	rjmp	.+112    	; 0x5724 <settings_store_global_setting+0x290>
            break;
          case 1:
            #ifdef MAX_STEP_RATE_HZ
              if (value*settings.steps_per_mm[parameter] > (MAX_STEP_RATE_HZ*60.0)) {  return(STATUS_MAX_STEP_RATE_EXCEEDED); }
            #endif
            settings.max_rate[parameter] = value;
    56b4:	f0 e0       	ldi	r31, 0x00	; 0
    56b6:	ee 0f       	add	r30, r30
    56b8:	ff 1f       	adc	r31, r31
    56ba:	ee 0f       	add	r30, r30
    56bc:	ff 1f       	adc	r31, r31
    56be:	e1 51       	subi	r30, 0x11	; 17
    56c0:	f9 4f       	sbci	r31, 0xF9	; 249
    56c2:	c0 82       	st	Z, r12
    56c4:	d1 82       	std	Z+1, r13	; 0x01
    56c6:	e2 82       	std	Z+2, r14	; 0x02
    56c8:	f3 82       	std	Z+3, r15	; 0x03
            break;
    56ca:	d0 cf       	rjmp	.-96     	; 0x566c <settings_store_global_setting+0x1d8>
          case 2: settings.acceleration[parameter] = value*60*60; break; // Convert to mm/min^2 for grbl internal use.
    56cc:	c8 2f       	mov	r28, r24
    56ce:	d0 e0       	ldi	r29, 0x00	; 0
    56d0:	cc 0f       	add	r28, r28
    56d2:	dd 1f       	adc	r29, r29
    56d4:	cc 0f       	add	r28, r28
    56d6:	dd 1f       	adc	r29, r29
    56d8:	c5 50       	subi	r28, 0x05	; 5
    56da:	d9 4f       	sbci	r29, 0xF9	; 249
    56dc:	20 e0       	ldi	r18, 0x00	; 0
    56de:	30 e0       	ldi	r19, 0x00	; 0
    56e0:	40 e7       	ldi	r20, 0x70	; 112
    56e2:	52 e4       	ldi	r21, 0x42	; 66
    56e4:	c7 01       	movw	r24, r14
    56e6:	b6 01       	movw	r22, r12
    56e8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    56ec:	20 e0       	ldi	r18, 0x00	; 0
    56ee:	30 e0       	ldi	r19, 0x00	; 0
    56f0:	40 e7       	ldi	r20, 0x70	; 112
    56f2:	52 e4       	ldi	r21, 0x42	; 66
    56f4:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    56f8:	68 83       	st	Y, r22
    56fa:	79 83       	std	Y+1, r23	; 0x01
    56fc:	8a 83       	std	Y+2, r24	; 0x02
    56fe:	9b 83       	std	Y+3, r25	; 0x03
    5700:	b5 cf       	rjmp	.-150    	; 0x566c <settings_store_global_setting+0x1d8>
          case 3: settings.max_travel[parameter] = -value; break;  // Store as negative for grbl internal use.
    5702:	e8 2f       	mov	r30, r24
    5704:	f0 e0       	ldi	r31, 0x00	; 0
    5706:	ee 0f       	add	r30, r30
    5708:	ff 1f       	adc	r31, r31
    570a:	ee 0f       	add	r30, r30
    570c:	ff 1f       	adc	r31, r31
    570e:	e9 5f       	subi	r30, 0xF9	; 249
    5710:	f8 4f       	sbci	r31, 0xF8	; 248
    5712:	f7 fa       	bst	r15, 7
    5714:	f0 94       	com	r15
    5716:	f7 f8       	bld	r15, 7
    5718:	f0 94       	com	r15
    571a:	c0 82       	st	Z, r12
    571c:	d1 82       	std	Z+1, r13	; 0x01
    571e:	e2 82       	std	Z+2, r14	; 0x02
    5720:	f3 82       	std	Z+3, r15	; 0x03
    5722:	a4 cf       	rjmp	.-184    	; 0x566c <settings_store_global_setting+0x1d8>
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    5724:	df 91       	pop	r29
    5726:	cf 91       	pop	r28
    5728:	ff 90       	pop	r15
    572a:	ef 90       	pop	r14
    572c:	df 90       	pop	r13
    572e:	cf 90       	pop	r12
    5730:	08 95       	ret

00005732 <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    5732:	0e 94 34 2a 	call	0x5468	; 0x5468 <read_global_settings>
    5736:	81 11       	cpse	r24, r1
    5738:	08 c0       	rjmp	.+16     	; 0x574a <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
    573a:	87 e0       	ldi	r24, 0x07	; 7
    573c:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    5740:	8f ef       	ldi	r24, 0xFF	; 255
    5742:	0e 94 1d 29 	call	0x523a	; 0x523a <settings_restore>
    report_grbl_settings();
    5746:	0e 94 39 23 	call	0x4672	; 0x4672 <report_grbl_settings>
    574a:	08 95       	ret

0000574c <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    574c:	88 23       	and	r24, r24
    574e:	21 f0       	breq	.+8      	; 0x5758 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    5750:	81 30       	cpi	r24, 0x01	; 1
    5752:	21 f0       	breq	.+8      	; 0x575c <get_step_pin_mask+0x10>
  return((1<<Z_STEP_BIT));
    5754:	80 e1       	ldi	r24, 0x10	; 16
    5756:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    5758:	84 e0       	ldi	r24, 0x04	; 4
    575a:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    575c:	88 e0       	ldi	r24, 0x08	; 8
  return((1<<Z_STEP_BIT));
}
    575e:	08 95       	ret

00005760 <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    5760:	88 23       	and	r24, r24
    5762:	21 f0       	breq	.+8      	; 0x576c <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5764:	81 30       	cpi	r24, 0x01	; 1
    5766:	21 f0       	breq	.+8      	; 0x5770 <get_direction_pin_mask+0x10>
  return((1<<Z_DIRECTION_BIT));
    5768:	80 e8       	ldi	r24, 0x80	; 128
    576a:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    576c:	80 e2       	ldi	r24, 0x20	; 32
    576e:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    5770:	80 e4       	ldi	r24, 0x40	; 64
  return((1<<Z_DIRECTION_BIT));
}
    5772:	08 95       	ret

00005774 <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5774:	88 23       	and	r24, r24
    5776:	21 f0       	breq	.+8      	; 0x5780 <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5778:	81 30       	cpi	r24, 0x01	; 1
    577a:	21 f0       	breq	.+8      	; 0x5784 <get_limit_pin_mask+0x10>
  return((1<<Z_LIMIT_BIT));
    577c:	80 e1       	ldi	r24, 0x10	; 16
    577e:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    5780:	82 e0       	ldi	r24, 0x02	; 2
    5782:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    5784:	84 e0       	ldi	r24, 0x04	; 4
  return((1<<Z_LIMIT_BIT));
}
    5786:	08 95       	ret

00005788 <spindle_stop>:

void spindle_stop()
{
  // On the Uno, spindle enable and PWM are shared. Other CPUs have seperate enable pin.
  #ifdef VARIABLE_SPINDLE
    TCCRA_REGISTER &= ~(1<<COMB_BIT); // Disable PWM. Output voltage is zero.
    5788:	e0 eb       	ldi	r30, 0xB0	; 176
    578a:	f0 e0       	ldi	r31, 0x00	; 0
    578c:	80 81       	ld	r24, Z
    578e:	8f 77       	andi	r24, 0x7F	; 127
    5790:	80 83       	st	Z, r24
    5792:	08 95       	ret

00005794 <spindle_init>:
void spindle_init()
{    
  // Configure variable spindle PWM and enable pin, if requried. On the Uno, PWM and enable are
  // combined unless configured otherwise.
  #ifdef VARIABLE_SPINDLE
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    5794:	23 9a       	sbi	0x04, 3	; 4
  #else  
    SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
  #endif
  
  #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
    SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    5796:	25 9a       	sbi	0x04, 5	; 4
  #endif
  spindle_stop();
    5798:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
    579c:	08 95       	ret

0000579e <spindle_set_state>:
  #endif  
}


void spindle_set_state(uint8_t state, float rpm)
{
    579e:	cf 92       	push	r12
    57a0:	df 92       	push	r13
    57a2:	ef 92       	push	r14
    57a4:	ff 92       	push	r15
    57a6:	6a 01       	movw	r12, r20
    57a8:	7b 01       	movw	r14, r22
  // Halt or set spindle direction and rpm. 
  if (state == SPINDLE_DISABLE) {
    57aa:	81 11       	cpse	r24, r1
    57ac:	03 c0       	rjmp	.+6      	; 0x57b4 <spindle_set_state+0x16>

    spindle_stop();
    57ae:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
    57b2:	4d c0       	rjmp	.+154    	; 0x584e <spindle_set_state+0xb0>

  } else {

    #ifndef USE_SPINDLE_DIR_AS_ENABLE_PIN
      if (state == SPINDLE_ENABLE_CW) {
    57b4:	81 30       	cpi	r24, 0x01	; 1
    57b6:	11 f4       	brne	.+4      	; 0x57bc <spindle_set_state+0x1e>
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    57b8:	2d 98       	cbi	0x05, 5	; 5
    57ba:	01 c0       	rjmp	.+2      	; 0x57be <spindle_set_state+0x20>
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    57bc:	2d 9a       	sbi	0x05, 5	; 5
      	TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02 | (1<<WAVE2_REGISTER) | (1<<WAVE3_REGISTER); // set to 1/8 Prescaler
        OCR4A = 0xFFFF; // set the top 16bit value
        uint16_t current_pwm;
      #else
        TCCRA_REGISTER = (1<<COMB_BIT) | (1<<WAVE1_REGISTER) | (1<<WAVE0_REGISTER);
    57be:	83 e8       	ldi	r24, 0x83	; 131
    57c0:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
        TCCRB_REGISTER = (TCCRB_REGISTER & 0b11111000) | 0x02; // set to 1/8 Prescaler
    57c4:	e1 eb       	ldi	r30, 0xB1	; 177
    57c6:	f0 e0       	ldi	r31, 0x00	; 0
    57c8:	80 81       	ld	r24, Z
    57ca:	88 7f       	andi	r24, 0xF8	; 248
    57cc:	82 60       	ori	r24, 0x02	; 2
    57ce:	80 83       	st	Z, r24
        uint8_t current_pwm;
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
    57d0:	20 e0       	ldi	r18, 0x00	; 0
    57d2:	30 e0       	ldi	r19, 0x00	; 0
    57d4:	a9 01       	movw	r20, r18
    57d6:	c7 01       	movw	r24, r14
    57d8:	b6 01       	movw	r22, r12
    57da:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    57de:	18 16       	cp	r1, r24
    57e0:	1c f0       	brlt	.+6      	; 0x57e8 <spindle_set_state+0x4a>
    57e2:	0e 94 c4 2b 	call	0x5788	; 0x5788 <spindle_stop>
    57e6:	33 c0       	rjmp	.+102    	; 0x584e <spindle_set_state+0xb0>
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    57e8:	20 e0       	ldi	r18, 0x00	; 0
    57ea:	30 e0       	ldi	r19, 0x00	; 0
    57ec:	a9 01       	movw	r20, r18
    57ee:	c7 01       	movw	r24, r14
    57f0:	b6 01       	movw	r22, r12
    57f2:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    57f6:	88 23       	and	r24, r24
    57f8:	9c f0       	brlt	.+38     	; 0x5820 <spindle_set_state+0x82>
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
    57fa:	20 e0       	ldi	r18, 0x00	; 0
    57fc:	30 e0       	ldi	r19, 0x00	; 0
    57fe:	4a e7       	ldi	r20, 0x7A	; 122
    5800:	54 e4       	ldi	r21, 0x44	; 68
    5802:	c7 01       	movw	r24, r14
    5804:	b6 01       	movw	r22, r12
    5806:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    580a:	18 16       	cp	r1, r24
    580c:	64 f4       	brge	.+24     	; 0x5826 <spindle_set_state+0x88>
    580e:	0f 2e       	mov	r0, r31
    5810:	c1 2c       	mov	r12, r1
    5812:	d1 2c       	mov	r13, r1
    5814:	fa e7       	ldi	r31, 0x7A	; 122
    5816:	ef 2e       	mov	r14, r31
    5818:	f4 e4       	ldi	r31, 0x44	; 68
    581a:	ff 2e       	mov	r15, r31
    581c:	f0 2d       	mov	r31, r0
    581e:	03 c0       	rjmp	.+6      	; 0x5826 <spindle_set_state+0x88>
      #endif

      if (rpm <= 0.0) { spindle_stop(); } // RPM should never be negative, but check anyway.
      else {
        #define SPINDLE_RPM_RANGE (SPINDLE_MAX_RPM-SPINDLE_MIN_RPM)
        if ( rpm < SPINDLE_MIN_RPM ) { rpm = 0; } 
    5820:	c1 2c       	mov	r12, r1
    5822:	d1 2c       	mov	r13, r1
    5824:	76 01       	movw	r14, r12
        else { 
          rpm -= SPINDLE_MIN_RPM; 
          if ( rpm > SPINDLE_RPM_RANGE ) { rpm = SPINDLE_RPM_RANGE; } // Prevent integer overflow
        }
        current_pwm = floor( rpm*(PWM_MAX_VALUE/SPINDLE_RPM_RANGE) + 0.5);
    5826:	2c e5       	ldi	r18, 0x5C	; 92
    5828:	3f e8       	ldi	r19, 0x8F	; 143
    582a:	42 e8       	ldi	r20, 0x82	; 130
    582c:	5e e3       	ldi	r21, 0x3E	; 62
    582e:	c7 01       	movw	r24, r14
    5830:	b6 01       	movw	r22, r12
    5832:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    5836:	20 e0       	ldi	r18, 0x00	; 0
    5838:	30 e0       	ldi	r19, 0x00	; 0
    583a:	40 e0       	ldi	r20, 0x00	; 0
    583c:	5f e3       	ldi	r21, 0x3F	; 63
    583e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    5842:	0e 94 9a 3b 	call	0x7734	; 0x7734 <floor>
    5846:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
        #ifdef MINIMUM_SPINDLE_PWM
          if (current_pwm < MINIMUM_SPINDLE_PWM) { current_pwm = MINIMUM_SPINDLE_PWM; }
        #endif
        OCR_REGISTER = current_pwm; // Set PWM pin output
    584a:	60 93 b3 00 	sts	0x00B3, r22	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7e00b3>
        SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
      #endif
    #endif

  }
}
    584e:	ff 90       	pop	r15
    5850:	ef 90       	pop	r14
    5852:	df 90       	pop	r13
    5854:	cf 90       	pop	r12
    5856:	08 95       	ret

00005858 <spindle_run>:


void spindle_run(uint8_t state, float rpm)
{
    5858:	cf 92       	push	r12
    585a:	df 92       	push	r13
    585c:	ef 92       	push	r14
    585e:	ff 92       	push	r15
    5860:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    5862:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <sys+0x1>
    5866:	92 30       	cpi	r25, 0x02	; 2
    5868:	51 f0       	breq	.+20     	; 0x587e <spindle_run+0x26>
    586a:	6a 01       	movw	r12, r20
    586c:	7b 01       	movw	r14, r22
    586e:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.  
    5870:	0e 94 3b 22 	call	0x4476	; 0x4476 <protocol_buffer_synchronize>
  spindle_set_state(state, rpm);
    5874:	b7 01       	movw	r22, r14
    5876:	a6 01       	movw	r20, r12
    5878:	8c 2f       	mov	r24, r28
    587a:	0e 94 cf 2b 	call	0x579e	; 0x579e <spindle_set_state>
}
    587e:	cf 91       	pop	r28
    5880:	ff 90       	pop	r15
    5882:	ef 90       	pop	r14
    5884:	df 90       	pop	r13
    5886:	cf 90       	pop	r12
    5888:	08 95       	ret

0000588a <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up() 
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    588a:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    588e:	82 ff       	sbrs	r24, 2
    5890:	02 c0       	rjmp	.+4      	; 0x5896 <st_wake_up+0xc>
    5892:	28 9a       	sbi	0x05, 0	; 5
    5894:	01 c0       	rjmp	.+2      	; 0x5898 <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    5896:	28 98       	cbi	0x05, 0	; 5

  if (sys.state & (STATE_CYCLE | STATE_HOMING)){
    5898:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    589c:	8c 70       	andi	r24, 0x0C	; 12
    589e:	99 f0       	breq	.+38     	; 0x58c6 <st_wake_up+0x3c>
    // Initialize stepper output bits
    st.dir_outbits = dir_port_invert_mask; 
    58a0:	ed ee       	ldi	r30, 0xED	; 237
    58a2:	f4 e0       	ldi	r31, 0x04	; 4
    58a4:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <dir_port_invert_mask>
    58a8:	87 87       	std	Z+15, r24	; 0x0f
    st.step_outbits = step_port_invert_mask;
    58aa:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <step_port_invert_mask>
    58ae:	86 87       	std	Z+14, r24	; 0x0e
      st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
      // Set delay between direction pin write and step command.
      OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
    #else // Normal operation
      // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
      st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    58b0:	80 91 13 07 	lds	r24, 0x0713	; 0x800713 <settings+0x30>
    58b4:	88 0f       	add	r24, r24
    58b6:	84 50       	subi	r24, 0x04	; 4
    58b8:	81 95       	neg	r24
    58ba:	85 87       	std	Z+13, r24	; 0x0d
    #endif

    // Enable Stepper Driver Interrupt
    TIMSK1 |= (1<<OCIE1A);
    58bc:	ef e6       	ldi	r30, 0x6F	; 111
    58be:	f0 e0       	ldi	r31, 0x00	; 0
    58c0:	80 81       	ld	r24, Z
    58c2:	82 60       	ori	r24, 0x02	; 2
    58c4:	80 83       	st	Z, r24
    58c6:	08 95       	ret

000058c8 <st_go_idle>:

// Stepper shutdown
void st_go_idle() 
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    58c8:	ef e6       	ldi	r30, 0x6F	; 111
    58ca:	f0 e0       	ldi	r31, 0x00	; 0
    58cc:	80 81       	ld	r24, Z
    58ce:	8d 7f       	andi	r24, 0xFD	; 253
    58d0:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    58d2:	e1 e8       	ldi	r30, 0x81	; 129
    58d4:	f0 e0       	ldi	r31, 0x00	; 0
    58d6:	80 81       	ld	r24, Z
    58d8:	88 7f       	andi	r24, 0xF8	; 248
    58da:	81 60       	ori	r24, 0x01	; 1
    58dc:	80 83       	st	Z, r24
  busy = false;
    58de:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <busy>
  
  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm) && sys.state != STATE_HOMING) {
    58e2:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <settings+0x33>
    58e6:	8f 3f       	cpi	r24, 0xFF	; 255
    58e8:	21 f4       	brne	.+8      	; 0x58f2 <st_go_idle+0x2a>
    58ea:	90 91 8b 05 	lds	r25, 0x058B	; 0x80058b <sys_rt_exec_alarm>
    58ee:	99 23       	and	r25, r25
    58f0:	79 f0       	breq	.+30     	; 0x5910 <st_go_idle+0x48>
    58f2:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <sys+0x1>
    58f6:	94 30       	cpi	r25, 0x04	; 4
    58f8:	59 f0       	breq	.+22     	; 0x5910 <st_go_idle+0x48>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    58fa:	90 e0       	ldi	r25, 0x00	; 0
    58fc:	0e 94 3c 19 	call	0x3278	; 0x3278 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    5900:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    5904:	82 fd       	sbrc	r24, 2
    5906:	02 c0       	rjmp	.+4      	; 0x590c <st_go_idle+0x44>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    5908:	28 9a       	sbi	0x05, 0	; 5
    590a:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    590c:	28 98       	cbi	0x05, 0	; 5
}
    590e:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    5910:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    5914:	82 ff       	sbrs	r24, 2
    5916:	fa cf       	rjmp	.-12     	; 0x590c <st_go_idle+0x44>
    5918:	f7 cf       	rjmp	.-18     	; 0x5908 <st_go_idle+0x40>

0000591a <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated 
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{        
    591a:	1f 92       	push	r1
    591c:	0f 92       	push	r0
    591e:	0f b6       	in	r0, 0x3f	; 63
    5920:	0f 92       	push	r0
    5922:	11 24       	eor	r1, r1
    5924:	0f 93       	push	r16
    5926:	1f 93       	push	r17
    5928:	2f 93       	push	r18
    592a:	3f 93       	push	r19
    592c:	4f 93       	push	r20
    592e:	5f 93       	push	r21
    5930:	6f 93       	push	r22
    5932:	7f 93       	push	r23
    5934:	8f 93       	push	r24
    5936:	9f 93       	push	r25
    5938:	af 93       	push	r26
    593a:	bf 93       	push	r27
    593c:	cf 93       	push	r28
    593e:	df 93       	push	r29
    5940:	ef 93       	push	r30
    5942:	ff 93       	push	r31
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    5944:	80 91 e7 04 	lds	r24, 0x04E7	; 0x8004e7 <busy>
    5948:	81 11       	cpse	r24, r1
    594a:	b5 c1       	rjmp	.+874    	; 0x5cb6 <__vector_11+0x39c>
  
  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    594c:	8b b1       	in	r24, 0x0b	; 11
    594e:	ed ee       	ldi	r30, 0xED	; 237
    5950:	f4 e0       	ldi	r31, 0x04	; 4
    5952:	97 85       	ldd	r25, Z+15	; 0x0f
    5954:	90 7e       	andi	r25, 0xE0	; 224
    5956:	8f 71       	andi	r24, 0x1F	; 31
    5958:	89 2b       	or	r24, r25
    595a:	8b b9       	out	0x0b, r24	; 11

  // Then pulse the stepping pins
  #ifdef STEP_PULSE_DELAY
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    595c:	8b b1       	in	r24, 0x0b	; 11
    595e:	83 7e       	andi	r24, 0xE3	; 227
    5960:	96 85       	ldd	r25, Z+14	; 0x0e
    5962:	89 2b       	or	r24, r25
    5964:	8b b9       	out	0x0b, r24	; 11
  #endif  

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    5966:	85 85       	ldd	r24, Z+13	; 0x0d
    5968:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    596a:	82 e0       	ldi	r24, 0x02	; 2
    596c:	85 bd       	out	0x25, r24	; 37

  busy = true;
    596e:	81 e0       	ldi	r24, 0x01	; 1
    5970:	80 93 e7 04 	sts	0x04E7, r24	; 0x8004e7 <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time. 
    5974:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.
    
  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    5976:	81 a1       	ldd	r24, Z+33	; 0x21
    5978:	92 a1       	ldd	r25, Z+34	; 0x22
    597a:	89 2b       	or	r24, r25
    597c:	09 f0       	breq	.+2      	; 0x5980 <__vector_11+0x66>
    597e:	92 c0       	rjmp	.+292    	; 0x5aa4 <__vector_11+0x18a>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    5980:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <segment_buffer_tail>
    5984:	90 91 eb 04 	lds	r25, 0x04EB	; 0x8004eb <segment_buffer_head>
    5988:	98 17       	cp	r25, r24
    598a:	09 f4       	brne	.+2      	; 0x598e <__vector_11+0x74>
    598c:	80 c0       	rjmp	.+256    	; 0x5a8e <__vector_11+0x174>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    598e:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <segment_buffer_tail>
    5992:	90 e0       	ldi	r25, 0x00	; 0
    5994:	ef 01       	movw	r28, r30
    5996:	fc 01       	movw	r30, r24
    5998:	ee 0f       	add	r30, r30
    599a:	ff 1f       	adc	r31, r31
    599c:	df 01       	movw	r26, r30
    599e:	a8 0f       	add	r26, r24
    59a0:	b9 1f       	adc	r27, r25
    59a2:	aa 0f       	add	r26, r26
    59a4:	bb 1f       	adc	r27, r27
    59a6:	a0 5f       	subi	r26, 0xF0	; 240
    59a8:	ba 4f       	sbci	r27, 0xFA	; 250
    59aa:	ba a3       	std	Y+34, r27	; 0x22
    59ac:	a9 a3       	std	Y+33, r26	; 0x21
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    59ae:	fd 01       	movw	r30, r26
    59b0:	83 81       	ldd	r24, Z+3	; 0x03
    59b2:	94 81       	ldd	r25, Z+4	; 0x04
    59b4:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
    59b8:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    59bc:	8d 91       	ld	r24, X+
    59be:	9c 91       	ld	r25, X
    59c0:	11 97       	sbiw	r26, 0x01	; 1
    59c2:	9d 8f       	std	Y+29, r25	; 0x1d
    59c4:	8c 8f       	std	Y+28, r24	; 0x1c
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    59c6:	12 96       	adiw	r26, 0x02	; 2
    59c8:	ec 91       	ld	r30, X
    59ca:	12 97       	sbiw	r26, 0x02	; 2
    59cc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    59ce:	8e 17       	cp	r24, r30
    59d0:	e9 f0       	breq	.+58     	; 0x5a0c <__vector_11+0xf2>
        st.exec_block_index = st.exec_segment->st_block_index;
    59d2:	ee 8f       	std	Y+30, r30	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    59d4:	01 e1       	ldi	r16, 0x11	; 17
    59d6:	e0 9f       	mul	r30, r16
    59d8:	f0 01       	movw	r30, r0
    59da:	11 24       	eor	r1, r1
    59dc:	ec 5c       	subi	r30, 0xCC	; 204
    59de:	fa 4f       	sbci	r31, 0xFA	; 250
    59e0:	f8 a3       	std	Y+32, r31	; 0x20
    59e2:	ef 8f       	std	Y+31, r30	; 0x1f
        
        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    59e4:	45 85       	ldd	r20, Z+13	; 0x0d
    59e6:	56 85       	ldd	r21, Z+14	; 0x0e
    59e8:	67 85       	ldd	r22, Z+15	; 0x0f
    59ea:	70 89       	ldd	r23, Z+16	; 0x10
    59ec:	76 95       	lsr	r23
    59ee:	67 95       	ror	r22
    59f0:	57 95       	ror	r21
    59f2:	47 95       	ror	r20
    59f4:	48 87       	std	Y+8, r20	; 0x08
    59f6:	59 87       	std	Y+9, r21	; 0x09
    59f8:	6a 87       	std	Y+10, r22	; 0x0a
    59fa:	7b 87       	std	Y+11, r23	; 0x0b
    59fc:	4c 83       	std	Y+4, r20	; 0x04
    59fe:	5d 83       	std	Y+5, r21	; 0x05
    5a00:	6e 83       	std	Y+6, r22	; 0x06
    5a02:	7f 83       	std	Y+7, r23	; 0x07
    5a04:	48 83       	st	Y, r20
    5a06:	59 83       	std	Y+1, r21	; 0x01
    5a08:	6a 83       	std	Y+2, r22	; 0x02
    5a0a:	7b 83       	std	Y+3, r23	; 0x03
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask; 
    5a0c:	ed ee       	ldi	r30, 0xED	; 237
    5a0e:	f4 e0       	ldi	r31, 0x04	; 4
    5a10:	c7 8d       	ldd	r28, Z+31	; 0x1f
    5a12:	d0 a1       	ldd	r29, Z+32	; 0x20
    5a14:	98 81       	ld	r25, Y
    5a16:	80 91 e8 04 	lds	r24, 0x04E8	; 0x8004e8 <dir_port_invert_mask>
    5a1a:	89 27       	eor	r24, r25
    5a1c:	87 87       	std	Z+15, r24	; 0x0f

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    5a1e:	49 81       	ldd	r20, Y+1	; 0x01
    5a20:	5a 81       	ldd	r21, Y+2	; 0x02
    5a22:	6b 81       	ldd	r22, Y+3	; 0x03
    5a24:	7c 81       	ldd	r23, Y+4	; 0x04
    5a26:	15 96       	adiw	r26, 0x05	; 5
    5a28:	0c 90       	ld	r0, X
    5a2a:	15 97       	sbiw	r26, 0x05	; 5
    5a2c:	04 c0       	rjmp	.+8      	; 0x5a36 <__vector_11+0x11c>
    5a2e:	76 95       	lsr	r23
    5a30:	67 95       	ror	r22
    5a32:	57 95       	ror	r21
    5a34:	47 95       	ror	r20
    5a36:	0a 94       	dec	r0
    5a38:	d2 f7       	brpl	.-12     	; 0x5a2e <__vector_11+0x114>
    5a3a:	40 8b       	std	Z+16, r20	; 0x10
    5a3c:	51 8b       	std	Z+17, r21	; 0x11
    5a3e:	62 8b       	std	Z+18, r22	; 0x12
    5a40:	73 8b       	std	Z+19, r23	; 0x13
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    5a42:	4d 81       	ldd	r20, Y+5	; 0x05
    5a44:	5e 81       	ldd	r21, Y+6	; 0x06
    5a46:	6f 81       	ldd	r22, Y+7	; 0x07
    5a48:	78 85       	ldd	r23, Y+8	; 0x08
    5a4a:	15 96       	adiw	r26, 0x05	; 5
    5a4c:	0c 90       	ld	r0, X
    5a4e:	15 97       	sbiw	r26, 0x05	; 5
    5a50:	04 c0       	rjmp	.+8      	; 0x5a5a <__vector_11+0x140>
    5a52:	76 95       	lsr	r23
    5a54:	67 95       	ror	r22
    5a56:	57 95       	ror	r21
    5a58:	47 95       	ror	r20
    5a5a:	0a 94       	dec	r0
    5a5c:	d2 f7       	brpl	.-12     	; 0x5a52 <__vector_11+0x138>
    5a5e:	44 8b       	std	Z+20, r20	; 0x14
    5a60:	55 8b       	std	Z+21, r21	; 0x15
    5a62:	66 8b       	std	Z+22, r22	; 0x16
    5a64:	77 8b       	std	Z+23, r23	; 0x17
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    5a66:	49 85       	ldd	r20, Y+9	; 0x09
    5a68:	5a 85       	ldd	r21, Y+10	; 0x0a
    5a6a:	6b 85       	ldd	r22, Y+11	; 0x0b
    5a6c:	7c 85       	ldd	r23, Y+12	; 0x0c
    5a6e:	8a 01       	movw	r16, r20
    5a70:	9b 01       	movw	r18, r22
    5a72:	15 96       	adiw	r26, 0x05	; 5
    5a74:	0c 90       	ld	r0, X
    5a76:	04 c0       	rjmp	.+8      	; 0x5a80 <__vector_11+0x166>
    5a78:	36 95       	lsr	r19
    5a7a:	27 95       	ror	r18
    5a7c:	17 95       	ror	r17
    5a7e:	07 95       	ror	r16
    5a80:	0a 94       	dec	r0
    5a82:	d2 f7       	brpl	.-12     	; 0x5a78 <__vector_11+0x15e>
    5a84:	00 8f       	std	Z+24, r16	; 0x18
    5a86:	11 8f       	std	Z+25, r17	; 0x19
    5a88:	22 8f       	std	Z+26, r18	; 0x1a
    5a8a:	33 8f       	std	Z+27, r19	; 0x1b
    5a8c:	0b c0       	rjmp	.+22     	; 0x5aa4 <__vector_11+0x18a>
      #endif
      
    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    5a8e:	0e 94 64 2c 	call	0x58c8	; 0x58c8 <st_go_idle>
      bit_true_atomic(sys_rt_exec_state,EXEC_CYCLE_STOP); // Flag main program for cycle end
    5a92:	9f b7       	in	r25, 0x3f	; 63
    5a94:	f8 94       	cli
    5a96:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    5a9a:	84 60       	ori	r24, 0x04	; 4
    5a9c:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    5aa0:	9f bf       	out	0x3f, r25	; 63
      return; // Nothing to do but exit.
    5aa2:	09 c1       	rjmp	.+530    	; 0x5cb6 <__vector_11+0x39c>
    }  
  }
  
  
  // Check probing state.
  probe_state_monitor();
    5aa4:	0e 94 3e 20 	call	0x407c	; 0x407c <probe_state_monitor>
   
  // Reset step out bits.
  st.step_outbits = 0; 
    5aa8:	ed ee       	ldi	r30, 0xED	; 237
    5aaa:	f4 e0       	ldi	r31, 0x04	; 4
    5aac:	16 86       	std	Z+14, r1	; 0x0e

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    5aae:	40 81       	ld	r20, Z
    5ab0:	51 81       	ldd	r21, Z+1	; 0x01
    5ab2:	62 81       	ldd	r22, Z+2	; 0x02
    5ab4:	73 81       	ldd	r23, Z+3	; 0x03
    5ab6:	80 89       	ldd	r24, Z+16	; 0x10
    5ab8:	91 89       	ldd	r25, Z+17	; 0x11
    5aba:	a2 89       	ldd	r26, Z+18	; 0x12
    5abc:	b3 89       	ldd	r27, Z+19	; 0x13
    5abe:	84 0f       	add	r24, r20
    5ac0:	95 1f       	adc	r25, r21
    5ac2:	a6 1f       	adc	r26, r22
    5ac4:	b7 1f       	adc	r27, r23
    5ac6:	80 83       	st	Z, r24
    5ac8:	91 83       	std	Z+1, r25	; 0x01
    5aca:	a2 83       	std	Z+2, r26	; 0x02
    5acc:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif  
  if (st.counter_x > st.exec_block->step_event_count) {
    5ace:	07 8c       	ldd	r0, Z+31	; 0x1f
    5ad0:	f0 a1       	ldd	r31, Z+32	; 0x20
    5ad2:	e0 2d       	mov	r30, r0
    5ad4:	45 85       	ldd	r20, Z+13	; 0x0d
    5ad6:	56 85       	ldd	r21, Z+14	; 0x0e
    5ad8:	67 85       	ldd	r22, Z+15	; 0x0f
    5ada:	70 89       	ldd	r23, Z+16	; 0x10
    5adc:	48 17       	cp	r20, r24
    5ade:	59 07       	cpc	r21, r25
    5ae0:	6a 07       	cpc	r22, r26
    5ae2:	7b 07       	cpc	r23, r27
    5ae4:	70 f5       	brcc	.+92     	; 0x5b42 <__vector_11+0x228>
    st.step_outbits |= (1<<X_STEP_BIT);
    5ae6:	cd ee       	ldi	r28, 0xED	; 237
    5ae8:	d4 e0       	ldi	r29, 0x04	; 4
    5aea:	24 e0       	ldi	r18, 0x04	; 4
    5aec:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_x -= st.exec_block->step_event_count;
    5aee:	45 85       	ldd	r20, Z+13	; 0x0d
    5af0:	56 85       	ldd	r21, Z+14	; 0x0e
    5af2:	67 85       	ldd	r22, Z+15	; 0x0f
    5af4:	70 89       	ldd	r23, Z+16	; 0x10
    5af6:	84 1b       	sub	r24, r20
    5af8:	95 0b       	sbc	r25, r21
    5afa:	a6 0b       	sbc	r26, r22
    5afc:	b7 0b       	sbc	r27, r23
    5afe:	88 83       	st	Y, r24
    5b00:	99 83       	std	Y+1, r25	; 0x01
    5b02:	aa 83       	std	Y+2, r26	; 0x02
    5b04:	bb 83       	std	Y+3, r27	; 0x03
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys.position[X_AXIS]--; }
    5b06:	80 81       	ld	r24, Z
    5b08:	85 ff       	sbrs	r24, 5
    5b0a:	0e c0       	rjmp	.+28     	; 0x5b28 <__vector_11+0x20e>
    5b0c:	c4 e0       	ldi	r28, 0x04	; 4
    5b0e:	d6 e0       	ldi	r29, 0x06	; 6
    5b10:	8c 81       	ldd	r24, Y+4	; 0x04
    5b12:	9d 81       	ldd	r25, Y+5	; 0x05
    5b14:	ae 81       	ldd	r26, Y+6	; 0x06
    5b16:	bf 81       	ldd	r27, Y+7	; 0x07
    5b18:	01 97       	sbiw	r24, 0x01	; 1
    5b1a:	a1 09       	sbc	r26, r1
    5b1c:	b1 09       	sbc	r27, r1
    5b1e:	8c 83       	std	Y+4, r24	; 0x04
    5b20:	9d 83       	std	Y+5, r25	; 0x05
    5b22:	ae 83       	std	Y+6, r26	; 0x06
    5b24:	bf 83       	std	Y+7, r27	; 0x07
    5b26:	0d c0       	rjmp	.+26     	; 0x5b42 <__vector_11+0x228>
    else { sys.position[X_AXIS]++; }
    5b28:	c4 e0       	ldi	r28, 0x04	; 4
    5b2a:	d6 e0       	ldi	r29, 0x06	; 6
    5b2c:	8c 81       	ldd	r24, Y+4	; 0x04
    5b2e:	9d 81       	ldd	r25, Y+5	; 0x05
    5b30:	ae 81       	ldd	r26, Y+6	; 0x06
    5b32:	bf 81       	ldd	r27, Y+7	; 0x07
    5b34:	01 96       	adiw	r24, 0x01	; 1
    5b36:	a1 1d       	adc	r26, r1
    5b38:	b1 1d       	adc	r27, r1
    5b3a:	8c 83       	std	Y+4, r24	; 0x04
    5b3c:	9d 83       	std	Y+5, r25	; 0x05
    5b3e:	ae 83       	std	Y+6, r26	; 0x06
    5b40:	bf 83       	std	Y+7, r27	; 0x07
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    5b42:	cd ee       	ldi	r28, 0xED	; 237
    5b44:	d4 e0       	ldi	r29, 0x04	; 4
    5b46:	4c 81       	ldd	r20, Y+4	; 0x04
    5b48:	5d 81       	ldd	r21, Y+5	; 0x05
    5b4a:	6e 81       	ldd	r22, Y+6	; 0x06
    5b4c:	7f 81       	ldd	r23, Y+7	; 0x07
    5b4e:	8c 89       	ldd	r24, Y+20	; 0x14
    5b50:	9d 89       	ldd	r25, Y+21	; 0x15
    5b52:	ae 89       	ldd	r26, Y+22	; 0x16
    5b54:	bf 89       	ldd	r27, Y+23	; 0x17
    5b56:	84 0f       	add	r24, r20
    5b58:	95 1f       	adc	r25, r21
    5b5a:	a6 1f       	adc	r26, r22
    5b5c:	b7 1f       	adc	r27, r23
    5b5e:	8c 83       	std	Y+4, r24	; 0x04
    5b60:	9d 83       	std	Y+5, r25	; 0x05
    5b62:	ae 83       	std	Y+6, r26	; 0x06
    5b64:	bf 83       	std	Y+7, r27	; 0x07
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif    
  if (st.counter_y > st.exec_block->step_event_count) {
    5b66:	45 85       	ldd	r20, Z+13	; 0x0d
    5b68:	56 85       	ldd	r21, Z+14	; 0x0e
    5b6a:	67 85       	ldd	r22, Z+15	; 0x0f
    5b6c:	70 89       	ldd	r23, Z+16	; 0x10
    5b6e:	48 17       	cp	r20, r24
    5b70:	59 07       	cpc	r21, r25
    5b72:	6a 07       	cpc	r22, r26
    5b74:	7b 07       	cpc	r23, r27
    5b76:	68 f5       	brcc	.+90     	; 0x5bd2 <__vector_11+0x2b8>
    st.step_outbits |= (1<<Y_STEP_BIT);
    5b78:	2e 85       	ldd	r18, Y+14	; 0x0e
    5b7a:	28 60       	ori	r18, 0x08	; 8
    5b7c:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_y -= st.exec_block->step_event_count;
    5b7e:	45 85       	ldd	r20, Z+13	; 0x0d
    5b80:	56 85       	ldd	r21, Z+14	; 0x0e
    5b82:	67 85       	ldd	r22, Z+15	; 0x0f
    5b84:	70 89       	ldd	r23, Z+16	; 0x10
    5b86:	84 1b       	sub	r24, r20
    5b88:	95 0b       	sbc	r25, r21
    5b8a:	a6 0b       	sbc	r26, r22
    5b8c:	b7 0b       	sbc	r27, r23
    5b8e:	8c 83       	std	Y+4, r24	; 0x04
    5b90:	9d 83       	std	Y+5, r25	; 0x05
    5b92:	ae 83       	std	Y+6, r26	; 0x06
    5b94:	bf 83       	std	Y+7, r27	; 0x07
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys.position[Y_AXIS]--; }
    5b96:	80 81       	ld	r24, Z
    5b98:	86 ff       	sbrs	r24, 6
    5b9a:	0e c0       	rjmp	.+28     	; 0x5bb8 <__vector_11+0x29e>
    5b9c:	c4 e0       	ldi	r28, 0x04	; 4
    5b9e:	d6 e0       	ldi	r29, 0x06	; 6
    5ba0:	88 85       	ldd	r24, Y+8	; 0x08
    5ba2:	99 85       	ldd	r25, Y+9	; 0x09
    5ba4:	aa 85       	ldd	r26, Y+10	; 0x0a
    5ba6:	bb 85       	ldd	r27, Y+11	; 0x0b
    5ba8:	01 97       	sbiw	r24, 0x01	; 1
    5baa:	a1 09       	sbc	r26, r1
    5bac:	b1 09       	sbc	r27, r1
    5bae:	88 87       	std	Y+8, r24	; 0x08
    5bb0:	99 87       	std	Y+9, r25	; 0x09
    5bb2:	aa 87       	std	Y+10, r26	; 0x0a
    5bb4:	bb 87       	std	Y+11, r27	; 0x0b
    5bb6:	0d c0       	rjmp	.+26     	; 0x5bd2 <__vector_11+0x2b8>
    else { sys.position[Y_AXIS]++; }
    5bb8:	c4 e0       	ldi	r28, 0x04	; 4
    5bba:	d6 e0       	ldi	r29, 0x06	; 6
    5bbc:	88 85       	ldd	r24, Y+8	; 0x08
    5bbe:	99 85       	ldd	r25, Y+9	; 0x09
    5bc0:	aa 85       	ldd	r26, Y+10	; 0x0a
    5bc2:	bb 85       	ldd	r27, Y+11	; 0x0b
    5bc4:	01 96       	adiw	r24, 0x01	; 1
    5bc6:	a1 1d       	adc	r26, r1
    5bc8:	b1 1d       	adc	r27, r1
    5bca:	88 87       	std	Y+8, r24	; 0x08
    5bcc:	99 87       	std	Y+9, r25	; 0x09
    5bce:	aa 87       	std	Y+10, r26	; 0x0a
    5bd0:	bb 87       	std	Y+11, r27	; 0x0b
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    5bd2:	cd ee       	ldi	r28, 0xED	; 237
    5bd4:	d4 e0       	ldi	r29, 0x04	; 4
    5bd6:	48 85       	ldd	r20, Y+8	; 0x08
    5bd8:	59 85       	ldd	r21, Y+9	; 0x09
    5bda:	6a 85       	ldd	r22, Y+10	; 0x0a
    5bdc:	7b 85       	ldd	r23, Y+11	; 0x0b
    5bde:	88 8d       	ldd	r24, Y+24	; 0x18
    5be0:	99 8d       	ldd	r25, Y+25	; 0x19
    5be2:	aa 8d       	ldd	r26, Y+26	; 0x1a
    5be4:	bb 8d       	ldd	r27, Y+27	; 0x1b
    5be6:	84 0f       	add	r24, r20
    5be8:	95 1f       	adc	r25, r21
    5bea:	a6 1f       	adc	r26, r22
    5bec:	b7 1f       	adc	r27, r23
    5bee:	88 87       	std	Y+8, r24	; 0x08
    5bf0:	99 87       	std	Y+9, r25	; 0x09
    5bf2:	aa 87       	std	Y+10, r26	; 0x0a
    5bf4:	bb 87       	std	Y+11, r27	; 0x0b
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif  
  if (st.counter_z > st.exec_block->step_event_count) {
    5bf6:	45 85       	ldd	r20, Z+13	; 0x0d
    5bf8:	56 85       	ldd	r21, Z+14	; 0x0e
    5bfa:	67 85       	ldd	r22, Z+15	; 0x0f
    5bfc:	70 89       	ldd	r23, Z+16	; 0x10
    5bfe:	48 17       	cp	r20, r24
    5c00:	59 07       	cpc	r21, r25
    5c02:	6a 07       	cpc	r22, r26
    5c04:	7b 07       	cpc	r23, r27
    5c06:	68 f5       	brcc	.+90     	; 0x5c62 <__vector_11+0x348>
    st.step_outbits |= (1<<Z_STEP_BIT);
    5c08:	2e 85       	ldd	r18, Y+14	; 0x0e
    5c0a:	20 61       	ori	r18, 0x10	; 16
    5c0c:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_z -= st.exec_block->step_event_count;
    5c0e:	45 85       	ldd	r20, Z+13	; 0x0d
    5c10:	56 85       	ldd	r21, Z+14	; 0x0e
    5c12:	67 85       	ldd	r22, Z+15	; 0x0f
    5c14:	70 89       	ldd	r23, Z+16	; 0x10
    5c16:	84 1b       	sub	r24, r20
    5c18:	95 0b       	sbc	r25, r21
    5c1a:	a6 0b       	sbc	r26, r22
    5c1c:	b7 0b       	sbc	r27, r23
    5c1e:	88 87       	std	Y+8, r24	; 0x08
    5c20:	99 87       	std	Y+9, r25	; 0x09
    5c22:	aa 87       	std	Y+10, r26	; 0x0a
    5c24:	bb 87       	std	Y+11, r27	; 0x0b
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys.position[Z_AXIS]--; }
    5c26:	80 81       	ld	r24, Z
    5c28:	88 23       	and	r24, r24
    5c2a:	74 f4       	brge	.+28     	; 0x5c48 <__vector_11+0x32e>
    5c2c:	e4 e0       	ldi	r30, 0x04	; 4
    5c2e:	f6 e0       	ldi	r31, 0x06	; 6
    5c30:	84 85       	ldd	r24, Z+12	; 0x0c
    5c32:	95 85       	ldd	r25, Z+13	; 0x0d
    5c34:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c36:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c38:	01 97       	sbiw	r24, 0x01	; 1
    5c3a:	a1 09       	sbc	r26, r1
    5c3c:	b1 09       	sbc	r27, r1
    5c3e:	84 87       	std	Z+12, r24	; 0x0c
    5c40:	95 87       	std	Z+13, r25	; 0x0d
    5c42:	a6 87       	std	Z+14, r26	; 0x0e
    5c44:	b7 87       	std	Z+15, r27	; 0x0f
    5c46:	0d c0       	rjmp	.+26     	; 0x5c62 <__vector_11+0x348>
    else { sys.position[Z_AXIS]++; }
    5c48:	e4 e0       	ldi	r30, 0x04	; 4
    5c4a:	f6 e0       	ldi	r31, 0x06	; 6
    5c4c:	84 85       	ldd	r24, Z+12	; 0x0c
    5c4e:	95 85       	ldd	r25, Z+13	; 0x0d
    5c50:	a6 85       	ldd	r26, Z+14	; 0x0e
    5c52:	b7 85       	ldd	r27, Z+15	; 0x0f
    5c54:	01 96       	adiw	r24, 0x01	; 1
    5c56:	a1 1d       	adc	r26, r1
    5c58:	b1 1d       	adc	r27, r1
    5c5a:	84 87       	std	Z+12, r24	; 0x0c
    5c5c:	95 87       	std	Z+13, r25	; 0x0d
    5c5e:	a6 87       	std	Z+14, r26	; 0x0e
    5c60:	b7 87       	std	Z+15, r27	; 0x0f
  }  

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { st.step_outbits &= sys.homing_axis_lock; }   
    5c62:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    5c66:	84 30       	cpi	r24, 0x04	; 4
    5c68:	39 f4       	brne	.+14     	; 0x5c78 <__vector_11+0x35e>
    5c6a:	ed ee       	ldi	r30, 0xED	; 237
    5c6c:	f4 e0       	ldi	r31, 0x04	; 4
    5c6e:	96 85       	ldd	r25, Z+14	; 0x0e
    5c70:	80 91 21 06 	lds	r24, 0x0621	; 0x800621 <sys+0x1d>
    5c74:	89 23       	and	r24, r25
    5c76:	86 87       	std	Z+14, r24	; 0x0e

  st.step_count--; // Decrement step events count 
    5c78:	ed ee       	ldi	r30, 0xED	; 237
    5c7a:	f4 e0       	ldi	r31, 0x04	; 4
    5c7c:	84 8d       	ldd	r24, Z+28	; 0x1c
    5c7e:	95 8d       	ldd	r25, Z+29	; 0x1d
    5c80:	01 97       	sbiw	r24, 0x01	; 1
    5c82:	95 8f       	std	Z+29, r25	; 0x1d
    5c84:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    5c86:	89 2b       	or	r24, r25
    5c88:	69 f4       	brne	.+26     	; 0x5ca4 <__vector_11+0x38a>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    5c8a:	10 92 0f 05 	sts	0x050F, r1	; 0x80050f <st+0x22>
    5c8e:	10 92 0e 05 	sts	0x050E, r1	; 0x80050e <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    5c92:	80 91 ec 04 	lds	r24, 0x04EC	; 0x8004ec <segment_buffer_tail>
    5c96:	8f 5f       	subi	r24, 0xFF	; 255
    5c98:	80 93 ec 04 	sts	0x04EC, r24	; 0x8004ec <segment_buffer_tail>
    5c9c:	86 30       	cpi	r24, 0x06	; 6
    5c9e:	11 f4       	brne	.+4      	; 0x5ca4 <__vector_11+0x38a>
    5ca0:	10 92 ec 04 	sts	0x04EC, r1	; 0x8004ec <segment_buffer_tail>
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask    
    5ca4:	ed ee       	ldi	r30, 0xED	; 237
    5ca6:	f4 e0       	ldi	r31, 0x04	; 4
    5ca8:	96 85       	ldd	r25, Z+14	; 0x0e
    5caa:	80 91 e9 04 	lds	r24, 0x04E9	; 0x8004e9 <step_port_invert_mask>
    5cae:	89 27       	eor	r24, r25
    5cb0:	86 87       	std	Z+14, r24	; 0x0e
  busy = false;
    5cb2:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <busy>
// SPINDLE_ENABLE_PORT ^= 1<<SPINDLE_ENABLE_BIT; // Debug: Used to time ISR
}
    5cb6:	ff 91       	pop	r31
    5cb8:	ef 91       	pop	r30
    5cba:	df 91       	pop	r29
    5cbc:	cf 91       	pop	r28
    5cbe:	bf 91       	pop	r27
    5cc0:	af 91       	pop	r26
    5cc2:	9f 91       	pop	r25
    5cc4:	8f 91       	pop	r24
    5cc6:	7f 91       	pop	r23
    5cc8:	6f 91       	pop	r22
    5cca:	5f 91       	pop	r21
    5ccc:	4f 91       	pop	r20
    5cce:	3f 91       	pop	r19
    5cd0:	2f 91       	pop	r18
    5cd2:	1f 91       	pop	r17
    5cd4:	0f 91       	pop	r16
    5cd6:	0f 90       	pop	r0
    5cd8:	0f be       	out	0x3f, r0	; 63
    5cda:	0f 90       	pop	r0
    5cdc:	1f 90       	pop	r1
    5cde:	18 95       	reti

00005ce0 <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds) 
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    5ce0:	1f 92       	push	r1
    5ce2:	0f 92       	push	r0
    5ce4:	0f b6       	in	r0, 0x3f	; 63
    5ce6:	0f 92       	push	r0
    5ce8:	11 24       	eor	r1, r1
    5cea:	8f 93       	push	r24
    5cec:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK); 
    5cee:	8b b1       	in	r24, 0x0b	; 11
    5cf0:	90 91 e9 04 	lds	r25, 0x04E9	; 0x8004e9 <step_port_invert_mask>
    5cf4:	9c 71       	andi	r25, 0x1C	; 28
    5cf6:	83 7e       	andi	r24, 0xE3	; 227
    5cf8:	89 2b       	or	r24, r25
    5cfa:	8b b9       	out	0x0b, r24	; 11
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed. 
    5cfc:	15 bc       	out	0x25, r1	; 37
}
    5cfe:	9f 91       	pop	r25
    5d00:	8f 91       	pop	r24
    5d02:	0f 90       	pop	r0
    5d04:	0f be       	out	0x3f, r0	; 63
    5d06:	0f 90       	pop	r0
    5d08:	1f 90       	pop	r1
    5d0a:	18 95       	reti

00005d0c <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{  
    5d0c:	ef 92       	push	r14
    5d0e:	ff 92       	push	r15
    5d10:	0f 93       	push	r16
    5d12:	1f 93       	push	r17
    5d14:	cf 93       	push	r28
    5d16:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    5d18:	10 92 e9 04 	sts	0x04E9, r1	; 0x8004e9 <step_port_invert_mask>
  dir_port_invert_mask = 0;
    5d1c:	10 92 e8 04 	sts	0x04E8, r1	; 0x8004e8 <dir_port_invert_mask>
    5d20:	c0 e0       	ldi	r28, 0x00	; 0
    5d22:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    5d24:	03 ee       	ldi	r16, 0xE3	; 227
    5d26:	16 e0       	ldi	r17, 0x06	; 6
    5d28:	ec 2e       	mov	r14, r28
    5d2a:	fc 2e       	mov	r15, r28
    5d2c:	f8 01       	movw	r30, r16
    5d2e:	81 a9       	ldd	r24, Z+49	; 0x31
    5d30:	90 e0       	ldi	r25, 0x00	; 0
    5d32:	0c 2e       	mov	r0, r28
    5d34:	02 c0       	rjmp	.+4      	; 0x5d3a <st_generate_step_dir_invert_masks+0x2e>
    5d36:	95 95       	asr	r25
    5d38:	87 95       	ror	r24
    5d3a:	0a 94       	dec	r0
    5d3c:	e2 f7       	brpl	.-8      	; 0x5d36 <st_generate_step_dir_invert_masks+0x2a>
    5d3e:	80 ff       	sbrs	r24, 0
    5d40:	08 c0       	rjmp	.+16     	; 0x5d52 <st_generate_step_dir_invert_masks+0x46>
    5d42:	8c 2f       	mov	r24, r28
    5d44:	0e 94 a6 2b 	call	0x574c	; 0x574c <get_step_pin_mask>
    5d48:	90 91 e9 04 	lds	r25, 0x04E9	; 0x8004e9 <step_port_invert_mask>
    5d4c:	89 2b       	or	r24, r25
    5d4e:	80 93 e9 04 	sts	0x04E9, r24	; 0x8004e9 <step_port_invert_mask>
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    5d52:	f8 01       	movw	r30, r16
    5d54:	82 a9       	ldd	r24, Z+50	; 0x32
    5d56:	90 e0       	ldi	r25, 0x00	; 0
    5d58:	02 c0       	rjmp	.+4      	; 0x5d5e <st_generate_step_dir_invert_masks+0x52>
    5d5a:	95 95       	asr	r25
    5d5c:	87 95       	ror	r24
    5d5e:	fa 94       	dec	r15
    5d60:	e2 f7       	brpl	.-8      	; 0x5d5a <st_generate_step_dir_invert_masks+0x4e>
    5d62:	80 ff       	sbrs	r24, 0
    5d64:	08 c0       	rjmp	.+16     	; 0x5d76 <st_generate_step_dir_invert_masks+0x6a>
    5d66:	8e 2d       	mov	r24, r14
    5d68:	0e 94 b0 2b 	call	0x5760	; 0x5760 <get_direction_pin_mask>
    5d6c:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <dir_port_invert_mask>
    5d70:	89 2b       	or	r24, r25
    5d72:	80 93 e8 04 	sts	0x04E8, r24	; 0x8004e8 <dir_port_invert_mask>
    5d76:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{  
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    5d78:	c3 30       	cpi	r28, 0x03	; 3
    5d7a:	d1 05       	cpc	r29, r1
    5d7c:	a9 f6       	brne	.-86     	; 0x5d28 <st_generate_step_dir_invert_masks+0x1c>
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
  }
}
    5d7e:	df 91       	pop	r29
    5d80:	cf 91       	pop	r28
    5d82:	1f 91       	pop	r17
    5d84:	0f 91       	pop	r16
    5d86:	ff 90       	pop	r15
    5d88:	ef 90       	pop	r14
    5d8a:	08 95       	ret

00005d8c <st_reset>:

// Reset and clear stepper subsystem variables
void st_reset()
{
  // Initialize stepper driver idle state.
  st_go_idle();
    5d8c:	0e 94 64 2c 	call	0x58c8	; 0x58c8 <st_go_idle>
  
  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    5d90:	8b e2       	ldi	r24, 0x2B	; 43
    5d92:	ea eb       	ldi	r30, 0xBA	; 186
    5d94:	f4 e0       	ldi	r31, 0x04	; 4
    5d96:	df 01       	movw	r26, r30
    5d98:	1d 92       	st	X+, r1
    5d9a:	8a 95       	dec	r24
    5d9c:	e9 f7       	brne	.-6      	; 0x5d98 <st_reset+0xc>
  memset(&st, 0, sizeof(stepper_t));
    5d9e:	83 e2       	ldi	r24, 0x23	; 35
    5da0:	ed ee       	ldi	r30, 0xED	; 237
    5da2:	f4 e0       	ldi	r31, 0x04	; 4
    5da4:	df 01       	movw	r26, r30
    5da6:	1d 92       	st	X+, r1
    5da8:	8a 95       	dec	r24
    5daa:	e9 f7       	brne	.-6      	; 0x5da6 <st_reset+0x1a>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    5dac:	10 92 e6 04 	sts	0x04E6, r1	; 0x8004e6 <pl_block+0x1>
    5db0:	10 92 e5 04 	sts	0x04E5, r1	; 0x8004e5 <pl_block>
  segment_buffer_tail = 0;
    5db4:	10 92 ec 04 	sts	0x04EC, r1	; 0x8004ec <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    5db8:	10 92 eb 04 	sts	0x04EB, r1	; 0x8004eb <segment_buffer_head>
  segment_next_head = 1;
    5dbc:	81 e0       	ldi	r24, 0x01	; 1
    5dbe:	80 93 ea 04 	sts	0x04EA, r24	; 0x8004ea <segment_next_head>
  busy = false;
    5dc2:	10 92 e7 04 	sts	0x04E7, r1	; 0x8004e7 <busy>
  
  st_generate_step_dir_invert_masks();
    5dc6:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <st_generate_step_dir_invert_masks>
      
  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    5dca:	8b b1       	in	r24, 0x0b	; 11
    5dcc:	83 7e       	andi	r24, 0xE3	; 227
    5dce:	90 91 e9 04 	lds	r25, 0x04E9	; 0x8004e9 <step_port_invert_mask>
    5dd2:	89 2b       	or	r24, r25
    5dd4:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    5dd6:	8b b1       	in	r24, 0x0b	; 11
    5dd8:	8f 71       	andi	r24, 0x1F	; 31
    5dda:	90 91 e8 04 	lds	r25, 0x04E8	; 0x8004e8 <dir_port_invert_mask>
    5dde:	89 2b       	or	r24, r25
    5de0:	8b b9       	out	0x0b, r24	; 11
    5de2:	08 95       	ret

00005de4 <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    5de4:	8a b1       	in	r24, 0x0a	; 10
    5de6:	8c 61       	ori	r24, 0x1C	; 28
    5de8:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    5dea:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    5dec:	8a b1       	in	r24, 0x0a	; 10
    5dee:	80 6e       	ori	r24, 0xE0	; 224
    5df0:	8a b9       	out	0x0a, r24	; 10

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    5df2:	e1 e8       	ldi	r30, 0x81	; 129
    5df4:	f0 e0       	ldi	r31, 0x00	; 0
    5df6:	80 81       	ld	r24, Z
    5df8:	8f 7e       	andi	r24, 0xEF	; 239
    5dfa:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    5dfc:	80 81       	ld	r24, Z
    5dfe:	88 60       	ori	r24, 0x08	; 8
    5e00:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10)); 
    5e02:	e0 e8       	ldi	r30, 0x80	; 128
    5e04:	f0 e0       	ldi	r31, 0x00	; 0
    5e06:	80 81       	ld	r24, Z
    5e08:	8c 7f       	andi	r24, 0xFC	; 252
    5e0a:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    5e0c:	80 81       	ld	r24, Z
    5e0e:	8f 70       	andi	r24, 0x0F	; 15
    5e10:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().
  
  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    5e12:	ee e6       	ldi	r30, 0x6E	; 110
    5e14:	f0 e0       	ldi	r31, 0x00	; 0
    5e16:	80 81       	ld	r24, Z
    5e18:	88 7f       	andi	r24, 0xF8	; 248
    5e1a:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    5e1c:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    5e1e:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    5e20:	80 81       	ld	r24, Z
    5e22:	81 60       	ori	r24, 0x01	; 1
    5e24:	80 83       	st	Z, r24
    5e26:	08 95       	ret

00005e28 <st_update_plan_block_parameters>:
}
  

// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{ 
    5e28:	cf 93       	push	r28
    5e2a:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    5e2c:	c0 91 e5 04 	lds	r28, 0x04E5	; 0x8004e5 <pl_block>
    5e30:	d0 91 e6 04 	lds	r29, 0x04E6	; 0x8004e6 <pl_block+0x1>
    5e34:	20 97       	sbiw	r28, 0x00	; 0
    5e36:	a1 f0       	breq	.+40     	; 0x5e60 <st_update_plan_block_parameters+0x38>
    prep.flag_partial_block = true;
    5e38:	ea eb       	ldi	r30, 0xBA	; 186
    5e3a:	f4 e0       	ldi	r31, 0x04	; 4
    5e3c:	81 e0       	ldi	r24, 0x01	; 1
    5e3e:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    5e40:	67 89       	ldd	r22, Z+23	; 0x17
    5e42:	70 8d       	ldd	r23, Z+24	; 0x18
    5e44:	81 8d       	ldd	r24, Z+25	; 0x19
    5e46:	92 8d       	ldd	r25, Z+26	; 0x1a
    5e48:	9b 01       	movw	r18, r22
    5e4a:	ac 01       	movw	r20, r24
    5e4c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    5e50:	69 8b       	std	Y+17, r22	; 0x11
    5e52:	7a 8b       	std	Y+18, r23	; 0x12
    5e54:	8b 8b       	std	Y+19, r24	; 0x13
    5e56:	9c 8b       	std	Y+20, r25	; 0x14
    pl_block = NULL; // Flag st_prep_segment() to load new velocity profile.
    5e58:	10 92 e6 04 	sts	0x04E6, r1	; 0x8004e6 <pl_block+0x1>
    5e5c:	10 92 e5 04 	sts	0x04E5, r1	; 0x8004e5 <pl_block>
  }
}
    5e60:	df 91       	pop	r29
    5e62:	cf 91       	pop	r28
    5e64:	08 95       	ret

00005e66 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it. 
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    5e66:	2f 92       	push	r2
    5e68:	3f 92       	push	r3
    5e6a:	4f 92       	push	r4
    5e6c:	5f 92       	push	r5
    5e6e:	6f 92       	push	r6
    5e70:	7f 92       	push	r7
    5e72:	8f 92       	push	r8
    5e74:	9f 92       	push	r9
    5e76:	af 92       	push	r10
    5e78:	bf 92       	push	r11
    5e7a:	cf 92       	push	r12
    5e7c:	df 92       	push	r13
    5e7e:	ef 92       	push	r14
    5e80:	ff 92       	push	r15
    5e82:	0f 93       	push	r16
    5e84:	1f 93       	push	r17
    5e86:	cf 93       	push	r28
    5e88:	df 93       	push	r29
    5e8a:	cd b7       	in	r28, 0x3d	; 61
    5e8c:	de b7       	in	r29, 0x3e	; 62
    5e8e:	ed 97       	sbiw	r28, 0x3d	; 61
    5e90:	0f b6       	in	r0, 0x3f	; 63
    5e92:	f8 94       	cli
    5e94:	de bf       	out	0x3e, r29	; 62
    5e96:	0f be       	out	0x3f, r0	; 63
    5e98:	cd bf       	out	0x3d, r28	; 61

  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    5e9a:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    5e9e:	80 77       	andi	r24, 0x70	; 112
    5ea0:	09 f4       	brne	.+2      	; 0x5ea4 <st_prep_buffer+0x3e>
    5ea2:	a2 c6       	rjmp	.+3396   	; 0x6be8 <st_prep_buffer+0xd82>
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
    5ea4:	20 e0       	ldi	r18, 0x00	; 0
    5ea6:	30 e0       	ldi	r19, 0x00	; 0
    5ea8:	a9 01       	movw	r20, r18
    5eaa:	60 91 d1 04 	lds	r22, 0x04D1	; 0x8004d1 <prep+0x17>
    5eae:	70 91 d2 04 	lds	r23, 0x04D2	; 0x8004d2 <prep+0x18>
    5eb2:	80 91 d3 04 	lds	r24, 0x04D3	; 0x8004d3 <prep+0x19>
    5eb6:	90 91 d4 04 	lds	r25, 0x04D4	; 0x8004d4 <prep+0x1a>
    5eba:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    5ebe:	81 11       	cpse	r24, r1
    5ec0:	93 c6       	rjmp	.+3366   	; 0x6be8 <st_prep_buffer+0xd82>
    5ec2:	a0 c6       	rjmp	.+3392   	; 0x6c04 <st_prep_buffer+0xd9e>
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block has been replanned. 
    if (pl_block == NULL) {
    5ec4:	80 91 e5 04 	lds	r24, 0x04E5	; 0x8004e5 <pl_block>
    5ec8:	90 91 e6 04 	lds	r25, 0x04E6	; 0x8004e6 <pl_block+0x1>
    5ecc:	89 2b       	or	r24, r25
    5ece:	09 f0       	breq	.+2      	; 0x5ed2 <st_prep_buffer+0x6c>
    5ed0:	53 c2       	rjmp	.+1190   	; 0x6378 <st_prep_buffer+0x512>
      pl_block = plan_get_current_block(); // Query planner for a queued block
    5ed2:	0e 94 05 1b 	call	0x360a	; 0x360a <plan_get_current_block>
    5ed6:	8c 01       	movw	r16, r24
    5ed8:	90 93 e6 04 	sts	0x04E6, r25	; 0x8004e6 <pl_block+0x1>
    5edc:	80 93 e5 04 	sts	0x04E5, r24	; 0x8004e5 <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    5ee0:	89 2b       	or	r24, r25
    5ee2:	09 f4       	brne	.+2      	; 0x5ee6 <st_prep_buffer+0x80>
    5ee4:	8f c6       	rjmp	.+3358   	; 0x6c04 <st_prep_buffer+0xd9e>
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    5ee6:	d3 01       	movw	r26, r6
    5ee8:	11 96       	adiw	r26, 0x01	; 1
    5eea:	8c 91       	ld	r24, X
    5eec:	11 97       	sbiw	r26, 0x01	; 1
    5eee:	88 23       	and	r24, r24
    5ef0:	19 f0       	breq	.+6      	; 0x5ef8 <st_prep_buffer+0x92>
        prep.flag_partial_block = false; // Reset flag
    5ef2:	11 96       	adiw	r26, 0x01	; 1
    5ef4:	1c 92       	st	X, r1
    5ef6:	ca c0       	rjmp	.+404    	; 0x608c <st_prep_buffer+0x226>
      } else {
        // Increment stepper common data index to store new planner block data. 
        if ( ++prep.st_block_index == (SEGMENT_BUFFER_SIZE-1) ) { prep.st_block_index = 0; }
    5ef8:	f3 01       	movw	r30, r6
    5efa:	80 81       	ld	r24, Z
    5efc:	8f 5f       	subi	r24, 0xFF	; 255
    5efe:	85 30       	cpi	r24, 0x05	; 5
    5f00:	11 f0       	breq	.+4      	; 0x5f06 <st_prep_buffer+0xa0>
    5f02:	80 83       	st	Z, r24
    5f04:	01 c0       	rjmp	.+2      	; 0x5f08 <st_prep_buffer+0xa2>
    5f06:	10 82       	st	Z, r1
        
        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the 
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it. 
        st_prep_block = &st_block_buffer[prep.st_block_index];
    5f08:	d3 01       	movw	r26, r6
    5f0a:	ec 91       	ld	r30, X
        st_prep_block->direction_bits = pl_block->direction_bits;
    5f0c:	d8 01       	movw	r26, r16
    5f0e:	8c 91       	ld	r24, X
    5f10:	b1 e1       	ldi	r27, 0x11	; 17
    5f12:	be 9f       	mul	r27, r30
    5f14:	f0 01       	movw	r30, r0
    5f16:	11 24       	eor	r1, r1
    5f18:	ec 5c       	subi	r30, 0xCC	; 204
    5f1a:	fa 4f       	sbci	r31, 0xFA	; 250
    5f1c:	80 83       	st	Z, r24
          st_prep_block->step_event_count = pl_block->step_event_count;
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS 
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          st_prep_block->steps[X_AXIS] = pl_block->steps[X_AXIS] << MAX_AMASS_LEVEL;
    5f1e:	d8 01       	movw	r26, r16
    5f20:	11 96       	adiw	r26, 0x01	; 1
    5f22:	4d 91       	ld	r20, X+
    5f24:	5d 91       	ld	r21, X+
    5f26:	6d 91       	ld	r22, X+
    5f28:	7c 91       	ld	r23, X
    5f2a:	14 97       	sbiw	r26, 0x04	; 4
    5f2c:	db 01       	movw	r26, r22
    5f2e:	ca 01       	movw	r24, r20
    5f30:	88 0f       	add	r24, r24
    5f32:	99 1f       	adc	r25, r25
    5f34:	aa 1f       	adc	r26, r26
    5f36:	bb 1f       	adc	r27, r27
    5f38:	88 0f       	add	r24, r24
    5f3a:	99 1f       	adc	r25, r25
    5f3c:	aa 1f       	adc	r26, r26
    5f3e:	bb 1f       	adc	r27, r27
    5f40:	88 0f       	add	r24, r24
    5f42:	99 1f       	adc	r25, r25
    5f44:	aa 1f       	adc	r26, r26
    5f46:	bb 1f       	adc	r27, r27
    5f48:	81 83       	std	Z+1, r24	; 0x01
    5f4a:	92 83       	std	Z+2, r25	; 0x02
    5f4c:	a3 83       	std	Z+3, r26	; 0x03
    5f4e:	b4 83       	std	Z+4, r27	; 0x04
          st_prep_block->steps[Y_AXIS] = pl_block->steps[Y_AXIS] << MAX_AMASS_LEVEL;
    5f50:	d8 01       	movw	r26, r16
    5f52:	15 96       	adiw	r26, 0x05	; 5
    5f54:	4d 91       	ld	r20, X+
    5f56:	5d 91       	ld	r21, X+
    5f58:	6d 91       	ld	r22, X+
    5f5a:	7c 91       	ld	r23, X
    5f5c:	18 97       	sbiw	r26, 0x08	; 8
    5f5e:	db 01       	movw	r26, r22
    5f60:	ca 01       	movw	r24, r20
    5f62:	88 0f       	add	r24, r24
    5f64:	99 1f       	adc	r25, r25
    5f66:	aa 1f       	adc	r26, r26
    5f68:	bb 1f       	adc	r27, r27
    5f6a:	88 0f       	add	r24, r24
    5f6c:	99 1f       	adc	r25, r25
    5f6e:	aa 1f       	adc	r26, r26
    5f70:	bb 1f       	adc	r27, r27
    5f72:	88 0f       	add	r24, r24
    5f74:	99 1f       	adc	r25, r25
    5f76:	aa 1f       	adc	r26, r26
    5f78:	bb 1f       	adc	r27, r27
    5f7a:	85 83       	std	Z+5, r24	; 0x05
    5f7c:	96 83       	std	Z+6, r25	; 0x06
    5f7e:	a7 83       	std	Z+7, r26	; 0x07
    5f80:	b0 87       	std	Z+8, r27	; 0x08
          st_prep_block->steps[Z_AXIS] = pl_block->steps[Z_AXIS] << MAX_AMASS_LEVEL;
    5f82:	d8 01       	movw	r26, r16
    5f84:	19 96       	adiw	r26, 0x09	; 9
    5f86:	4d 91       	ld	r20, X+
    5f88:	5d 91       	ld	r21, X+
    5f8a:	6d 91       	ld	r22, X+
    5f8c:	7c 91       	ld	r23, X
    5f8e:	1c 97       	sbiw	r26, 0x0c	; 12
    5f90:	db 01       	movw	r26, r22
    5f92:	ca 01       	movw	r24, r20
    5f94:	88 0f       	add	r24, r24
    5f96:	99 1f       	adc	r25, r25
    5f98:	aa 1f       	adc	r26, r26
    5f9a:	bb 1f       	adc	r27, r27
    5f9c:	88 0f       	add	r24, r24
    5f9e:	99 1f       	adc	r25, r25
    5fa0:	aa 1f       	adc	r26, r26
    5fa2:	bb 1f       	adc	r27, r27
    5fa4:	88 0f       	add	r24, r24
    5fa6:	99 1f       	adc	r25, r25
    5fa8:	aa 1f       	adc	r26, r26
    5faa:	bb 1f       	adc	r27, r27
    5fac:	81 87       	std	Z+9, r24	; 0x09
    5fae:	92 87       	std	Z+10, r25	; 0x0a
    5fb0:	a3 87       	std	Z+11, r26	; 0x0b
    5fb2:	b4 87       	std	Z+12, r27	; 0x0c
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    5fb4:	d8 01       	movw	r26, r16
    5fb6:	1d 96       	adiw	r26, 0x0d	; 13
    5fb8:	4d 91       	ld	r20, X+
    5fba:	5d 91       	ld	r21, X+
    5fbc:	6d 91       	ld	r22, X+
    5fbe:	7c 91       	ld	r23, X
    5fc0:	50 97       	sbiw	r26, 0x10	; 16
    5fc2:	db 01       	movw	r26, r22
    5fc4:	ca 01       	movw	r24, r20
    5fc6:	88 0f       	add	r24, r24
    5fc8:	99 1f       	adc	r25, r25
    5fca:	aa 1f       	adc	r26, r26
    5fcc:	bb 1f       	adc	r27, r27
    5fce:	88 0f       	add	r24, r24
    5fd0:	99 1f       	adc	r25, r25
    5fd2:	aa 1f       	adc	r26, r26
    5fd4:	bb 1f       	adc	r27, r27
    5fd6:	88 0f       	add	r24, r24
    5fd8:	99 1f       	adc	r25, r25
    5fda:	aa 1f       	adc	r26, r26
    5fdc:	bb 1f       	adc	r27, r27
    5fde:	85 87       	std	Z+13, r24	; 0x0d
    5fe0:	96 87       	std	Z+14, r25	; 0x0e
    5fe2:	a7 87       	std	Z+15, r26	; 0x0f
    5fe4:	b0 8b       	std	Z+16, r27	; 0x10
        #endif
        
        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = pl_block->step_event_count;
    5fe6:	f8 01       	movw	r30, r16
    5fe8:	65 85       	ldd	r22, Z+13	; 0x0d
    5fea:	76 85       	ldd	r23, Z+14	; 0x0e
    5fec:	87 85       	ldd	r24, Z+15	; 0x0f
    5fee:	90 89       	ldd	r25, Z+16	; 0x10
    5ff0:	0e 94 5d 3b 	call	0x76ba	; 0x76ba <__floatunsisf>
    5ff4:	d3 01       	movw	r26, r6
    5ff6:	12 96       	adiw	r26, 0x02	; 2
    5ff8:	6d 93       	st	X+, r22
    5ffa:	7d 93       	st	X+, r23
    5ffc:	8d 93       	st	X+, r24
    5ffe:	9c 93       	st	X, r25
    6000:	15 97       	sbiw	r26, 0x05	; 5
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    6002:	f8 01       	movw	r30, r16
    6004:	25 a1       	ldd	r18, Z+37	; 0x25
    6006:	36 a1       	ldd	r19, Z+38	; 0x26
    6008:	47 a1       	ldd	r20, Z+39	; 0x27
    600a:	50 a5       	ldd	r21, Z+40	; 0x28
    600c:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    6010:	9b 01       	movw	r18, r22
    6012:	ac 01       	movw	r20, r24
    6014:	d3 01       	movw	r26, r6
    6016:	16 96       	adiw	r26, 0x06	; 6
    6018:	6d 93       	st	X+, r22
    601a:	7d 93       	st	X+, r23
    601c:	8d 93       	st	X+, r24
    601e:	9c 93       	st	X, r25
    6020:	19 97       	sbiw	r26, 0x09	; 9
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    6022:	60 e0       	ldi	r22, 0x00	; 0
    6024:	70 e0       	ldi	r23, 0x00	; 0
    6026:	80 ea       	ldi	r24, 0xA0	; 160
    6028:	9f e3       	ldi	r25, 0x3F	; 63
    602a:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    602e:	f3 01       	movw	r30, r6
    6030:	62 87       	std	Z+10, r22	; 0x0a
    6032:	73 87       	std	Z+11, r23	; 0x0b
    6034:	84 87       	std	Z+12, r24	; 0x0c
    6036:	95 87       	std	Z+13, r25	; 0x0d
        
        prep.dt_remainder = 0.0; // Reset for new planner block
    6038:	16 86       	std	Z+14, r1	; 0x0e
    603a:	17 86       	std	Z+15, r1	; 0x0f
    603c:	10 8a       	std	Z+16, r1	; 0x10
    603e:	11 8a       	std	Z+17, r1	; 0x11

        if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    6040:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    6044:	80 77       	andi	r24, 0x70	; 112
    6046:	a1 f0       	breq	.+40     	; 0x6070 <st_prep_buffer+0x20a>
          // Override planner block entry speed and enforce deceleration during feed hold.
          prep.current_speed = prep.exit_speed; 
    6048:	67 8d       	ldd	r22, Z+31	; 0x1f
    604a:	70 a1       	ldd	r23, Z+32	; 0x20
    604c:	81 a1       	ldd	r24, Z+33	; 0x21
    604e:	92 a1       	ldd	r25, Z+34	; 0x22
    6050:	67 8b       	std	Z+23, r22	; 0x17
    6052:	70 8f       	std	Z+24, r23	; 0x18
    6054:	81 8f       	std	Z+25, r24	; 0x19
    6056:	92 8f       	std	Z+26, r25	; 0x1a
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed; 
    6058:	9b 01       	movw	r18, r22
    605a:	ac 01       	movw	r20, r24
    605c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6060:	d8 01       	movw	r26, r16
    6062:	51 96       	adiw	r26, 0x11	; 17
    6064:	6d 93       	st	X+, r22
    6066:	7d 93       	st	X+, r23
    6068:	8d 93       	st	X+, r24
    606a:	9c 93       	st	X, r25
    606c:	54 97       	sbiw	r26, 0x14	; 20
    606e:	0e c0       	rjmp	.+28     	; 0x608c <st_prep_buffer+0x226>
        }
        else { prep.current_speed = sqrt(pl_block->entry_speed_sqr); }
    6070:	f8 01       	movw	r30, r16
    6072:	61 89       	ldd	r22, Z+17	; 0x11
    6074:	72 89       	ldd	r23, Z+18	; 0x12
    6076:	83 89       	ldd	r24, Z+19	; 0x13
    6078:	94 89       	ldd	r25, Z+20	; 0x14
    607a:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    607e:	d3 01       	movw	r26, r6
    6080:	57 96       	adiw	r26, 0x17	; 23
    6082:	6d 93       	st	X+, r22
    6084:	7d 93       	st	X+, r23
    6086:	8d 93       	st	X+, r24
    6088:	9c 93       	st	X, r25
    608a:	5a 97       	sbiw	r26, 0x1a	; 26
         Compute the velocity profile of a new planner block based on its entry and exit
         speeds, or recompute the profile of a partially-completed planner block if the 
         planner has updated it. For a commanded forced-deceleration, such as from a feed 
         hold, override the planner velocities and decelerate to the target exit speed.
      */
      prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    608c:	f3 01       	movw	r30, r6
    608e:	13 8a       	std	Z+19, r1	; 0x13
    6090:	14 8a       	std	Z+20, r1	; 0x14
    6092:	15 8a       	std	Z+21, r1	; 0x15
    6094:	16 8a       	std	Z+22, r1	; 0x16
      float inv_2_accel = 0.5/pl_block->acceleration;
    6096:	20 91 e5 04 	lds	r18, 0x04E5	; 0x8004e5 <pl_block>
    609a:	30 91 e6 04 	lds	r19, 0x04E6	; 0x8004e6 <pl_block+0x1>
    609e:	3a 83       	std	Y+2, r19	; 0x02
    60a0:	29 83       	std	Y+1, r18	; 0x01
    60a2:	d9 01       	movw	r26, r18
    60a4:	91 96       	adiw	r26, 0x21	; 33
    60a6:	cd 90       	ld	r12, X+
    60a8:	dd 90       	ld	r13, X+
    60aa:	ed 90       	ld	r14, X+
    60ac:	fc 90       	ld	r15, X
    60ae:	94 97       	sbiw	r26, 0x24	; 36
    60b0:	a7 01       	movw	r20, r14
    60b2:	96 01       	movw	r18, r12
    60b4:	60 e0       	ldi	r22, 0x00	; 0
    60b6:	70 e0       	ldi	r23, 0x00	; 0
    60b8:	80 e0       	ldi	r24, 0x00	; 0
    60ba:	9f e3       	ldi	r25, 0x3F	; 63
    60bc:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    60c0:	4b 01       	movw	r8, r22
    60c2:	5c 01       	movw	r10, r24
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { // [Forced Deceleration to Zero Velocity]
    60c4:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    60c8:	80 77       	andi	r24, 0x70	; 112
    60ca:	09 f4       	brne	.+2      	; 0x60ce <st_prep_buffer+0x268>
    60cc:	4f c0       	rjmp	.+158    	; 0x616c <st_prep_buffer+0x306>
        // Compute velocity profile parameters for a feed hold in-progress. This profile overrides
        // the planner block profile, enforcing a deceleration to zero speed.
        prep.ramp_type = RAMP_DECEL;
    60ce:	22 e0       	ldi	r18, 0x02	; 2
    60d0:	f3 01       	movw	r30, r6
    60d2:	22 8b       	std	Z+18, r18	; 0x12
        // Compute decelerate distance relative to end of block.
        float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    60d4:	a9 81       	ldd	r26, Y+1	; 0x01
    60d6:	ba 81       	ldd	r27, Y+2	; 0x02
    60d8:	95 96       	adiw	r26, 0x25	; 37
    60da:	2d 90       	ld	r2, X+
    60dc:	3d 90       	ld	r3, X+
    60de:	4d 90       	ld	r4, X+
    60e0:	5c 90       	ld	r5, X
    60e2:	98 97       	sbiw	r26, 0x28	; 40
    60e4:	51 96       	adiw	r26, 0x11	; 17
    60e6:	2d 91       	ld	r18, X+
    60e8:	3d 91       	ld	r19, X+
    60ea:	4d 91       	ld	r20, X+
    60ec:	5c 91       	ld	r21, X
    60ee:	54 97       	sbiw	r26, 0x14	; 20
    60f0:	29 83       	std	Y+1, r18	; 0x01
    60f2:	3a 83       	std	Y+2, r19	; 0x02
    60f4:	4b 83       	std	Y+3, r20	; 0x03
    60f6:	5c 83       	std	Y+4, r21	; 0x04
    60f8:	c5 01       	movw	r24, r10
    60fa:	b4 01       	movw	r22, r8
    60fc:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6100:	9b 01       	movw	r18, r22
    6102:	ac 01       	movw	r20, r24
    6104:	c2 01       	movw	r24, r4
    6106:	b1 01       	movw	r22, r2
    6108:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    610c:	4b 01       	movw	r8, r22
    610e:	5c 01       	movw	r10, r24
        if (decel_dist < 0.0) {
    6110:	20 e0       	ldi	r18, 0x00	; 0
    6112:	30 e0       	ldi	r19, 0x00	; 0
    6114:	a9 01       	movw	r20, r18
    6116:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    611a:	88 23       	and	r24, r24
    611c:	d4 f4       	brge	.+52     	; 0x6152 <st_prep_buffer+0x2ec>
          // Deceleration through entire planner block. End of feed hold is not in this block.
          prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    611e:	a7 01       	movw	r20, r14
    6120:	96 01       	movw	r18, r12
    6122:	c7 01       	movw	r24, r14
    6124:	b6 01       	movw	r22, r12
    6126:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    612a:	a2 01       	movw	r20, r4
    612c:	91 01       	movw	r18, r2
    612e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6132:	9b 01       	movw	r18, r22
    6134:	ac 01       	movw	r20, r24
    6136:	69 81       	ldd	r22, Y+1	; 0x01
    6138:	7a 81       	ldd	r23, Y+2	; 0x02
    613a:	8b 81       	ldd	r24, Y+3	; 0x03
    613c:	9c 81       	ldd	r25, Y+4	; 0x04
    613e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6142:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    6146:	f3 01       	movw	r30, r6
    6148:	67 8f       	std	Z+31, r22	; 0x1f
    614a:	70 a3       	std	Z+32, r23	; 0x20
    614c:	81 a3       	std	Z+33, r24	; 0x21
    614e:	92 a3       	std	Z+34, r25	; 0x22
    6150:	13 c1       	rjmp	.+550    	; 0x6378 <st_prep_buffer+0x512>
        } else {
          prep.mm_complete = decel_dist; // End of feed hold.
    6152:	d3 01       	movw	r26, r6
    6154:	53 96       	adiw	r26, 0x13	; 19
    6156:	8d 92       	st	X+, r8
    6158:	9d 92       	st	X+, r9
    615a:	ad 92       	st	X+, r10
    615c:	bc 92       	st	X, r11
    615e:	56 97       	sbiw	r26, 0x16	; 22
          prep.exit_speed = 0.0;
    6160:	f3 01       	movw	r30, r6
    6162:	17 8e       	std	Z+31, r1	; 0x1f
    6164:	10 a2       	std	Z+32, r1	; 0x20
    6166:	11 a2       	std	Z+33, r1	; 0x21
    6168:	12 a2       	std	Z+34, r1	; 0x22
    616a:	06 c1       	rjmp	.+524    	; 0x6378 <st_prep_buffer+0x512>
        }
      } else { // [Normal Operation]
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    616c:	d3 01       	movw	r26, r6
    616e:	52 96       	adiw	r26, 0x12	; 18
    6170:	1c 92       	st	X, r1
        prep.accelerate_until = pl_block->millimeters; 
    6172:	e9 81       	ldd	r30, Y+1	; 0x01
    6174:	fa 81       	ldd	r31, Y+2	; 0x02
    6176:	85 a1       	ldd	r24, Z+37	; 0x25
    6178:	96 a1       	ldd	r25, Z+38	; 0x26
    617a:	a7 a1       	ldd	r26, Z+39	; 0x27
    617c:	b0 a5       	ldd	r27, Z+40	; 0x28
    617e:	f3 01       	movw	r30, r6
    6180:	83 a3       	std	Z+35, r24	; 0x23
    6182:	94 a3       	std	Z+36, r25	; 0x24
    6184:	a5 a3       	std	Z+37, r26	; 0x25
    6186:	b6 a3       	std	Z+38, r27	; 0x26
        prep.exit_speed = plan_get_exec_block_exit_speed();   
    6188:	0e 94 15 1b 	call	0x362a	; 0x362a <plan_get_exec_block_exit_speed>
    618c:	1b 01       	movw	r2, r22
    618e:	2c 01       	movw	r4, r24
    6190:	d3 01       	movw	r26, r6
    6192:	5f 96       	adiw	r26, 0x1f	; 31
    6194:	6d 93       	st	X+, r22
    6196:	7d 93       	st	X+, r23
    6198:	8d 93       	st	X+, r24
    619a:	9c 93       	st	X, r25
    619c:	92 97       	sbiw	r26, 0x22	; 34
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
    619e:	9b 01       	movw	r18, r22
    61a0:	ac 01       	movw	r20, r24
    61a2:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    61a6:	69 83       	std	Y+1, r22	; 0x01
    61a8:	7a 83       	std	Y+2, r23	; 0x02
    61aa:	8b 83       	std	Y+3, r24	; 0x03
    61ac:	9c 83       	std	Y+4, r25	; 0x04
        float intersect_distance =
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    61ae:	e0 91 e5 04 	lds	r30, 0x04E5	; 0x8004e5 <pl_block>
    61b2:	f0 91 e6 04 	lds	r31, 0x04E6	; 0x8004e6 <pl_block+0x1>
    61b6:	fe 83       	std	Y+6, r31	; 0x06
    61b8:	ed 83       	std	Y+5, r30	; 0x05
    61ba:	25 a1       	ldd	r18, Z+37	; 0x25
    61bc:	36 a1       	ldd	r19, Z+38	; 0x26
    61be:	47 a1       	ldd	r20, Z+39	; 0x27
    61c0:	50 a5       	ldd	r21, Z+40	; 0x28
    61c2:	29 87       	std	Y+9, r18	; 0x09
    61c4:	3a 87       	std	Y+10, r19	; 0x0a
    61c6:	4b 87       	std	Y+11, r20	; 0x0b
    61c8:	5c 87       	std	Y+12, r21	; 0x0c
        // Compute or recompute velocity profile parameters of the prepped planner block.
        prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
        prep.accelerate_until = pl_block->millimeters; 
        prep.exit_speed = plan_get_exec_block_exit_speed();   
        float exit_speed_sqr = prep.exit_speed*prep.exit_speed;
        float intersect_distance =
    61ca:	9b 01       	movw	r18, r22
    61cc:	ac 01       	movw	r20, r24
    61ce:	61 89       	ldd	r22, Z+17	; 0x11
    61d0:	72 89       	ldd	r23, Z+18	; 0x12
    61d2:	83 89       	ldd	r24, Z+19	; 0x13
    61d4:	94 89       	ldd	r25, Z+20	; 0x14
    61d6:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    61da:	a5 01       	movw	r20, r10
    61dc:	94 01       	movw	r18, r8
    61de:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    61e2:	29 85       	ldd	r18, Y+9	; 0x09
    61e4:	3a 85       	ldd	r19, Y+10	; 0x0a
    61e6:	4b 85       	ldd	r20, Y+11	; 0x0b
    61e8:	5c 85       	ldd	r21, Y+12	; 0x0c
    61ea:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    61ee:	20 e0       	ldi	r18, 0x00	; 0
    61f0:	30 e0       	ldi	r19, 0x00	; 0
    61f2:	40 e0       	ldi	r20, 0x00	; 0
    61f4:	5f e3       	ldi	r21, 0x3F	; 63
    61f6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    61fa:	6b 01       	movw	r12, r22
    61fc:	7c 01       	movw	r14, r24
                0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
        if (intersect_distance > 0.0) {
    61fe:	20 e0       	ldi	r18, 0x00	; 0
    6200:	30 e0       	ldi	r19, 0x00	; 0
    6202:	a9 01       	movw	r20, r18
    6204:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6208:	18 16       	cp	r1, r24
    620a:	0c f0       	brlt	.+2      	; 0x620e <st_prep_buffer+0x3a8>
    620c:	a9 c0       	rjmp	.+338    	; 0x6360 <st_prep_buffer+0x4fa>
          if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    620e:	a7 01       	movw	r20, r14
    6210:	96 01       	movw	r18, r12
    6212:	69 85       	ldd	r22, Y+9	; 0x09
    6214:	7a 85       	ldd	r23, Y+10	; 0x0a
    6216:	8b 85       	ldd	r24, Y+11	; 0x0b
    6218:	9c 85       	ldd	r25, Y+12	; 0x0c
    621a:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    621e:	18 16       	cp	r1, r24
    6220:	0c f0       	brlt	.+2      	; 0x6224 <st_prep_buffer+0x3be>
    6222:	8d c0       	rjmp	.+282    	; 0x633e <st_prep_buffer+0x4d8>
            // NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
            prep.decelerate_after = inv_2_accel*(pl_block->nominal_speed_sqr-exit_speed_sqr);
    6224:	29 81       	ldd	r18, Y+1	; 0x01
    6226:	3a 81       	ldd	r19, Y+2	; 0x02
    6228:	4b 81       	ldd	r20, Y+3	; 0x03
    622a:	5c 81       	ldd	r21, Y+4	; 0x04
    622c:	ed 81       	ldd	r30, Y+5	; 0x05
    622e:	fe 81       	ldd	r31, Y+6	; 0x06
    6230:	65 8d       	ldd	r22, Z+29	; 0x1d
    6232:	76 8d       	ldd	r23, Z+30	; 0x1e
    6234:	87 8d       	ldd	r24, Z+31	; 0x1f
    6236:	90 a1       	ldd	r25, Z+32	; 0x20
    6238:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    623c:	a5 01       	movw	r20, r10
    623e:	94 01       	movw	r18, r8
    6240:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6244:	9b 01       	movw	r18, r22
    6246:	ac 01       	movw	r20, r24
    6248:	d3 01       	movw	r26, r6
    624a:	97 96       	adiw	r26, 0x27	; 39
    624c:	6d 93       	st	X+, r22
    624e:	7d 93       	st	X+, r23
    6250:	8d 93       	st	X+, r24
    6252:	9c 93       	st	X, r25
    6254:	9a 97       	sbiw	r26, 0x2a	; 42
            if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    6256:	c7 01       	movw	r24, r14
    6258:	b6 01       	movw	r22, r12
    625a:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    625e:	18 16       	cp	r1, r24
    6260:	0c f0       	brlt	.+2      	; 0x6264 <st_prep_buffer+0x3fe>
    6262:	41 c0       	rjmp	.+130    	; 0x62e6 <st_prep_buffer+0x480>
              prep.maximum_speed = sqrt(pl_block->nominal_speed_sqr);
    6264:	ed 81       	ldd	r30, Y+5	; 0x05
    6266:	fe 81       	ldd	r31, Y+6	; 0x06
    6268:	65 8d       	ldd	r22, Z+29	; 0x1d
    626a:	76 8d       	ldd	r23, Z+30	; 0x1e
    626c:	87 8d       	ldd	r24, Z+31	; 0x1f
    626e:	90 a1       	ldd	r25, Z+32	; 0x20
    6270:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    6274:	d3 01       	movw	r26, r6
    6276:	5b 96       	adiw	r26, 0x1b	; 27
    6278:	6d 93       	st	X+, r22
    627a:	7d 93       	st	X+, r23
    627c:	8d 93       	st	X+, r24
    627e:	9c 93       	st	X, r25
    6280:	5e 97       	sbiw	r26, 0x1e	; 30
              if (pl_block->entry_speed_sqr == pl_block->nominal_speed_sqr) { 
    6282:	ed 81       	ldd	r30, Y+5	; 0x05
    6284:	fe 81       	ldd	r31, Y+6	; 0x06
    6286:	c1 88       	ldd	r12, Z+17	; 0x11
    6288:	d2 88       	ldd	r13, Z+18	; 0x12
    628a:	e3 88       	ldd	r14, Z+19	; 0x13
    628c:	f4 88       	ldd	r15, Z+20	; 0x14
    628e:	25 8c       	ldd	r2, Z+29	; 0x1d
    6290:	36 8c       	ldd	r3, Z+30	; 0x1e
    6292:	47 8c       	ldd	r4, Z+31	; 0x1f
    6294:	50 a0       	ldd	r5, Z+32	; 0x20
    6296:	a2 01       	movw	r20, r4
    6298:	91 01       	movw	r18, r2
    629a:	c7 01       	movw	r24, r14
    629c:	b6 01       	movw	r22, r12
    629e:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    62a2:	81 11       	cpse	r24, r1
    62a4:	05 c0       	rjmp	.+10     	; 0x62b0 <st_prep_buffer+0x44a>
                // Cruise-deceleration or cruise-only type.
                prep.ramp_type = RAMP_CRUISE;
    62a6:	e1 e0       	ldi	r30, 0x01	; 1
    62a8:	d3 01       	movw	r26, r6
    62aa:	52 96       	adiw	r26, 0x12	; 18
    62ac:	ec 93       	st	X, r30
    62ae:	64 c0       	rjmp	.+200    	; 0x6378 <st_prep_buffer+0x512>
              } else {
                // Full-trapezoid or acceleration-cruise types
                prep.accelerate_until -= inv_2_accel*(pl_block->nominal_speed_sqr-pl_block->entry_speed_sqr); 
    62b0:	a7 01       	movw	r20, r14
    62b2:	96 01       	movw	r18, r12
    62b4:	c2 01       	movw	r24, r4
    62b6:	b1 01       	movw	r22, r2
    62b8:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    62bc:	a5 01       	movw	r20, r10
    62be:	94 01       	movw	r18, r8
    62c0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    62c4:	9b 01       	movw	r18, r22
    62c6:	ac 01       	movw	r20, r24
    62c8:	d3 01       	movw	r26, r6
    62ca:	93 96       	adiw	r26, 0x23	; 35
    62cc:	6d 91       	ld	r22, X+
    62ce:	7d 91       	ld	r23, X+
    62d0:	8d 91       	ld	r24, X+
    62d2:	9c 91       	ld	r25, X
    62d4:	96 97       	sbiw	r26, 0x26	; 38
    62d6:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    62da:	f3 01       	movw	r30, r6
    62dc:	63 a3       	std	Z+35, r22	; 0x23
    62de:	74 a3       	std	Z+36, r23	; 0x24
    62e0:	85 a3       	std	Z+37, r24	; 0x25
    62e2:	96 a3       	std	Z+38, r25	; 0x26
    62e4:	49 c0       	rjmp	.+146    	; 0x6378 <st_prep_buffer+0x512>
              }
            } else { // Triangle type
              prep.accelerate_until = intersect_distance;
    62e6:	d3 01       	movw	r26, r6
    62e8:	93 96       	adiw	r26, 0x23	; 35
    62ea:	cd 92       	st	X+, r12
    62ec:	dd 92       	st	X+, r13
    62ee:	ed 92       	st	X+, r14
    62f0:	fc 92       	st	X, r15
    62f2:	96 97       	sbiw	r26, 0x26	; 38
              prep.decelerate_after = intersect_distance;
    62f4:	f3 01       	movw	r30, r6
    62f6:	c7 a2       	std	Z+39, r12	; 0x27
    62f8:	d0 a6       	std	Z+40, r13	; 0x28
    62fa:	e1 a6       	std	Z+41, r14	; 0x29
    62fc:	f2 a6       	std	Z+42, r15	; 0x2a
              prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    62fe:	ad 81       	ldd	r26, Y+5	; 0x05
    6300:	be 81       	ldd	r27, Y+6	; 0x06
    6302:	91 96       	adiw	r26, 0x21	; 33
    6304:	8d 90       	ld	r8, X+
    6306:	9d 90       	ld	r9, X+
    6308:	ad 90       	ld	r10, X+
    630a:	bc 90       	ld	r11, X
    630c:	94 97       	sbiw	r26, 0x24	; 36
    630e:	a5 01       	movw	r20, r10
    6310:	94 01       	movw	r18, r8
    6312:	c5 01       	movw	r24, r10
    6314:	b4 01       	movw	r22, r8
    6316:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    631a:	a7 01       	movw	r20, r14
    631c:	96 01       	movw	r18, r12
    631e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6322:	29 81       	ldd	r18, Y+1	; 0x01
    6324:	3a 81       	ldd	r19, Y+2	; 0x02
    6326:	4b 81       	ldd	r20, Y+3	; 0x03
    6328:	5c 81       	ldd	r21, Y+4	; 0x04
    632a:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    632e:	0e 94 ac 3d 	call	0x7b58	; 0x7b58 <sqrt>
    6332:	f3 01       	movw	r30, r6
    6334:	63 8f       	std	Z+27, r22	; 0x1b
    6336:	74 8f       	std	Z+28, r23	; 0x1c
    6338:	85 8f       	std	Z+29, r24	; 0x1d
    633a:	96 8f       	std	Z+30, r25	; 0x1e
    633c:	1d c0       	rjmp	.+58     	; 0x6378 <st_prep_buffer+0x512>
            }          
          } else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    633e:	e2 e0       	ldi	r30, 0x02	; 2
    6340:	d3 01       	movw	r26, r6
    6342:	52 96       	adiw	r26, 0x12	; 18
    6344:	ec 93       	st	X, r30
    6346:	52 97       	sbiw	r26, 0x12	; 18
            // prep.decelerate_after = pl_block->millimeters;
            prep.maximum_speed = prep.current_speed;
    6348:	57 96       	adiw	r26, 0x17	; 23
    634a:	8d 91       	ld	r24, X+
    634c:	9d 91       	ld	r25, X+
    634e:	0d 90       	ld	r0, X+
    6350:	bc 91       	ld	r27, X
    6352:	a0 2d       	mov	r26, r0
    6354:	f3 01       	movw	r30, r6
    6356:	83 8f       	std	Z+27, r24	; 0x1b
    6358:	94 8f       	std	Z+28, r25	; 0x1c
    635a:	a5 8f       	std	Z+29, r26	; 0x1d
    635c:	b6 8f       	std	Z+30, r27	; 0x1e
    635e:	0c c0       	rjmp	.+24     	; 0x6378 <st_prep_buffer+0x512>
          }
        } else { // Acceleration-only type
          prep.accelerate_until = 0.0;
    6360:	d3 01       	movw	r26, r6
    6362:	93 96       	adiw	r26, 0x23	; 35
    6364:	1d 92       	st	X+, r1
    6366:	1d 92       	st	X+, r1
    6368:	1d 92       	st	X+, r1
    636a:	1c 92       	st	X, r1
    636c:	96 97       	sbiw	r26, 0x26	; 38
          // prep.decelerate_after = 0.0;
          prep.maximum_speed = prep.exit_speed;
    636e:	f3 01       	movw	r30, r6
    6370:	23 8e       	std	Z+27, r2	; 0x1b
    6372:	34 8e       	std	Z+28, r3	; 0x1c
    6374:	45 8e       	std	Z+29, r4	; 0x1d
    6376:	56 8e       	std	Z+30, r5	; 0x1e
        }
      }  
    }

    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    6378:	e0 91 eb 04 	lds	r30, 0x04EB	; 0x8004eb <segment_buffer_head>
    637c:	2e 2f       	mov	r18, r30
    637e:	30 e0       	ldi	r19, 0x00	; 0
    6380:	3a a7       	std	Y+42, r19	; 0x2a
    6382:	29 a7       	std	Y+41, r18	; 0x29

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    6384:	f9 01       	movw	r30, r18
    6386:	ee 0f       	add	r30, r30
    6388:	ff 1f       	adc	r31, r31
    638a:	e2 0f       	add	r30, r18
    638c:	f3 1f       	adc	r31, r19
    638e:	ee 0f       	add	r30, r30
    6390:	ff 1f       	adc	r31, r31
    6392:	e0 5f       	subi	r30, 0xF0	; 240
    6394:	fa 4f       	sbci	r31, 0xFA	; 250
    6396:	d3 01       	movw	r26, r6
    6398:	8c 91       	ld	r24, X
    639a:	82 83       	std	Z+2, r24	; 0x02
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable   
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    639c:	e0 91 e5 04 	lds	r30, 0x04E5	; 0x8004e5 <pl_block>
    63a0:	f0 91 e6 04 	lds	r31, 0x04E6	; 0x8004e6 <pl_block+0x1>
    63a4:	f8 a3       	std	Y+32, r31	; 0x20
    63a6:	ef 8f       	std	Y+31, r30	; 0x1f
    63a8:	f5 a1       	ldd	r31, Z+37	; 0x25
    63aa:	f8 ab       	std	Y+48, r31	; 0x30
    63ac:	af 8d       	ldd	r26, Y+31	; 0x1f
    63ae:	b8 a1       	ldd	r27, Y+32	; 0x20
    63b0:	96 96       	adiw	r26, 0x26	; 38
    63b2:	bc 91       	ld	r27, X
    63b4:	b9 ab       	std	Y+49, r27	; 0x31
    63b6:	ef 8d       	ldd	r30, Y+31	; 0x1f
    63b8:	f8 a1       	ldd	r31, Y+32	; 0x20
    63ba:	f7 a1       	ldd	r31, Z+39	; 0x27
    63bc:	fa ab       	std	Y+50, r31	; 0x32
    63be:	af 8d       	ldd	r26, Y+31	; 0x1f
    63c0:	b8 a1       	ldd	r27, Y+32	; 0x20
    63c2:	98 96       	adiw	r26, 0x28	; 40
    63c4:	bc 91       	ld	r27, X
    63c6:	bb ab       	std	Y+51, r27	; 0x33
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    63c8:	f3 01       	movw	r30, r6
    63ca:	22 85       	ldd	r18, Z+10	; 0x0a
    63cc:	33 85       	ldd	r19, Z+11	; 0x0b
    63ce:	44 85       	ldd	r20, Z+12	; 0x0c
    63d0:	55 85       	ldd	r21, Z+13	; 0x0d
    63d2:	68 a9       	ldd	r22, Y+48	; 0x30
    63d4:	79 a9       	ldd	r23, Y+49	; 0x31
    63d6:	8a a9       	ldd	r24, Y+50	; 0x32
    63d8:	9b 2f       	mov	r25, r27
    63da:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    63de:	6b a7       	std	Y+43, r22	; 0x2b
    63e0:	7c a7       	std	Y+44, r23	; 0x2c
    63e2:	8d a7       	std	Y+45, r24	; 0x2d
    63e4:	9e a7       	std	Y+46, r25	; 0x2e
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    63e6:	20 e0       	ldi	r18, 0x00	; 0
    63e8:	30 e0       	ldi	r19, 0x00	; 0
    63ea:	a9 01       	movw	r20, r18
    63ec:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    63f0:	88 23       	and	r24, r24
    63f2:	24 f4       	brge	.+8      	; 0x63fc <st_prep_buffer+0x596>
    63f4:	1b a6       	std	Y+43, r1	; 0x2b
    63f6:	1c a6       	std	Y+44, r1	; 0x2c
    63f8:	1d a6       	std	Y+45, r1	; 0x2d
    63fa:	1e a6       	std	Y+46, r1	; 0x2e
    63fc:	d3 01       	movw	r26, r6
    63fe:	57 96       	adiw	r26, 0x17	; 23
    6400:	bc 91       	ld	r27, X
    6402:	b9 87       	std	Y+9, r27	; 0x09
    6404:	f3 01       	movw	r30, r6
    6406:	f0 8d       	ldd	r31, Z+24	; 0x18
    6408:	fd 87       	std	Y+13, r31	; 0x0d
    640a:	d3 01       	movw	r26, r6
    640c:	59 96       	adiw	r26, 0x19	; 25
    640e:	bc 91       	ld	r27, X
    6410:	b9 8b       	std	Y+17, r27	; 0x11
    6412:	f3 01       	movw	r30, r6
    6414:	f2 8d       	ldd	r31, Z+26	; 0x1a
    6416:	fd 8b       	std	Y+21, r31	; 0x15
      switch (prep.ramp_type) {
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    6418:	d3 01       	movw	r26, r6
    641a:	93 96       	adiw	r26, 0x23	; 35
    641c:	bc 91       	ld	r27, X
    641e:	b9 a3       	std	Y+33, r27	; 0x21
    6420:	f3 01       	movw	r30, r6
    6422:	f4 a1       	ldd	r31, Z+36	; 0x24
    6424:	fa a3       	std	Y+34, r31	; 0x22
    6426:	d3 01       	movw	r26, r6
    6428:	95 96       	adiw	r26, 0x25	; 37
    642a:	bc 91       	ld	r27, X
    642c:	bb a3       	std	Y+35, r27	; 0x23
    642e:	f3 01       	movw	r30, r6
    6430:	f6 a1       	ldd	r31, Z+38	; 0x26
    6432:	fc a3       	std	Y+36, r31	; 0x24
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    6434:	d3 01       	movw	r26, r6
    6436:	5b 96       	adiw	r26, 0x1b	; 27
    6438:	bc 91       	ld	r27, X
    643a:	bb 8f       	std	Y+27, r27	; 0x1b
    643c:	f3 01       	movw	r30, r6
    643e:	f4 8d       	ldd	r31, Z+28	; 0x1c
    6440:	fc 8f       	std	Y+28, r31	; 0x1c
    6442:	d3 01       	movw	r26, r6
    6444:	5d 96       	adiw	r26, 0x1d	; 29
    6446:	bc 91       	ld	r27, X
    6448:	bd 8f       	std	Y+29, r27	; 0x1d
    644a:	f3 01       	movw	r30, r6
    644c:	f6 8d       	ldd	r31, Z+30	; 0x1e
    644e:	fe 8f       	std	Y+30, r31	; 0x1e
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    6450:	d3 01       	movw	r26, r6
    6452:	97 96       	adiw	r26, 0x27	; 39
    6454:	bc 91       	ld	r27, X
    6456:	bd a3       	std	Y+37, r27	; 0x25
    6458:	f3 01       	movw	r30, r6
    645a:	f0 a5       	ldd	r31, Z+40	; 0x28
    645c:	fe a3       	std	Y+38, r31	; 0x26
    645e:	d3 01       	movw	r26, r6
    6460:	99 96       	adiw	r26, 0x29	; 41
    6462:	bc 91       	ld	r27, X
    6464:	bf a3       	std	Y+39, r27	; 0x27
    6466:	f3 01       	movw	r30, r6
    6468:	f2 a5       	ldd	r31, Z+42	; 0x2a
    646a:	f8 a7       	std	Y+40, r31	; 0x28
    646c:	d3 01       	movw	r26, r6
    646e:	52 96       	adiw	r26, 0x12	; 18
    6470:	bc 91       	ld	r27, X
    6472:	bd 83       	std	Y+5, r27	; 0x05
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
    6474:	f3 01       	movw	r30, r6
    6476:	f3 89       	ldd	r31, Z+19	; 0x13
    6478:	fe 8b       	std	Y+22, r31	; 0x16
    647a:	d3 01       	movw	r26, r6
    647c:	54 96       	adiw	r26, 0x14	; 20
    647e:	bc 91       	ld	r27, X
    6480:	bf 8b       	std	Y+23, r27	; 0x17
    6482:	f3 01       	movw	r30, r6
    6484:	f5 89       	ldd	r31, Z+21	; 0x15
    6486:	f8 8f       	std	Y+24, r31	; 0x18
    6488:	d3 01       	movw	r26, r6
    648a:	56 96       	adiw	r26, 0x16	; 22
    648c:	bc 91       	ld	r27, X
    648e:	b9 8f       	std	Y+25, r27	; 0x19
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    6490:	d3 01       	movw	r26, r6
    6492:	5f 96       	adiw	r26, 0x1f	; 31
    6494:	2d 91       	ld	r18, X+
    6496:	3d 91       	ld	r19, X+
    6498:	4d 91       	ld	r20, X+
    649a:	5c 91       	ld	r21, X
    649c:	92 97       	sbiw	r26, 0x22	; 34
    649e:	2c ab       	std	Y+52, r18	; 0x34
    64a0:	3d ab       	std	Y+53, r19	; 0x35
    64a2:	4e ab       	std	Y+54, r20	; 0x36
    64a4:	5f ab       	std	Y+55, r21	; 0x37
    64a6:	2d a1       	ldd	r18, Y+37	; 0x25
    64a8:	3e a1       	ldd	r19, Y+38	; 0x26
    64aa:	4f a1       	ldd	r20, Y+39	; 0x27
    64ac:	58 a5       	ldd	r21, Y+40	; 0x28
    64ae:	69 a1       	ldd	r22, Y+33	; 0x21
    64b0:	7a a1       	ldd	r23, Y+34	; 0x22
    64b2:	8b a1       	ldd	r24, Y+35	; 0x23
    64b4:	9c a1       	ldd	r25, Y+36	; 0x24
    64b6:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    64ba:	81 11       	cpse	r24, r1
    64bc:	02 c0       	rjmp	.+4      	; 0x64c2 <st_prep_buffer+0x65c>
    64be:	82 e0       	ldi	r24, 0x02	; 2
    64c0:	01 c0       	rjmp	.+2      	; 0x64c4 <st_prep_buffer+0x65e>
    64c2:	81 e0       	ldi	r24, 0x01	; 1
    64c4:	e8 a8       	ldd	r14, Y+48	; 0x30
    64c6:	f9 a8       	ldd	r15, Y+49	; 0x31
    64c8:	0a a9       	ldd	r16, Y+50	; 0x32
    64ca:	1b a9       	ldd	r17, Y+51	; 0x33
    64cc:	0f 2e       	mov	r0, r31
    64ce:	fe e3       	ldi	r31, 0x3E	; 62
    64d0:	5f 2e       	mov	r5, r31
    64d2:	f0 2d       	mov	r31, r0
    64d4:	0f 2e       	mov	r0, r31
    64d6:	f3 ec       	ldi	r31, 0xC3	; 195
    64d8:	4f 2e       	mov	r4, r31
    64da:	f0 2d       	mov	r31, r0
    64dc:	0f 2e       	mov	r0, r31
    64de:	fe e2       	ldi	r31, 0x2E	; 46
    64e0:	3f 2e       	mov	r3, r31
    64e2:	f0 2d       	mov	r31, r0
    64e4:	0f 2e       	mov	r0, r31
    64e6:	f9 e3       	ldi	r31, 0x39	; 57
    64e8:	2f 2e       	mov	r2, r31
    64ea:	f0 2d       	mov	r31, r0
    64ec:	81 2c       	mov	r8, r1
    64ee:	91 2c       	mov	r9, r1
    64f0:	54 01       	movw	r10, r8
    64f2:	be e3       	ldi	r27, 0x3E	; 62
    64f4:	ba 8f       	std	Y+26, r27	; 0x1a
    64f6:	e3 ec       	ldi	r30, 0xC3	; 195
    64f8:	e9 83       	std	Y+1, r30	; 0x01
    64fa:	0f 2e       	mov	r0, r31
    64fc:	fe e2       	ldi	r31, 0x2E	; 46
    64fe:	cf 2e       	mov	r12, r31
    6500:	f0 2d       	mov	r31, r0
    6502:	0f 2e       	mov	r0, r31
    6504:	f9 e3       	ldi	r31, 0x39	; 57
    6506:	df 2e       	mov	r13, r31
    6508:	f0 2d       	mov	r31, r0
    650a:	88 af       	std	Y+56, r24	; 0x38
    650c:	7b ae       	std	Y+59, r7	; 0x3b
    650e:	6a ae       	std	Y+58, r6	; 0x3a
    6510:	0f 2e       	mov	r0, r31
    6512:	fe e3       	ldi	r31, 0x3E	; 62
    6514:	7f 2e       	mov	r7, r31
    6516:	f0 2d       	mov	r31, r0
    6518:	8d 2d       	mov	r24, r13
    651a:	dc 2c       	mov	r13, r12
    651c:	9f 2d       	mov	r25, r15
    651e:	fe 2c       	mov	r15, r14
    6520:	0d af       	std	Y+61, r16	; 0x3d
    6522:	01 2f       	mov	r16, r17
    6524:	1d 81       	ldd	r17, Y+5	; 0x05
    6526:	e9 2e       	mov	r14, r25
    6528:	c8 2e       	mov	r12, r24
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    652a:	11 23       	and	r17, r17
    652c:	21 f0       	breq	.+8      	; 0x6536 <st_prep_buffer+0x6d0>
    652e:	11 30       	cpi	r17, 0x01	; 1
    6530:	09 f4       	brne	.+2      	; 0x6534 <st_prep_buffer+0x6ce>
    6532:	7b c0       	rjmp	.+246    	; 0x662a <st_prep_buffer+0x7c4>
    6534:	b8 c0       	rjmp	.+368    	; 0x66a6 <st_prep_buffer+0x840>
        case RAMP_ACCEL: 
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    6536:	af 8d       	ldd	r26, Y+31	; 0x1f
    6538:	b8 a1       	ldd	r27, Y+32	; 0x20
    653a:	91 96       	adiw	r26, 0x21	; 33
    653c:	2d 91       	ld	r18, X+
    653e:	3d 91       	ld	r19, X+
    6540:	4d 91       	ld	r20, X+
    6542:	5c 91       	ld	r21, X
    6544:	94 97       	sbiw	r26, 0x24	; 36
    6546:	65 2d       	mov	r22, r5
    6548:	74 2d       	mov	r23, r4
    654a:	83 2d       	mov	r24, r3
    654c:	92 2d       	mov	r25, r2
    654e:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6552:	6d 83       	std	Y+5, r22	; 0x05
    6554:	7e 83       	std	Y+6, r23	; 0x06
    6556:	8f 83       	std	Y+7, r24	; 0x07
    6558:	98 87       	std	Y+8, r25	; 0x08
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    655a:	20 e0       	ldi	r18, 0x00	; 0
    655c:	30 e0       	ldi	r19, 0x00	; 0
    655e:	40 e0       	ldi	r20, 0x00	; 0
    6560:	5f e3       	ldi	r21, 0x3F	; 63
    6562:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6566:	29 85       	ldd	r18, Y+9	; 0x09
    6568:	3d 85       	ldd	r19, Y+13	; 0x0d
    656a:	49 89       	ldd	r20, Y+17	; 0x11
    656c:	5d 89       	ldd	r21, Y+21	; 0x15
    656e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    6572:	25 2d       	mov	r18, r5
    6574:	34 2d       	mov	r19, r4
    6576:	43 2d       	mov	r20, r3
    6578:	52 2d       	mov	r21, r2
    657a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    657e:	9b 01       	movw	r18, r22
    6580:	ac 01       	movw	r20, r24
    6582:	6f 2d       	mov	r22, r15
    6584:	7e 2d       	mov	r23, r14
    6586:	8d ad       	ldd	r24, Y+61	; 0x3d
    6588:	90 2f       	mov	r25, r16
    658a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    658e:	f6 2e       	mov	r15, r22
    6590:	e7 2e       	mov	r14, r23
    6592:	8d af       	std	Y+61, r24	; 0x3d
    6594:	09 2f       	mov	r16, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    6596:	29 a1       	ldd	r18, Y+33	; 0x21
    6598:	3a a1       	ldd	r19, Y+34	; 0x22
    659a:	4b a1       	ldd	r20, Y+35	; 0x23
    659c:	5c a1       	ldd	r21, Y+36	; 0x24
    659e:	0e 94 ab 3a 	call	0x7556	; 0x7556 <__cmpsf2>
    65a2:	88 23       	and	r24, r24
    65a4:	9c f5       	brge	.+102    	; 0x660c <st_prep_buffer+0x7a6>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    65a6:	29 a1       	ldd	r18, Y+33	; 0x21
    65a8:	3a a1       	ldd	r19, Y+34	; 0x22
    65aa:	4b a1       	ldd	r20, Y+35	; 0x23
    65ac:	5c a1       	ldd	r21, Y+36	; 0x24
    65ae:	68 a9       	ldd	r22, Y+48	; 0x30
    65b0:	79 a9       	ldd	r23, Y+49	; 0x31
    65b2:	8a a9       	ldd	r24, Y+50	; 0x32
    65b4:	9b a9       	ldd	r25, Y+51	; 0x33
    65b6:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    65ba:	9b 01       	movw	r18, r22
    65bc:	ac 01       	movw	r20, r24
    65be:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    65c2:	1b 01       	movw	r2, r22
    65c4:	2c 01       	movw	r4, r24
    65c6:	29 85       	ldd	r18, Y+9	; 0x09
    65c8:	3d 85       	ldd	r19, Y+13	; 0x0d
    65ca:	49 89       	ldd	r20, Y+17	; 0x11
    65cc:	5d 89       	ldd	r21, Y+21	; 0x15
    65ce:	6b 8d       	ldd	r22, Y+27	; 0x1b
    65d0:	7c 8d       	ldd	r23, Y+28	; 0x1c
    65d2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    65d4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    65d6:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    65da:	9b 01       	movw	r18, r22
    65dc:	ac 01       	movw	r20, r24
    65de:	c2 01       	movw	r24, r4
    65e0:	b1 01       	movw	r22, r2
    65e2:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    65e6:	56 2e       	mov	r5, r22
    65e8:	47 2e       	mov	r4, r23
    65ea:	38 2e       	mov	r3, r24
    65ec:	29 2e       	mov	r2, r25
    65ee:	18 ad       	ldd	r17, Y+56	; 0x38
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    65f0:	bb 8d       	ldd	r27, Y+27	; 0x1b
    65f2:	b9 87       	std	Y+9, r27	; 0x09
    65f4:	ec 8d       	ldd	r30, Y+28	; 0x1c
    65f6:	ed 87       	std	Y+13, r30	; 0x0d
    65f8:	fd 8d       	ldd	r31, Y+29	; 0x1d
    65fa:	f9 8b       	std	Y+17, r31	; 0x11
    65fc:	2e 8d       	ldd	r18, Y+30	; 0x1e
    65fe:	2d 8b       	std	Y+21, r18	; 0x15
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    6600:	f9 a0       	ldd	r15, Y+33	; 0x21
    6602:	ea a0       	ldd	r14, Y+34	; 0x22
    6604:	3b a1       	ldd	r19, Y+35	; 0x23
    6606:	3d af       	std	Y+61, r19	; 0x3d
    6608:	0c a1       	ldd	r16, Y+36	; 0x24
    660a:	d7 c0       	rjmp	.+430    	; 0x67ba <st_prep_buffer+0x954>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only. 
            prep.current_speed += speed_var;
    660c:	2d 81       	ldd	r18, Y+5	; 0x05
    660e:	3e 81       	ldd	r19, Y+6	; 0x06
    6610:	4f 81       	ldd	r20, Y+7	; 0x07
    6612:	58 85       	ldd	r21, Y+8	; 0x08
    6614:	69 85       	ldd	r22, Y+9	; 0x09
    6616:	7d 85       	ldd	r23, Y+13	; 0x0d
    6618:	89 89       	ldd	r24, Y+17	; 0x11
    661a:	9d 89       	ldd	r25, Y+21	; 0x15
    661c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    6620:	69 87       	std	Y+9, r22	; 0x09
    6622:	7d 87       	std	Y+13, r23	; 0x0d
    6624:	89 8b       	std	Y+17, r24	; 0x11
    6626:	9d 8b       	std	Y+21, r25	; 0x15
    6628:	c8 c0       	rjmp	.+400    	; 0x67ba <st_prep_buffer+0x954>
          break;
        case RAMP_CRUISE: 
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To 
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    662a:	2b 8d       	ldd	r18, Y+27	; 0x1b
    662c:	3c 8d       	ldd	r19, Y+28	; 0x1c
    662e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    6630:	5e 8d       	ldd	r21, Y+30	; 0x1e
    6632:	65 2d       	mov	r22, r5
    6634:	74 2d       	mov	r23, r4
    6636:	83 2d       	mov	r24, r3
    6638:	92 2d       	mov	r25, r2
    663a:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    663e:	9b 01       	movw	r18, r22
    6640:	ac 01       	movw	r20, r24
    6642:	6f 2d       	mov	r22, r15
    6644:	7e 2d       	mov	r23, r14
    6646:	8d ad       	ldd	r24, Y+61	; 0x3d
    6648:	90 2f       	mov	r25, r16
    664a:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    664e:	6d 83       	std	Y+5, r22	; 0x05
    6650:	7a 8f       	std	Y+26, r23	; 0x1a
    6652:	68 2e       	mov	r6, r24
    6654:	9f a7       	std	Y+47, r25	; 0x2f
          if (mm_var < prep.decelerate_after) { // End of cruise. 
    6656:	26 2f       	mov	r18, r22
    6658:	37 2f       	mov	r19, r23
    665a:	48 2f       	mov	r20, r24
    665c:	59 2f       	mov	r21, r25
    665e:	6d a1       	ldd	r22, Y+37	; 0x25
    6660:	7e a1       	ldd	r23, Y+38	; 0x26
    6662:	8f a1       	ldd	r24, Y+39	; 0x27
    6664:	98 a5       	ldd	r25, Y+40	; 0x28
    6666:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    666a:	18 16       	cp	r1, r24
    666c:	0c f0       	brlt	.+2      	; 0x6670 <st_prep_buffer+0x80a>
    666e:	a1 c0       	rjmp	.+322    	; 0x67b2 <st_prep_buffer+0x94c>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    6670:	2d a1       	ldd	r18, Y+37	; 0x25
    6672:	3e a1       	ldd	r19, Y+38	; 0x26
    6674:	4f a1       	ldd	r20, Y+39	; 0x27
    6676:	58 a5       	ldd	r21, Y+40	; 0x28
    6678:	6f 2d       	mov	r22, r15
    667a:	7e 2d       	mov	r23, r14
    667c:	8d ad       	ldd	r24, Y+61	; 0x3d
    667e:	90 2f       	mov	r25, r16
    6680:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6684:	2b 8d       	ldd	r18, Y+27	; 0x1b
    6686:	3c 8d       	ldd	r19, Y+28	; 0x1c
    6688:	4d 8d       	ldd	r20, Y+29	; 0x1d
    668a:	5e 8d       	ldd	r21, Y+30	; 0x1e
    668c:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    6690:	56 2e       	mov	r5, r22
    6692:	47 2e       	mov	r4, r23
    6694:	38 2e       	mov	r3, r24
    6696:	29 2e       	mov	r2, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    6698:	fd a0       	ldd	r15, Y+37	; 0x25
    669a:	ee a0       	ldd	r14, Y+38	; 0x26
    669c:	4f a1       	ldd	r20, Y+39	; 0x27
    669e:	4d af       	std	Y+61, r20	; 0x3d
    66a0:	08 a5       	ldd	r16, Y+40	; 0x28
            prep.ramp_type = RAMP_DECEL;
    66a2:	19 ad       	ldd	r17, Y+57	; 0x39
    66a4:	8a c0       	rjmp	.+276    	; 0x67ba <st_prep_buffer+0x954>
            mm_remaining = mm_var; 
          } 
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    66a6:	af 8d       	ldd	r26, Y+31	; 0x1f
    66a8:	b8 a1       	ldd	r27, Y+32	; 0x20
    66aa:	91 96       	adiw	r26, 0x21	; 33
    66ac:	2d 91       	ld	r18, X+
    66ae:	3d 91       	ld	r19, X+
    66b0:	4d 91       	ld	r20, X+
    66b2:	5c 91       	ld	r21, X
    66b4:	94 97       	sbiw	r26, 0x24	; 36
    66b6:	65 2d       	mov	r22, r5
    66b8:	74 2d       	mov	r23, r4
    66ba:	83 2d       	mov	r24, r3
    66bc:	92 2d       	mov	r25, r2
    66be:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    66c2:	6d 83       	std	Y+5, r22	; 0x05
    66c4:	7e 83       	std	Y+6, r23	; 0x06
    66c6:	8f 83       	std	Y+7, r24	; 0x07
    66c8:	98 87       	std	Y+8, r25	; 0x08
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    66ca:	9b 01       	movw	r18, r22
    66cc:	ac 01       	movw	r20, r24
    66ce:	69 85       	ldd	r22, Y+9	; 0x09
    66d0:	7d 85       	ldd	r23, Y+13	; 0x0d
    66d2:	89 89       	ldd	r24, Y+17	; 0x11
    66d4:	9d 89       	ldd	r25, Y+21	; 0x15
    66d6:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    66da:	18 16       	cp	r1, r24
    66dc:	0c f0       	brlt	.+2      	; 0x66e0 <st_prep_buffer+0x87a>
    66de:	3f c0       	rjmp	.+126    	; 0x675e <st_prep_buffer+0x8f8>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    66e0:	20 e0       	ldi	r18, 0x00	; 0
    66e2:	30 e0       	ldi	r19, 0x00	; 0
    66e4:	40 e0       	ldi	r20, 0x00	; 0
    66e6:	5f e3       	ldi	r21, 0x3F	; 63
    66e8:	6d 81       	ldd	r22, Y+5	; 0x05
    66ea:	7e 81       	ldd	r23, Y+6	; 0x06
    66ec:	8f 81       	ldd	r24, Y+7	; 0x07
    66ee:	98 85       	ldd	r25, Y+8	; 0x08
    66f0:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    66f4:	9b 01       	movw	r18, r22
    66f6:	ac 01       	movw	r20, r24
    66f8:	69 85       	ldd	r22, Y+9	; 0x09
    66fa:	7d 85       	ldd	r23, Y+13	; 0x0d
    66fc:	89 89       	ldd	r24, Y+17	; 0x11
    66fe:	9d 89       	ldd	r25, Y+21	; 0x15
    6700:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6704:	25 2d       	mov	r18, r5
    6706:	34 2d       	mov	r19, r4
    6708:	43 2d       	mov	r20, r3
    670a:	52 2d       	mov	r21, r2
    670c:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    6710:	9b 01       	movw	r18, r22
    6712:	ac 01       	movw	r20, r24
    6714:	6f 2d       	mov	r22, r15
    6716:	7e 2d       	mov	r23, r14
    6718:	8d ad       	ldd	r24, Y+61	; 0x3d
    671a:	90 2f       	mov	r25, r16
    671c:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6720:	6a 8f       	std	Y+26, r22	; 0x1a
    6722:	7f a7       	std	Y+47, r23	; 0x2f
    6724:	68 2e       	mov	r6, r24
    6726:	9c af       	std	Y+60, r25	; 0x3c
            if (mm_var > prep.mm_complete) { // Deceleration only.
    6728:	2e 89       	ldd	r18, Y+22	; 0x16
    672a:	3f 89       	ldd	r19, Y+23	; 0x17
    672c:	48 8d       	ldd	r20, Y+24	; 0x18
    672e:	59 8d       	ldd	r21, Y+25	; 0x19
    6730:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6734:	18 16       	cp	r1, r24
    6736:	9c f4       	brge	.+38     	; 0x675e <st_prep_buffer+0x8f8>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    6738:	2d 81       	ldd	r18, Y+5	; 0x05
    673a:	3e 81       	ldd	r19, Y+6	; 0x06
    673c:	4f 81       	ldd	r20, Y+7	; 0x07
    673e:	58 85       	ldd	r21, Y+8	; 0x08
    6740:	69 85       	ldd	r22, Y+9	; 0x09
    6742:	7d 85       	ldd	r23, Y+13	; 0x0d
    6744:	89 89       	ldd	r24, Y+17	; 0x11
    6746:	9d 89       	ldd	r25, Y+21	; 0x15
    6748:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    674c:	69 87       	std	Y+9, r22	; 0x09
    674e:	7d 87       	std	Y+13, r23	; 0x0d
    6750:	89 8b       	std	Y+17, r24	; 0x11
    6752:	9d 8b       	std	Y+21, r25	; 0x15
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Deceleration only.
              mm_remaining = mm_var;
    6754:	fa 8c       	ldd	r15, Y+26	; 0x1a
    6756:	ef a4       	ldd	r14, Y+47	; 0x2f
    6758:	6d ae       	std	Y+61, r6	; 0x3d
    675a:	0c ad       	ldd	r16, Y+60	; 0x3c
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    675c:	2e c0       	rjmp	.+92     	; 0x67ba <st_prep_buffer+0x954>
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    675e:	2e 89       	ldd	r18, Y+22	; 0x16
    6760:	3f 89       	ldd	r19, Y+23	; 0x17
    6762:	48 8d       	ldd	r20, Y+24	; 0x18
    6764:	59 8d       	ldd	r21, Y+25	; 0x19
    6766:	6f 2d       	mov	r22, r15
    6768:	7e 2d       	mov	r23, r14
    676a:	8d ad       	ldd	r24, Y+61	; 0x3d
    676c:	90 2f       	mov	r25, r16
    676e:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6772:	9b 01       	movw	r18, r22
    6774:	ac 01       	movw	r20, r24
    6776:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    677a:	1b 01       	movw	r2, r22
    677c:	2c 01       	movw	r4, r24
    677e:	2c a9       	ldd	r18, Y+52	; 0x34
    6780:	3d a9       	ldd	r19, Y+53	; 0x35
    6782:	4e a9       	ldd	r20, Y+54	; 0x36
    6784:	5f a9       	ldd	r21, Y+55	; 0x37
    6786:	69 85       	ldd	r22, Y+9	; 0x09
    6788:	7d 85       	ldd	r23, Y+13	; 0x0d
    678a:	89 89       	ldd	r24, Y+17	; 0x11
    678c:	9d 89       	ldd	r25, Y+21	; 0x15
    678e:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    6792:	9b 01       	movw	r18, r22
    6794:	ac 01       	movw	r20, r24
    6796:	c2 01       	movw	r24, r4
    6798:	b1 01       	movw	r22, r2
    679a:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    679e:	56 2e       	mov	r5, r22
    67a0:	47 2e       	mov	r4, r23
    67a2:	38 2e       	mov	r3, r24
    67a4:	29 2e       	mov	r2, r25
          mm_remaining = prep.mm_complete; 
    67a6:	fe 88       	ldd	r15, Y+22	; 0x16
    67a8:	ef 88       	ldd	r14, Y+23	; 0x17
    67aa:	b8 8d       	ldd	r27, Y+24	; 0x18
    67ac:	bd af       	std	Y+61, r27	; 0x3d
    67ae:	09 8d       	ldd	r16, Y+25	; 0x19
    67b0:	04 c0       	rjmp	.+8      	; 0x67ba <st_prep_buffer+0x954>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.         
            mm_remaining = mm_var; 
    67b2:	fd 80       	ldd	r15, Y+5	; 0x05
    67b4:	ea 8c       	ldd	r14, Y+26	; 0x1a
    67b6:	6d ae       	std	Y+61, r6	; 0x3d
    67b8:	0f a5       	ldd	r16, Y+47	; 0x2f
            }
          } // End of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete; 
      }
      dt += time_var; // Add computed ramp time to total segment time.
    67ba:	25 2d       	mov	r18, r5
    67bc:	34 2d       	mov	r19, r4
    67be:	43 2d       	mov	r20, r3
    67c0:	52 2d       	mov	r21, r2
    67c2:	c5 01       	movw	r24, r10
    67c4:	b4 01       	movw	r22, r8
    67c6:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    67ca:	4b 01       	movw	r8, r22
    67cc:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    67ce:	9b 01       	movw	r18, r22
    67d0:	ac 01       	movw	r20, r24
    67d2:	67 2d       	mov	r22, r7
    67d4:	79 81       	ldd	r23, Y+1	; 0x01
    67d6:	8d 2d       	mov	r24, r13
    67d8:	9c 2d       	mov	r25, r12
    67da:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    67de:	18 16       	cp	r1, r24
    67e0:	6c f4       	brge	.+26     	; 0x67fc <st_prep_buffer+0x996>
    67e2:	a5 01       	movw	r20, r10
    67e4:	94 01       	movw	r18, r8
    67e6:	67 2d       	mov	r22, r7
    67e8:	79 81       	ldd	r23, Y+1	; 0x01
    67ea:	8d 2d       	mov	r24, r13
    67ec:	9c 2d       	mov	r25, r12
    67ee:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    67f2:	56 2e       	mov	r5, r22
    67f4:	47 2e       	mov	r4, r23
    67f6:	38 2e       	mov	r3, r24
    67f8:	29 2e       	mov	r2, r25
    67fa:	36 c0       	rjmp	.+108    	; 0x6868 <st_prep_buffer+0xa02>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    67fc:	2b a5       	ldd	r18, Y+43	; 0x2b
    67fe:	3c a5       	ldd	r19, Y+44	; 0x2c
    6800:	4d a5       	ldd	r20, Y+45	; 0x2d
    6802:	5e a5       	ldd	r21, Y+46	; 0x2e
    6804:	6f 2d       	mov	r22, r15
    6806:	7e 2d       	mov	r23, r14
    6808:	8d ad       	ldd	r24, Y+61	; 0x3d
    680a:	90 2f       	mov	r25, r16
    680c:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6810:	18 16       	cp	r1, r24
    6812:	a4 f0       	brlt	.+40     	; 0x683c <st_prep_buffer+0x9d6>
    6814:	1d 83       	std	Y+5, r17	; 0x05
    6816:	6a ac       	ldd	r6, Y+58	; 0x3a
    6818:	7b ac       	ldd	r7, Y+59	; 0x3b
    681a:	8e 2d       	mov	r24, r14
    681c:	ef 2c       	mov	r14, r15
    681e:	10 2f       	mov	r17, r16
    6820:	0d ad       	ldd	r16, Y+61	; 0x3d
    6822:	f8 2e       	mov	r15, r24
    6824:	89 85       	ldd	r24, Y+9	; 0x09
    6826:	9d 85       	ldd	r25, Y+13	; 0x0d
    6828:	a9 89       	ldd	r26, Y+17	; 0x11
    682a:	bd 89       	ldd	r27, Y+21	; 0x15
    682c:	f3 01       	movw	r30, r6
    682e:	87 8b       	std	Z+23, r24	; 0x17
    6830:	90 8f       	std	Z+24, r25	; 0x18
    6832:	a1 8f       	std	Z+25, r26	; 0x19
    6834:	b2 8f       	std	Z+26, r27	; 0x1a
    6836:	2d 81       	ldd	r18, Y+5	; 0x05
    6838:	22 8b       	std	Z+18, r18	; 0x12
    683a:	36 c0       	rjmp	.+108    	; 0x68a8 <st_prep_buffer+0xa42>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    683c:	2e e3       	ldi	r18, 0x3E	; 62
    683e:	33 ec       	ldi	r19, 0xC3	; 195
    6840:	4e e2       	ldi	r20, 0x2E	; 46
    6842:	59 e3       	ldi	r21, 0x39	; 57
    6844:	67 2d       	mov	r22, r7
    6846:	79 81       	ldd	r23, Y+1	; 0x01
    6848:	8d 2d       	mov	r24, r13
    684a:	9c 2d       	mov	r25, r12
    684c:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    6850:	76 2e       	mov	r7, r22
    6852:	79 83       	std	Y+1, r23	; 0x01
    6854:	d8 2e       	mov	r13, r24
    6856:	c9 2e       	mov	r12, r25
          time_var = dt_max - dt;
    6858:	a5 01       	movw	r20, r10
    685a:	94 01       	movw	r18, r8
    685c:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    6860:	56 2e       	mov	r5, r22
    6862:	47 2e       	mov	r4, r23
    6864:	38 2e       	mov	r3, r24
    6866:	29 2e       	mov	r2, r25
        } else { 
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    6868:	2e 89       	ldd	r18, Y+22	; 0x16
    686a:	3f 89       	ldd	r19, Y+23	; 0x17
    686c:	48 8d       	ldd	r20, Y+24	; 0x18
    686e:	59 8d       	ldd	r21, Y+25	; 0x19
    6870:	6f 2d       	mov	r22, r15
    6872:	7e 2d       	mov	r23, r14
    6874:	8d ad       	ldd	r24, Y+61	; 0x3d
    6876:	90 2f       	mov	r25, r16
    6878:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    687c:	18 16       	cp	r1, r24
    687e:	0c f4       	brge	.+2      	; 0x6882 <st_prep_buffer+0xa1c>
    6880:	54 ce       	rjmp	.-856    	; 0x652a <st_prep_buffer+0x6c4>
    6882:	1d 83       	std	Y+5, r17	; 0x05
    6884:	6a ac       	ldd	r6, Y+58	; 0x3a
    6886:	7b ac       	ldd	r7, Y+59	; 0x3b
    6888:	8e 2d       	mov	r24, r14
    688a:	ef 2c       	mov	r14, r15
    688c:	10 2f       	mov	r17, r16
    688e:	0d ad       	ldd	r16, Y+61	; 0x3d
    6890:	f8 2e       	mov	r15, r24
    6892:	89 85       	ldd	r24, Y+9	; 0x09
    6894:	9d 85       	ldd	r25, Y+13	; 0x0d
    6896:	a9 89       	ldd	r26, Y+17	; 0x11
    6898:	bd 89       	ldd	r27, Y+21	; 0x15
    689a:	f3 01       	movw	r30, r6
    689c:	87 8b       	std	Z+23, r24	; 0x17
    689e:	90 8f       	std	Z+24, r25	; 0x18
    68a0:	a1 8f       	std	Z+25, r26	; 0x19
    68a2:	b2 8f       	std	Z+26, r27	; 0x1a
    68a4:	2d 81       	ldd	r18, Y+5	; 0x05
    68a6:	22 8b       	std	Z+18, r18	; 0x12
       However, since floats have only 7.2 significant digits, long moves with extremely 
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float steps_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    68a8:	d3 01       	movw	r26, r6
    68aa:	16 96       	adiw	r26, 0x06	; 6
    68ac:	8d 91       	ld	r24, X+
    68ae:	9d 91       	ld	r25, X+
    68b0:	0d 90       	ld	r0, X+
    68b2:	bc 91       	ld	r27, X
    68b4:	a0 2d       	mov	r26, r0
    68b6:	89 8b       	std	Y+17, r24	; 0x11
    68b8:	9a 8b       	std	Y+18, r25	; 0x12
    68ba:	ab 8b       	std	Y+19, r26	; 0x13
    68bc:	bc 8b       	std	Y+20, r27	; 0x14
    68be:	9c 01       	movw	r18, r24
    68c0:	ad 01       	movw	r20, r26
    68c2:	6e 2d       	mov	r22, r14
    68c4:	7f 2d       	mov	r23, r15
    68c6:	80 2f       	mov	r24, r16
    68c8:	91 2f       	mov	r25, r17
    68ca:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    68ce:	69 83       	std	Y+1, r22	; 0x01
    68d0:	7a 83       	std	Y+2, r23	; 0x02
    68d2:	8b 83       	std	Y+3, r24	; 0x03
    68d4:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(steps_remaining); // Round-up current steps remaining
    68d6:	0e 94 94 3a 	call	0x7528	; 0x7528 <ceil>
    68da:	1b 01       	movw	r2, r22
    68dc:	2c 01       	movw	r4, r24
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    68de:	f3 01       	movw	r30, r6
    68e0:	62 81       	ldd	r22, Z+2	; 0x02
    68e2:	73 81       	ldd	r23, Z+3	; 0x03
    68e4:	84 81       	ldd	r24, Z+4	; 0x04
    68e6:	95 81       	ldd	r25, Z+5	; 0x05
    68e8:	0e 94 94 3a 	call	0x7528	; 0x7528 <ceil>
    68ec:	6d 87       	std	Y+13, r22	; 0x0d
    68ee:	7e 87       	std	Y+14, r23	; 0x0e
    68f0:	8f 87       	std	Y+15, r24	; 0x0f
    68f2:	98 8b       	std	Y+16, r25	; 0x10
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    68f4:	a2 01       	movw	r20, r4
    68f6:	91 01       	movw	r18, r2
    68f8:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    68fc:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    6900:	69 87       	std	Y+9, r22	; 0x09
    6902:	7a 87       	std	Y+10, r23	; 0x0a
    6904:	8b 87       	std	Y+11, r24	; 0x0b
    6906:	9c 87       	std	Y+12, r25	; 0x0c
    6908:	e9 a5       	ldd	r30, Y+41	; 0x29
    690a:	fa a5       	ldd	r31, Y+42	; 0x2a
    690c:	ee 0f       	add	r30, r30
    690e:	ff 1f       	adc	r31, r31
    6910:	29 a5       	ldd	r18, Y+41	; 0x29
    6912:	3a a5       	ldd	r19, Y+42	; 0x2a
    6914:	e2 0f       	add	r30, r18
    6916:	f3 1f       	adc	r31, r19
    6918:	ee 0f       	add	r30, r30
    691a:	ff 1f       	adc	r31, r31
    691c:	e0 5f       	subi	r30, 0xF0	; 240
    691e:	fa 4f       	sbci	r31, 0xFA	; 250
    6920:	49 85       	ldd	r20, Y+9	; 0x09
    6922:	5a 85       	ldd	r21, Y+10	; 0x0a
    6924:	51 83       	std	Z+1, r21	; 0x01
    6926:	40 83       	st	Z, r20
    
    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    6928:	ca 01       	movw	r24, r20
    692a:	89 2b       	or	r24, r25
    692c:	31 f5       	brne	.+76     	; 0x697a <st_prep_buffer+0xb14>
      if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) {
    692e:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    6932:	80 77       	andi	r24, 0x70	; 112
    6934:	11 f1       	breq	.+68     	; 0x697a <st_prep_buffer+0xb14>
    6936:	0f 8d       	ldd	r16, Y+31	; 0x1f
    6938:	18 a1       	ldd	r17, Y+32	; 0x20
        // Less than one step to decelerate to zero speed, but already very close. AMASS 
        // requires full steps to execute. So, just bail.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    693a:	ea eb       	ldi	r30, 0xBA	; 186
    693c:	f4 e0       	ldi	r31, 0x04	; 4
    693e:	17 8a       	std	Z+23, r1	; 0x17
    6940:	10 8e       	std	Z+24, r1	; 0x18
    6942:	11 8e       	std	Z+25, r1	; 0x19
    6944:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    6946:	16 86       	std	Z+14, r1	; 0x0e
    6948:	17 86       	std	Z+15, r1	; 0x0f
    694a:	10 8a       	std	Z+16, r1	; 0x10
    694c:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = n_steps_remaining;
    694e:	22 82       	std	Z+2, r2	; 0x02
    6950:	33 82       	std	Z+3, r3	; 0x03
    6952:	44 82       	std	Z+4, r4	; 0x04
    6954:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    6956:	29 89       	ldd	r18, Y+17	; 0x11
    6958:	3a 89       	ldd	r19, Y+18	; 0x12
    695a:	4b 89       	ldd	r20, Y+19	; 0x13
    695c:	5c 89       	ldd	r21, Y+20	; 0x14
    695e:	c2 01       	movw	r24, r4
    6960:	b1 01       	movw	r22, r2
    6962:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    6966:	d8 01       	movw	r26, r16
    6968:	95 96       	adiw	r26, 0x25	; 37
    696a:	6d 93       	st	X+, r22
    696c:	7d 93       	st	X+, r23
    696e:	8d 93       	st	X+, r24
    6970:	9c 93       	st	X, r25
    6972:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize();         
    6974:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <plan_cycle_reinitialize>
        return; // Segment not generated, but current step data still retained.
    6978:	45 c1       	rjmp	.+650    	; 0x6c04 <st_prep_buffer+0xd9e>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are 
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - steps_remaining); // Compute adjusted step rate inverse
    697a:	f3 01       	movw	r30, r6
    697c:	26 85       	ldd	r18, Z+14	; 0x0e
    697e:	37 85       	ldd	r19, Z+15	; 0x0f
    6980:	40 89       	ldd	r20, Z+16	; 0x10
    6982:	51 89       	ldd	r21, Z+17	; 0x11
    6984:	c5 01       	movw	r24, r10
    6986:	b4 01       	movw	r22, r8
    6988:	0e 94 b6 39 	call	0x736c	; 0x736c <__addsf3>
    698c:	4b 01       	movw	r8, r22
    698e:	5c 01       	movw	r10, r24
    6990:	29 81       	ldd	r18, Y+1	; 0x01
    6992:	3a 81       	ldd	r19, Y+2	; 0x02
    6994:	4b 81       	ldd	r20, Y+3	; 0x03
    6996:	5c 81       	ldd	r21, Y+4	; 0x04
    6998:	6d 85       	ldd	r22, Y+13	; 0x0d
    699a:	7e 85       	ldd	r23, Y+14	; 0x0e
    699c:	8f 85       	ldd	r24, Y+15	; 0x0f
    699e:	98 89       	ldd	r25, Y+16	; 0x10
    69a0:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    69a4:	9b 01       	movw	r18, r22
    69a6:	ac 01       	movw	r20, r24
    69a8:	c5 01       	movw	r24, r10
    69aa:	b4 01       	movw	r22, r8
    69ac:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    69b0:	4b 01       	movw	r8, r22
    69b2:	5c 01       	movw	r10, r24
    prep.dt_remainder = (n_steps_remaining - steps_remaining)*inv_rate; // Update segment partial step time
    69b4:	29 81       	ldd	r18, Y+1	; 0x01
    69b6:	3a 81       	ldd	r19, Y+2	; 0x02
    69b8:	4b 81       	ldd	r20, Y+3	; 0x03
    69ba:	5c 81       	ldd	r21, Y+4	; 0x04
    69bc:	c2 01       	movw	r24, r4
    69be:	b1 01       	movw	r22, r2
    69c0:	0e 94 b5 39 	call	0x736a	; 0x736a <__subsf3>
    69c4:	a5 01       	movw	r20, r10
    69c6:	94 01       	movw	r18, r8
    69c8:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    69cc:	d3 01       	movw	r26, r6
    69ce:	1e 96       	adiw	r26, 0x0e	; 14
    69d0:	6d 93       	st	X+, r22
    69d2:	7d 93       	st	X+, r23
    69d4:	8d 93       	st	X+, r24
    69d6:	9c 93       	st	X, r25
    69d8:	51 97       	sbiw	r26, 0x11	; 17

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)    
    69da:	20 ec       	ldi	r18, 0xC0	; 192
    69dc:	31 ee       	ldi	r19, 0xE1	; 225
    69de:	44 e6       	ldi	r20, 0x64	; 100
    69e0:	5e e4       	ldi	r21, 0x4E	; 78
    69e2:	c5 01       	movw	r24, r10
    69e4:	b4 01       	movw	r22, r8
    69e6:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    69ea:	0e 94 94 3a 	call	0x7528	; 0x7528 <ceil>
    69ee:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING        
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    69f2:	60 3d       	cpi	r22, 0xD0	; 208
    69f4:	b7 e0       	ldi	r27, 0x07	; 7
    69f6:	7b 07       	cpc	r23, r27
    69f8:	81 05       	cpc	r24, r1
    69fa:	91 05       	cpc	r25, r1
    69fc:	70 f4       	brcc	.+28     	; 0x6a1a <st_prep_buffer+0xbb4>
    69fe:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a00:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a02:	ee 0f       	add	r30, r30
    6a04:	ff 1f       	adc	r31, r31
    6a06:	29 a5       	ldd	r18, Y+41	; 0x29
    6a08:	3a a5       	ldd	r19, Y+42	; 0x2a
    6a0a:	e2 0f       	add	r30, r18
    6a0c:	f3 1f       	adc	r31, r19
    6a0e:	ee 0f       	add	r30, r30
    6a10:	ff 1f       	adc	r31, r31
    6a12:	e0 5f       	subi	r30, 0xF0	; 240
    6a14:	fa 4f       	sbci	r31, 0xFA	; 250
    6a16:	15 82       	std	Z+5, r1	; 0x05
    6a18:	56 c0       	rjmp	.+172    	; 0x6ac6 <st_prep_buffer+0xc60>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    6a1a:	60 3a       	cpi	r22, 0xA0	; 160
    6a1c:	3f e0       	ldi	r19, 0x0F	; 15
    6a1e:	73 07       	cpc	r23, r19
    6a20:	81 05       	cpc	r24, r1
    6a22:	91 05       	cpc	r25, r1
    6a24:	78 f4       	brcc	.+30     	; 0x6a44 <st_prep_buffer+0xbde>
    6a26:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a28:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a2a:	ee 0f       	add	r30, r30
    6a2c:	ff 1f       	adc	r31, r31
    6a2e:	49 a5       	ldd	r20, Y+41	; 0x29
    6a30:	5a a5       	ldd	r21, Y+42	; 0x2a
    6a32:	e4 0f       	add	r30, r20
    6a34:	f5 1f       	adc	r31, r21
    6a36:	ee 0f       	add	r30, r30
    6a38:	ff 1f       	adc	r31, r31
    6a3a:	e0 5f       	subi	r30, 0xF0	; 240
    6a3c:	fa 4f       	sbci	r31, 0xFA	; 250
    6a3e:	51 e0       	ldi	r21, 0x01	; 1
    6a40:	55 83       	std	Z+5, r21	; 0x05
    6a42:	23 c0       	rjmp	.+70     	; 0x6a8a <st_prep_buffer+0xc24>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    6a44:	60 34       	cpi	r22, 0x40	; 64
    6a46:	af e1       	ldi	r26, 0x1F	; 31
    6a48:	7a 07       	cpc	r23, r26
    6a4a:	81 05       	cpc	r24, r1
    6a4c:	91 05       	cpc	r25, r1
    6a4e:	78 f4       	brcc	.+30     	; 0x6a6e <st_prep_buffer+0xc08>
    6a50:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a52:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a54:	ee 0f       	add	r30, r30
    6a56:	ff 1f       	adc	r31, r31
    6a58:	29 a5       	ldd	r18, Y+41	; 0x29
    6a5a:	3a a5       	ldd	r19, Y+42	; 0x2a
    6a5c:	e2 0f       	add	r30, r18
    6a5e:	f3 1f       	adc	r31, r19
    6a60:	ee 0f       	add	r30, r30
    6a62:	ff 1f       	adc	r31, r31
    6a64:	e0 5f       	subi	r30, 0xF0	; 240
    6a66:	fa 4f       	sbci	r31, 0xFA	; 250
    6a68:	32 e0       	ldi	r19, 0x02	; 2
    6a6a:	35 83       	std	Z+5, r19	; 0x05
    6a6c:	0e c0       	rjmp	.+28     	; 0x6a8a <st_prep_buffer+0xc24>
        else { prep_segment->amass_level = 3; }    
    6a6e:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a70:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a72:	ee 0f       	add	r30, r30
    6a74:	ff 1f       	adc	r31, r31
    6a76:	49 a5       	ldd	r20, Y+41	; 0x29
    6a78:	5a a5       	ldd	r21, Y+42	; 0x2a
    6a7a:	e4 0f       	add	r30, r20
    6a7c:	f5 1f       	adc	r31, r21
    6a7e:	ee 0f       	add	r30, r30
    6a80:	ff 1f       	adc	r31, r31
    6a82:	e0 5f       	subi	r30, 0xF0	; 240
    6a84:	fa 4f       	sbci	r31, 0xFA	; 250
    6a86:	53 e0       	ldi	r21, 0x03	; 3
    6a88:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level; 
    6a8a:	e9 a5       	ldd	r30, Y+41	; 0x29
    6a8c:	fa a5       	ldd	r31, Y+42	; 0x2a
    6a8e:	ee 0f       	add	r30, r30
    6a90:	ff 1f       	adc	r31, r31
    6a92:	a9 a5       	ldd	r26, Y+41	; 0x29
    6a94:	ba a5       	ldd	r27, Y+42	; 0x2a
    6a96:	ea 0f       	add	r30, r26
    6a98:	fb 1f       	adc	r31, r27
    6a9a:	ee 0f       	add	r30, r30
    6a9c:	ff 1f       	adc	r31, r31
    6a9e:	e0 5f       	subi	r30, 0xF0	; 240
    6aa0:	fa 4f       	sbci	r31, 0xFA	; 250
    6aa2:	25 81       	ldd	r18, Z+5	; 0x05
    6aa4:	02 2e       	mov	r0, r18
    6aa6:	04 c0       	rjmp	.+8      	; 0x6ab0 <st_prep_buffer+0xc4a>
    6aa8:	96 95       	lsr	r25
    6aaa:	87 95       	ror	r24
    6aac:	77 95       	ror	r23
    6aae:	67 95       	ror	r22
    6ab0:	0a 94       	dec	r0
    6ab2:	d2 f7       	brpl	.-12     	; 0x6aa8 <st_prep_buffer+0xc42>
        prep_segment->n_step <<= prep_segment->amass_level;
    6ab4:	49 85       	ldd	r20, Y+9	; 0x09
    6ab6:	5a 85       	ldd	r21, Y+10	; 0x0a
    6ab8:	02 c0       	rjmp	.+4      	; 0x6abe <st_prep_buffer+0xc58>
    6aba:	44 0f       	add	r20, r20
    6abc:	55 1f       	adc	r21, r21
    6abe:	2a 95       	dec	r18
    6ac0:	e2 f7       	brpl	.-8      	; 0x6aba <st_prep_buffer+0xc54>
    6ac2:	51 83       	std	Z+1, r21	; 0x01
    6ac4:	40 83       	st	Z, r20
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    6ac6:	61 15       	cp	r22, r1
    6ac8:	71 05       	cpc	r23, r1
    6aca:	51 e0       	ldi	r21, 0x01	; 1
    6acc:	85 07       	cpc	r24, r21
    6ace:	91 05       	cpc	r25, r1
    6ad0:	78 f4       	brcc	.+30     	; 0x6af0 <st_prep_buffer+0xc8a>
    6ad2:	e9 a5       	ldd	r30, Y+41	; 0x29
    6ad4:	fa a5       	ldd	r31, Y+42	; 0x2a
    6ad6:	ee 0f       	add	r30, r30
    6ad8:	ff 1f       	adc	r31, r31
    6ada:	a9 a5       	ldd	r26, Y+41	; 0x29
    6adc:	ba a5       	ldd	r27, Y+42	; 0x2a
    6ade:	ea 0f       	add	r30, r26
    6ae0:	fb 1f       	adc	r31, r27
    6ae2:	ee 0f       	add	r30, r30
    6ae4:	ff 1f       	adc	r31, r31
    6ae6:	e0 5f       	subi	r30, 0xF0	; 240
    6ae8:	fa 4f       	sbci	r31, 0xFA	; 250
    6aea:	74 83       	std	Z+4, r23	; 0x04
    6aec:	63 83       	std	Z+3, r22	; 0x03
    6aee:	10 c0       	rjmp	.+32     	; 0x6b10 <st_prep_buffer+0xcaa>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    6af0:	e9 a5       	ldd	r30, Y+41	; 0x29
    6af2:	fa a5       	ldd	r31, Y+42	; 0x2a
    6af4:	ee 0f       	add	r30, r30
    6af6:	ff 1f       	adc	r31, r31
    6af8:	29 a5       	ldd	r18, Y+41	; 0x29
    6afa:	3a a5       	ldd	r19, Y+42	; 0x2a
    6afc:	e2 0f       	add	r30, r18
    6afe:	f3 1f       	adc	r31, r19
    6b00:	ee 0f       	add	r30, r30
    6b02:	ff 1f       	adc	r31, r31
    6b04:	e0 5f       	subi	r30, 0xF0	; 240
    6b06:	fa 4f       	sbci	r31, 0xFA	; 250
    6b08:	4f ef       	ldi	r20, 0xFF	; 255
    6b0a:	5f ef       	ldi	r21, 0xFF	; 255
    6b0c:	54 83       	std	Z+4, r21	; 0x04
    6b0e:	43 83       	std	Z+3, r20	; 0x03
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices.
    segment_buffer_head = segment_next_head;
    6b10:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <segment_next_head>
    6b14:	80 93 eb 04 	sts	0x04EB, r24	; 0x8004eb <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    6b18:	8f 5f       	subi	r24, 0xFF	; 255
    6b1a:	86 30       	cpi	r24, 0x06	; 6
    6b1c:	19 f0       	breq	.+6      	; 0x6b24 <st_prep_buffer+0xcbe>
    6b1e:	80 93 ea 04 	sts	0x04EA, r24	; 0x8004ea <segment_next_head>
    6b22:	02 c0       	rjmp	.+4      	; 0x6b28 <st_prep_buffer+0xcc2>
    6b24:	10 92 ea 04 	sts	0x04EA, r1	; 0x8004ea <segment_next_head>

    // Setup initial conditions for next segment.
    if (mm_remaining > prep.mm_complete) { 
    6b28:	d3 01       	movw	r26, r6
    6b2a:	53 96       	adiw	r26, 0x13	; 19
    6b2c:	2d 91       	ld	r18, X+
    6b2e:	3d 91       	ld	r19, X+
    6b30:	4d 91       	ld	r20, X+
    6b32:	5c 91       	ld	r21, X
    6b34:	56 97       	sbiw	r26, 0x16	; 22
    6b36:	6e 2d       	mov	r22, r14
    6b38:	7f 2d       	mov	r23, r15
    6b3a:	80 2f       	mov	r24, r16
    6b3c:	91 2f       	mov	r25, r17
    6b3e:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6b42:	18 16       	cp	r1, r24
    6b44:	c4 f4       	brge	.+48     	; 0x6b76 <st_prep_buffer+0xd10>
      // Normal operation. Block incomplete. Distance remaining in block to be executed.
      pl_block->millimeters = mm_remaining;      
    6b46:	e0 91 e5 04 	lds	r30, 0x04E5	; 0x8004e5 <pl_block>
    6b4a:	f0 91 e6 04 	lds	r31, 0x04E6	; 0x8004e6 <pl_block+0x1>
    6b4e:	8e 2d       	mov	r24, r14
    6b50:	9f 2d       	mov	r25, r15
    6b52:	a0 2f       	mov	r26, r16
    6b54:	b1 2f       	mov	r27, r17
    6b56:	85 a3       	std	Z+37, r24	; 0x25
    6b58:	96 a3       	std	Z+38, r25	; 0x26
    6b5a:	a7 a3       	std	Z+39, r26	; 0x27
    6b5c:	b0 a7       	std	Z+40, r27	; 0x28
      prep.steps_remaining = steps_remaining;  
    6b5e:	29 81       	ldd	r18, Y+1	; 0x01
    6b60:	3a 81       	ldd	r19, Y+2	; 0x02
    6b62:	4b 81       	ldd	r20, Y+3	; 0x03
    6b64:	5c 81       	ldd	r21, Y+4	; 0x04
    6b66:	d3 01       	movw	r26, r6
    6b68:	12 96       	adiw	r26, 0x02	; 2
    6b6a:	2d 93       	st	X+, r18
    6b6c:	3d 93       	st	X+, r19
    6b6e:	4d 93       	st	X+, r20
    6b70:	5c 93       	st	X, r21
    6b72:	15 97       	sbiw	r26, 0x05	; 5
    6b74:	41 c0       	rjmp	.+130    	; 0x6bf8 <st_prep_buffer+0xd92>
    } else { 
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    6b76:	20 e0       	ldi	r18, 0x00	; 0
    6b78:	30 e0       	ldi	r19, 0x00	; 0
    6b7a:	a9 01       	movw	r20, r18
    6b7c:	6e 2d       	mov	r22, r14
    6b7e:	7f 2d       	mov	r23, r15
    6b80:	80 2f       	mov	r24, r16
    6b82:	91 2f       	mov	r25, r17
    6b84:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6b88:	18 16       	cp	r1, r24
    6b8a:	3c f5       	brge	.+78     	; 0x6bda <st_prep_buffer+0xd74>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the 
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        prep.current_speed = 0.0; // NOTE: (=0.0) Used to indicate completed segment calcs for hold.
    6b8c:	ea eb       	ldi	r30, 0xBA	; 186
    6b8e:	f4 e0       	ldi	r31, 0x04	; 4
    6b90:	17 8a       	std	Z+23, r1	; 0x17
    6b92:	10 8e       	std	Z+24, r1	; 0x18
    6b94:	11 8e       	std	Z+25, r1	; 0x19
    6b96:	12 8e       	std	Z+26, r1	; 0x1a
        prep.dt_remainder = 0.0;
    6b98:	16 86       	std	Z+14, r1	; 0x0e
    6b9a:	17 86       	std	Z+15, r1	; 0x0f
    6b9c:	10 8a       	std	Z+16, r1	; 0x10
    6b9e:	11 8a       	std	Z+17, r1	; 0x11
        prep.steps_remaining = ceil(steps_remaining);
    6ba0:	22 82       	std	Z+2, r2	; 0x02
    6ba2:	33 82       	std	Z+3, r3	; 0x03
    6ba4:	44 82       	std	Z+4, r4	; 0x04
    6ba6:	55 82       	std	Z+5, r5	; 0x05
        pl_block->millimeters = prep.steps_remaining/prep.step_per_mm; // Update with full steps.
    6ba8:	20 91 e5 04 	lds	r18, 0x04E5	; 0x8004e5 <pl_block>
    6bac:	30 91 e6 04 	lds	r19, 0x04E6	; 0x8004e6 <pl_block+0x1>
    6bb0:	3a 83       	std	Y+2, r19	; 0x02
    6bb2:	29 83       	std	Y+1, r18	; 0x01
    6bb4:	26 81       	ldd	r18, Z+6	; 0x06
    6bb6:	37 81       	ldd	r19, Z+7	; 0x07
    6bb8:	40 85       	ldd	r20, Z+8	; 0x08
    6bba:	51 85       	ldd	r21, Z+9	; 0x09
    6bbc:	c2 01       	movw	r24, r4
    6bbe:	b1 01       	movw	r22, r2
    6bc0:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
    6bc4:	a9 81       	ldd	r26, Y+1	; 0x01
    6bc6:	ba 81       	ldd	r27, Y+2	; 0x02
    6bc8:	95 96       	adiw	r26, 0x25	; 37
    6bca:	6d 93       	st	X+, r22
    6bcc:	7d 93       	st	X+, r23
    6bce:	8d 93       	st	X+, r24
    6bd0:	9c 93       	st	X, r25
    6bd2:	98 97       	sbiw	r26, 0x28	; 40
        plan_cycle_reinitialize(); 
    6bd4:	0e 94 c4 1e 	call	0x3d88	; 0x3d88 <plan_cycle_reinitialize>
        return; // Bail!
    6bd8:	15 c0       	rjmp	.+42     	; 0x6c04 <st_prep_buffer+0xd9e>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    6bda:	10 92 e6 04 	sts	0x04E6, r1	; 0x8004e6 <pl_block+0x1>
    6bde:	10 92 e5 04 	sts	0x04E5, r1	; 0x8004e5 <pl_block>
        plan_discard_current_block();
    6be2:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <plan_discard_current_block>
    6be6:	08 c0       	rjmp	.+16     	; 0x6bf8 <st_prep_buffer+0xd92>
      pl_block = plan_get_current_block(); // Query planner for a queued block
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
                      
      // Check if the segment buffer completed the last planner block. If so, load the Bresenham
      // data for the block. If not, we are still mid-block and the velocity profile was updated. 
      if (prep.flag_partial_block) {
    6be8:	0f 2e       	mov	r0, r31
    6bea:	fa eb       	ldi	r31, 0xBA	; 186
    6bec:	6f 2e       	mov	r6, r31
    6bee:	f4 e0       	ldi	r31, 0x04	; 4
    6bf0:	7f 2e       	mov	r7, r31
    6bf2:	f0 2d       	mov	r31, r0
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise. 
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    6bf4:	b2 e0       	ldi	r27, 0x02	; 2
    6bf6:	b9 af       	std	Y+57, r27	; 0x39
  if (sys.state & (STATE_HOLD|STATE_MOTION_CANCEL|STATE_SAFETY_DOOR)) { 
    // Check if we still need to generate more segments for a motion suspend.
    if (prep.current_speed == 0.0) { return; } // Nothing to do. Bail.
  }
  
  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    6bf8:	90 91 ec 04 	lds	r25, 0x04EC	; 0x8004ec <segment_buffer_tail>
    6bfc:	80 91 ea 04 	lds	r24, 0x04EA	; 0x8004ea <segment_next_head>
    6c00:	98 13       	cpse	r25, r24
    6c02:	60 c9       	rjmp	.-3392   	; 0x5ec4 <st_prep_buffer+0x5e>
        plan_discard_current_block();
      }
    }

  } 
}      
    6c04:	ed 96       	adiw	r28, 0x3d	; 61
    6c06:	0f b6       	in	r0, 0x3f	; 63
    6c08:	f8 94       	cli
    6c0a:	de bf       	out	0x3e, r29	; 62
    6c0c:	0f be       	out	0x3f, r0	; 63
    6c0e:	cd bf       	out	0x3d, r28	; 61
    6c10:	df 91       	pop	r29
    6c12:	cf 91       	pop	r28
    6c14:	1f 91       	pop	r17
    6c16:	0f 91       	pop	r16
    6c18:	ff 90       	pop	r15
    6c1a:	ef 90       	pop	r14
    6c1c:	df 90       	pop	r13
    6c1e:	cf 90       	pop	r12
    6c20:	bf 90       	pop	r11
    6c22:	af 90       	pop	r10
    6c24:	9f 90       	pop	r9
    6c26:	8f 90       	pop	r8
    6c28:	7f 90       	pop	r7
    6c2a:	6f 90       	pop	r6
    6c2c:	5f 90       	pop	r5
    6c2e:	4f 90       	pop	r4
    6c30:	3f 90       	pop	r3
    6c32:	2f 90       	pop	r2
    6c34:	08 95       	ret

00006c36 <system_init>:
#include "grbl.h"


void system_init() 
{
  CONTROL_DDR &= ~(CONTROL_MASK); // Configure as input pins
    6c36:	87 b1       	in	r24, 0x07	; 7
    6c38:	88 7f       	andi	r24, 0xF8	; 248
    6c3a:	87 b9       	out	0x07, r24	; 7
  #ifdef DISABLE_CONTROL_PIN_PULL_UP
    CONTROL_PORT &= ~(CONTROL_MASK); // Normal low operation. Requires external pull-down.
  #else
    CONTROL_PORT |= CONTROL_MASK;   // Enable internal pull-up resistors. Normal high operation.
    6c3c:	88 b1       	in	r24, 0x08	; 8
    6c3e:	87 60       	ori	r24, 0x07	; 7
    6c40:	88 b9       	out	0x08, r24	; 8
  #endif
  CONTROL_PCMSK |= CONTROL_MASK;  // Enable specific pins of the Pin Change Interrupt
    6c42:	ec e6       	ldi	r30, 0x6C	; 108
    6c44:	f0 e0       	ldi	r31, 0x00	; 0
    6c46:	80 81       	ld	r24, Z
    6c48:	87 60       	ori	r24, 0x07	; 7
    6c4a:	80 83       	st	Z, r24
  PCICR |= (1 << CONTROL_INT);   // Enable Pin Change Interrupt
    6c4c:	e8 e6       	ldi	r30, 0x68	; 104
    6c4e:	f0 e0       	ldi	r31, 0x00	; 0
    6c50:	80 81       	ld	r24, Z
    6c52:	82 60       	ori	r24, 0x02	; 2
    6c54:	80 83       	st	Z, r24
    6c56:	08 95       	ret

00006c58 <__vector_4>:
// Pin change interrupt for pin-out commands, i.e. cycle start, feed hold, and reset. Sets
// only the realtime command execute variable to have the main program execute these when 
// its ready. This works exactly like the character-based realtime commands when picked off
// directly from the incoming serial data stream.
ISR(CONTROL_INT_vect) 
{
    6c58:	1f 92       	push	r1
    6c5a:	0f 92       	push	r0
    6c5c:	0f b6       	in	r0, 0x3f	; 63
    6c5e:	0f 92       	push	r0
    6c60:	11 24       	eor	r1, r1
    6c62:	2f 93       	push	r18
    6c64:	3f 93       	push	r19
    6c66:	4f 93       	push	r20
    6c68:	5f 93       	push	r21
    6c6a:	6f 93       	push	r22
    6c6c:	7f 93       	push	r23
    6c6e:	8f 93       	push	r24
    6c70:	9f 93       	push	r25
    6c72:	af 93       	push	r26
    6c74:	bf 93       	push	r27
    6c76:	ef 93       	push	r30
    6c78:	ff 93       	push	r31
  uint8_t pin = (CONTROL_PIN & CONTROL_MASK);
    6c7a:	86 b1       	in	r24, 0x06	; 6
  #ifndef INVERT_ALL_CONTROL_PINS
    pin ^= CONTROL_INVERT_MASK;
    6c7c:	80 95       	com	r24
    6c7e:	87 70       	andi	r24, 0x07	; 7
  #endif
  // Enter only if any CONTROL pin is detected as active.
  if (pin) { 
    6c80:	a9 f0       	breq	.+42     	; 0x6cac <__vector_4+0x54>
    if (bit_istrue(pin,bit(RESET_BIT))) {
    6c82:	80 ff       	sbrs	r24, 0
    6c84:	03 c0       	rjmp	.+6      	; 0x6c8c <__vector_4+0x34>
      mc_reset();
    6c86:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
    6c8a:	10 c0       	rjmp	.+32     	; 0x6cac <__vector_4+0x54>
    } else if (bit_istrue(pin,bit(CYCLE_START_BIT))) {
    6c8c:	98 2f       	mov	r25, r24
    6c8e:	94 70       	andi	r25, 0x04	; 4
    6c90:	31 f0       	breq	.+12     	; 0x6c9e <__vector_4+0x46>
      bit_true(sys_rt_exec_state, EXEC_CYCLE_START);
    6c92:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    6c96:	82 60       	ori	r24, 0x02	; 2
    6c98:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
    6c9c:	07 c0       	rjmp	.+14     	; 0x6cac <__vector_4+0x54>
    #ifndef ENABLE_SAFETY_DOOR_INPUT_PIN
      } else if (bit_istrue(pin,bit(FEED_HOLD_BIT))) {
    6c9e:	81 ff       	sbrs	r24, 1
    6ca0:	05 c0       	rjmp	.+10     	; 0x6cac <__vector_4+0x54>
        bit_true(sys_rt_exec_state, EXEC_FEED_HOLD); 
    6ca2:	80 91 89 05 	lds	r24, 0x0589	; 0x800589 <sys_rt_exec_state>
    6ca6:	88 60       	ori	r24, 0x08	; 8
    6ca8:	80 93 89 05 	sts	0x0589, r24	; 0x800589 <sys_rt_exec_state>
      } else if (bit_istrue(pin,bit(SAFETY_DOOR_BIT))) {
        bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    #endif
    } 
  }
}
    6cac:	ff 91       	pop	r31
    6cae:	ef 91       	pop	r30
    6cb0:	bf 91       	pop	r27
    6cb2:	af 91       	pop	r26
    6cb4:	9f 91       	pop	r25
    6cb6:	8f 91       	pop	r24
    6cb8:	7f 91       	pop	r23
    6cba:	6f 91       	pop	r22
    6cbc:	5f 91       	pop	r21
    6cbe:	4f 91       	pop	r20
    6cc0:	3f 91       	pop	r19
    6cc2:	2f 91       	pop	r18
    6cc4:	0f 90       	pop	r0
    6cc6:	0f be       	out	0x3f, r0	; 63
    6cc8:	0f 90       	pop	r0
    6cca:	1f 90       	pop	r1
    6ccc:	18 95       	reti

00006cce <system_check_safety_door_ajar>:
      return(bit_isfalse(CONTROL_PIN,bit(SAFETY_DOOR_BIT)));
    #endif
  #else
    return(false); // Input pin not enabled, so just return that it's closed.
  #endif
}
    6cce:	80 e0       	ldi	r24, 0x00	; 0
    6cd0:	08 95       	ret

00006cd2 <system_execute_startup>:


// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
    6cd2:	0f 93       	push	r16
    6cd4:	1f 93       	push	r17
    6cd6:	cf 93       	push	r28
    6cd8:	8c 01       	movw	r16, r24
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6cda:	c0 e0       	ldi	r28, 0x00	; 0
    if (!(settings_read_startup_line(n, line))) {
    6cdc:	b8 01       	movw	r22, r16
    6cde:	8c 2f       	mov	r24, r28
    6ce0:	0e 94 e1 29 	call	0x53c2	; 0x53c2 <settings_read_startup_line>
    6ce4:	81 11       	cpse	r24, r1
    6ce6:	04 c0       	rjmp	.+8      	; 0x6cf0 <system_execute_startup+0x1e>
      report_status_message(STATUS_SETTING_READ_FAIL);
    6ce8:	87 e0       	ldi	r24, 0x07	; 7
    6cea:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    6cee:	0c c0       	rjmp	.+24     	; 0x6d08 <system_execute_startup+0x36>
    } else {
      if (line[0] != 0) {
    6cf0:	f8 01       	movw	r30, r16
    6cf2:	80 81       	ld	r24, Z
    6cf4:	88 23       	and	r24, r24
    6cf6:	41 f0       	breq	.+16     	; 0x6d08 <system_execute_startup+0x36>
        printString(line); // Echo startup line to indicate execution.
    6cf8:	c8 01       	movw	r24, r16
    6cfa:	0e 94 cd 1e 	call	0x3d9a	; 0x3d9a <printString>
        report_status_message(gc_execute_line(line));
    6cfe:	c8 01       	movw	r24, r16
    6d00:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    6d04:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>

// Executes user startup script, if stored.
void system_execute_startup(char *line) 
{
  uint8_t n;
  for (n=0; n < N_STARTUP_LINE; n++) {
    6d08:	cf 5f       	subi	r28, 0xFF	; 255
    6d0a:	c2 30       	cpi	r28, 0x02	; 2
    6d0c:	39 f7       	brne	.-50     	; 0x6cdc <system_execute_startup+0xa>
        printString(line); // Echo startup line to indicate execution.
        report_status_message(gc_execute_line(line));
      }
    } 
  }  
}
    6d0e:	cf 91       	pop	r28
    6d10:	1f 91       	pop	r17
    6d12:	0f 91       	pop	r16
    6d14:	08 95       	ret

00006d16 <system_execute_line>:
// next line during a cycle, so for switches like block delete, the switch only effects
// the lines that are processed afterward, not necessarily real-time during a cycle, 
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
    6d16:	8f 92       	push	r8
    6d18:	9f 92       	push	r9
    6d1a:	af 92       	push	r10
    6d1c:	bf 92       	push	r11
    6d1e:	cf 92       	push	r12
    6d20:	df 92       	push	r13
    6d22:	ef 92       	push	r14
    6d24:	ff 92       	push	r15
    6d26:	0f 93       	push	r16
    6d28:	1f 93       	push	r17
    6d2a:	cf 93       	push	r28
    6d2c:	df 93       	push	r29
    6d2e:	cd b7       	in	r28, 0x3d	; 61
    6d30:	de b7       	in	r29, 0x3e	; 62
    6d32:	29 97       	sbiw	r28, 0x09	; 9
    6d34:	0f b6       	in	r0, 0x3f	; 63
    6d36:	f8 94       	cli
    6d38:	de bf       	out	0x3e, r29	; 62
    6d3a:	0f be       	out	0x3f, r0	; 63
    6d3c:	cd bf       	out	0x3d, r28	; 61
    6d3e:	8c 01       	movw	r16, r24
  uint8_t char_counter = 1; 
    6d40:	81 e0       	ldi	r24, 0x01	; 1
    6d42:	89 83       	std	Y+1, r24	; 0x01
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    6d44:	f8 01       	movw	r30, r16
    6d46:	81 81       	ldd	r24, Z+1	; 0x01
    6d48:	83 34       	cpi	r24, 0x43	; 67
    6d4a:	89 f0       	breq	.+34     	; 0x6d6e <system_execute_line+0x58>
    6d4c:	30 f4       	brcc	.+12     	; 0x6d5a <system_execute_line+0x44>
    6d4e:	88 23       	and	r24, r24
    6d50:	51 f0       	breq	.+20     	; 0x6d66 <system_execute_line+0x50>
    6d52:	84 32       	cpi	r24, 0x24	; 36
    6d54:	09 f0       	breq	.+2      	; 0x6d58 <system_execute_line+0x42>
    6d56:	48 c0       	rjmp	.+144    	; 0x6de8 <system_execute_line+0xd2>
    6d58:	0a c0       	rjmp	.+20     	; 0x6d6e <system_execute_line+0x58>
    6d5a:	87 34       	cpi	r24, 0x47	; 71
    6d5c:	41 f0       	breq	.+16     	; 0x6d6e <system_execute_line+0x58>
    6d5e:	88 35       	cpi	r24, 0x58	; 88
    6d60:	09 f0       	breq	.+2      	; 0x6d64 <system_execute_line+0x4e>
    6d62:	42 c0       	rjmp	.+132    	; 0x6de8 <system_execute_line+0xd2>
    6d64:	04 c0       	rjmp	.+8      	; 0x6d6e <system_execute_line+0x58>
    case 0 : report_grbl_help(); break;
    6d66:	0e 94 34 23 	call	0x4668	; 0x4668 <report_grbl_help>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6d6a:	f1 2c       	mov	r15, r1
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    6d6c:	b0 c1       	rjmp	.+864    	; 0x70ce <system_execute_line+0x3b8>
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6d6e:	f8 01       	movw	r30, r16
    6d70:	92 81       	ldd	r25, Z+2	; 0x02
    6d72:	91 11       	cpse	r25, r1
    6d74:	53 c1       	rjmp	.+678    	; 0x701c <system_execute_line+0x306>
      switch( line[char_counter] ) {
    6d76:	83 34       	cpi	r24, 0x43	; 67
    6d78:	b1 f0       	breq	.+44     	; 0x6da6 <system_execute_line+0x90>
    6d7a:	18 f4       	brcc	.+6      	; 0x6d82 <system_execute_line+0x6c>
    6d7c:	84 32       	cpi	r24, 0x24	; 36
    6d7e:	31 f0       	breq	.+12     	; 0x6d8c <system_execute_line+0x76>
    6d80:	52 c1       	rjmp	.+676    	; 0x7026 <system_execute_line+0x310>
    6d82:	87 34       	cpi	r24, 0x47	; 71
    6d84:	61 f0       	breq	.+24     	; 0x6d9e <system_execute_line+0x88>
    6d86:	88 35       	cpi	r24, 0x58	; 88
    6d88:	19 f1       	breq	.+70     	; 0x6dd0 <system_execute_line+0xba>
    6d8a:	4d c1       	rjmp	.+666    	; 0x7026 <system_execute_line+0x310>
    6d8c:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    6d90:	88 71       	andi	r24, 0x18	; 24
    6d92:	f8 2e       	mov	r15, r24
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    6d94:	09 f0       	breq	.+2      	; 0x6d98 <system_execute_line+0x82>
    6d96:	49 c1       	rjmp	.+658    	; 0x702a <system_execute_line+0x314>
          else { report_grbl_settings(); }
    6d98:	0e 94 39 23 	call	0x4672	; 0x4672 <report_grbl_settings>
          break;
    6d9c:	98 c1       	rjmp	.+816    	; 0x70ce <system_execute_line+0x3b8>
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
    6d9e:	0e 94 0e 26 	call	0x4c1c	; 0x4c1c <report_gcode_modes>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6da2:	f1 2c       	mov	r15, r1
          else { report_grbl_settings(); }
          break;
        case 'G' : // Prints gcode parser state
          // TODO: Move this to realtime commands for GUIs to request this data during suspend-state.
          report_gcode_modes();
          break;   
    6da4:	94 c1       	rjmp	.+808    	; 0x70ce <system_execute_line+0x3b8>
        case 'C' : // Set check g-code mode [IDLE/CHECK]
          // Perform reset when toggling off. Check g-code mode should only work if Grbl
          // is idle and ready, regardless of alarm locks. This is mainly to keep things
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
    6da6:	f0 90 05 06 	lds	r15, 0x0605	; 0x800605 <sys+0x1>
    6daa:	f2 e0       	ldi	r31, 0x02	; 2
    6dac:	ff 12       	cpse	r15, r31
    6dae:	07 c0       	rjmp	.+14     	; 0x6dbe <system_execute_line+0xa8>
            mc_reset(); 
    6db0:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
            report_feedback_message(MESSAGE_DISABLED);
    6db4:	85 e0       	ldi	r24, 0x05	; 5
    6db6:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6dba:	f1 2c       	mov	r15, r1
    6dbc:	88 c1       	rjmp	.+784    	; 0x70ce <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    6dbe:	f1 10       	cpse	r15, r1
    6dc0:	38 c1       	rjmp	.+624    	; 0x7032 <system_execute_line+0x31c>
            sys.state = STATE_CHECK_MODE;
    6dc2:	82 e0       	ldi	r24, 0x02	; 2
    6dc4:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <sys+0x1>
            report_feedback_message(MESSAGE_ENABLED);
    6dc8:	84 e0       	ldi	r24, 0x04	; 4
    6dca:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
    6dce:	7f c1       	rjmp	.+766    	; 0x70ce <system_execute_line+0x3b8>
          }
          break; 
        case 'X' : // Disable alarm lock [ALARM]
          if (sys.state == STATE_ALARM) { 
    6dd0:	80 91 05 06 	lds	r24, 0x0605	; 0x800605 <sys+0x1>
    6dd4:	81 30       	cpi	r24, 0x01	; 1
    6dd6:	09 f0       	breq	.+2      	; 0x6dda <system_execute_line+0xc4>
    6dd8:	30 c1       	rjmp	.+608    	; 0x703a <system_execute_line+0x324>
            report_feedback_message(MESSAGE_ALARM_UNLOCK);
    6dda:	83 e0       	ldi	r24, 0x03	; 3
    6ddc:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
            sys.state = STATE_IDLE;
    6de0:	10 92 05 06 	sts	0x0605, r1	; 0x800605 <sys+0x1>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6de4:	f1 2c       	mov	r15, r1
    6de6:	73 c1       	rjmp	.+742    	; 0x70ce <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    6de8:	90 91 05 06 	lds	r25, 0x0605	; 0x800605 <sys+0x1>
    6dec:	92 30       	cpi	r25, 0x02	; 2
    6dee:	08 f0       	brcs	.+2      	; 0x6df2 <system_execute_line+0xdc>
    6df0:	26 c1       	rjmp	.+588    	; 0x703e <system_execute_line+0x328>
      switch( line[char_counter] ) {
    6df2:	89 34       	cpi	r24, 0x49	; 73
    6df4:	91 f1       	breq	.+100    	; 0x6e5a <system_execute_line+0x144>
    6df6:	28 f4       	brcc	.+10     	; 0x6e02 <system_execute_line+0xec>
    6df8:	83 32       	cpi	r24, 0x23	; 35
    6dfa:	51 f0       	breq	.+20     	; 0x6e10 <system_execute_line+0xfa>
    6dfc:	88 34       	cpi	r24, 0x48	; 72
    6dfe:	91 f0       	breq	.+36     	; 0x6e24 <system_execute_line+0x10e>
    6e00:	9c c0       	rjmp	.+312    	; 0x6f3a <system_execute_line+0x224>
    6e02:	8e 34       	cpi	r24, 0x4E	; 78
    6e04:	09 f4       	brne	.+2      	; 0x6e08 <system_execute_line+0xf2>
    6e06:	79 c0       	rjmp	.+242    	; 0x6efa <system_execute_line+0x1e4>
    6e08:	82 35       	cpi	r24, 0x52	; 82
    6e0a:	09 f4       	brne	.+2      	; 0x6e0e <system_execute_line+0xf8>
    6e0c:	49 c0       	rjmp	.+146    	; 0x6ea0 <system_execute_line+0x18a>
    6e0e:	95 c0       	rjmp	.+298    	; 0x6f3a <system_execute_line+0x224>
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    6e10:	82 e0       	ldi	r24, 0x02	; 2
    6e12:	89 83       	std	Y+1, r24	; 0x01
    6e14:	f8 01       	movw	r30, r16
    6e16:	82 81       	ldd	r24, Z+2	; 0x02
    6e18:	81 11       	cpse	r24, r1
    6e1a:	15 c1       	rjmp	.+554    	; 0x7046 <system_execute_line+0x330>
          else { report_ngc_parameters(); }
    6e1c:	0e 94 78 25 	call	0x4af0	; 0x4af0 <report_ngc_parameters>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e20:	f1 2c       	mov	r15, r1
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
          else { report_ngc_parameters(); }
          break;          
    6e22:	55 c1       	rjmp	.+682    	; 0x70ce <system_execute_line+0x3b8>
        case 'H' : // Perform homing cycle [IDLE/ALARM]
          if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { 
    6e24:	80 91 20 07 	lds	r24, 0x0720	; 0x800720 <settings+0x3d>
    6e28:	84 ff       	sbrs	r24, 4
    6e2a:	12 c1       	rjmp	.+548    	; 0x7050 <system_execute_line+0x33a>
            sys.state = STATE_HOMING; // Set system state variable
    6e2c:	0f 2e       	mov	r0, r31
    6e2e:	f4 e0       	ldi	r31, 0x04	; 4
    6e30:	ef 2e       	mov	r14, r31
    6e32:	f6 e0       	ldi	r31, 0x06	; 6
    6e34:	ff 2e       	mov	r15, r31
    6e36:	f0 2d       	mov	r31, r0
    6e38:	84 e0       	ldi	r24, 0x04	; 4
    6e3a:	f7 01       	movw	r30, r14
    6e3c:	81 83       	std	Z+1, r24	; 0x01
              bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
              protocol_execute_realtime(); // Enter safety door mode.
            }
            
            
            mc_homing_cycle(); 
    6e3e:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <mc_homing_cycle>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
    6e42:	f7 01       	movw	r30, r14
    6e44:	f0 80       	ld	r15, Z
    6e46:	f1 10       	cpse	r15, r1
    6e48:	08 c1       	rjmp	.+528    	; 0x705a <system_execute_line+0x344>
              sys.state = STATE_IDLE; // Set to IDLE when complete.
    6e4a:	10 92 05 06 	sts	0x0605, r1	; 0x800605 <sys+0x1>
              st_go_idle(); // Set steppers to the settings idle state before returning.
    6e4e:	0e 94 64 2c 	call	0x58c8	; 0x58c8 <st_go_idle>
              system_execute_startup(line); 
    6e52:	c8 01       	movw	r24, r16
    6e54:	0e 94 69 36 	call	0x6cd2	; 0x6cd2 <system_execute_startup>
    6e58:	3a c1       	rjmp	.+628    	; 0x70ce <system_execute_line+0x3b8>
            }
          } else { return(STATUS_SETTING_DISABLED); }
          break;
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
    6e5a:	82 e0       	ldi	r24, 0x02	; 2
    6e5c:	89 83       	std	Y+1, r24	; 0x01
    6e5e:	f8 01       	movw	r30, r16
    6e60:	82 81       	ldd	r24, Z+2	; 0x02
    6e62:	81 11       	cpse	r24, r1
    6e64:	08 c0       	rjmp	.+16     	; 0x6e76 <system_execute_line+0x160>
            settings_read_build_info(line);
    6e66:	c8 01       	movw	r24, r16
    6e68:	0e 94 fe 29 	call	0x53fc	; 0x53fc <settings_read_build_info>
            report_build_info(line);
    6e6c:	c8 01       	movw	r24, r16
    6e6e:	0e 94 06 27 	call	0x4e0c	; 0x4e0c <report_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e72:	f1 2c       	mov	r15, r1
    6e74:	2c c1       	rjmp	.+600    	; 0x70ce <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6e76:	8d 33       	cpi	r24, 0x3D	; 61
    6e78:	09 f0       	breq	.+2      	; 0x6e7c <system_execute_line+0x166>
    6e7a:	f1 c0       	rjmp	.+482    	; 0x705e <system_execute_line+0x348>
    6e7c:	83 e0       	ldi	r24, 0x03	; 3
            helper_var = char_counter; // Set helper variable as counter to start of user info line.
            do {
              line[char_counter-helper_var] = line[char_counter];
    6e7e:	f8 01       	movw	r30, r16
    6e80:	e8 0f       	add	r30, r24
    6e82:	f1 1d       	adc	r31, r1
    6e84:	90 81       	ld	r25, Z
    6e86:	df 01       	movw	r26, r30
    6e88:	13 97       	sbiw	r26, 0x03	; 3
    6e8a:	9c 93       	st	X, r25
            } while (line[char_counter++] != 0);
    6e8c:	8f 5f       	subi	r24, 0xFF	; 255
    6e8e:	90 81       	ld	r25, Z
    6e90:	91 11       	cpse	r25, r1
    6e92:	f5 cf       	rjmp	.-22     	; 0x6e7e <system_execute_line+0x168>
    6e94:	89 83       	std	Y+1, r24	; 0x01
            settings_store_build_info(line);
    6e96:	c8 01       	movw	r24, r16
    6e98:	0e 94 fd 28 	call	0x51fa	; 0x51fa <settings_store_build_info>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6e9c:	f1 2c       	mov	r15, r1
    6e9e:	17 c1       	rjmp	.+558    	; 0x70ce <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    6ea0:	f8 01       	movw	r30, r16
    6ea2:	82 81       	ldd	r24, Z+2	; 0x02
    6ea4:	83 35       	cpi	r24, 0x53	; 83
    6ea6:	09 f0       	breq	.+2      	; 0x6eaa <system_execute_line+0x194>
    6ea8:	df c0       	rjmp	.+446    	; 0x7068 <system_execute_line+0x352>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    6eaa:	83 81       	ldd	r24, Z+3	; 0x03
    6eac:	84 35       	cpi	r24, 0x54	; 84
    6eae:	09 f0       	breq	.+2      	; 0x6eb2 <system_execute_line+0x19c>
    6eb0:	e0 c0       	rjmp	.+448    	; 0x7072 <system_execute_line+0x35c>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    6eb2:	84 81       	ldd	r24, Z+4	; 0x04
    6eb4:	8d 33       	cpi	r24, 0x3D	; 61
    6eb6:	09 f0       	breq	.+2      	; 0x6eba <system_execute_line+0x1a4>
    6eb8:	e1 c0       	rjmp	.+450    	; 0x707c <system_execute_line+0x366>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    6eba:	86 81       	ldd	r24, Z+6	; 0x06
    6ebc:	81 11       	cpse	r24, r1
    6ebe:	e3 c0       	rjmp	.+454    	; 0x7086 <system_execute_line+0x370>
          switch (line[++char_counter]) {
    6ec0:	85 e0       	ldi	r24, 0x05	; 5
    6ec2:	89 83       	std	Y+1, r24	; 0x01
    6ec4:	85 81       	ldd	r24, Z+5	; 0x05
    6ec6:	84 32       	cpi	r24, 0x24	; 36
    6ec8:	31 f0       	breq	.+12     	; 0x6ed6 <system_execute_line+0x1c0>
    6eca:	8a 32       	cpi	r24, 0x2A	; 42
    6ecc:	61 f0       	breq	.+24     	; 0x6ee6 <system_execute_line+0x1d0>
    6ece:	83 32       	cpi	r24, 0x23	; 35
    6ed0:	09 f0       	breq	.+2      	; 0x6ed4 <system_execute_line+0x1be>
    6ed2:	de c0       	rjmp	.+444    	; 0x7090 <system_execute_line+0x37a>
    6ed4:	04 c0       	rjmp	.+8      	; 0x6ede <system_execute_line+0x1c8>
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
    6ed6:	81 e0       	ldi	r24, 0x01	; 1
    6ed8:	0e 94 1d 29 	call	0x523a	; 0x523a <settings_restore>
    6edc:	07 c0       	rjmp	.+14     	; 0x6eec <system_execute_line+0x1d6>
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
    6ede:	82 e0       	ldi	r24, 0x02	; 2
    6ee0:	0e 94 1d 29 	call	0x523a	; 0x523a <settings_restore>
    6ee4:	03 c0       	rjmp	.+6      	; 0x6eec <system_execute_line+0x1d6>
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
    6ee6:	8f ef       	ldi	r24, 0xFF	; 255
    6ee8:	0e 94 1d 29 	call	0x523a	; 0x523a <settings_restore>
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
    6eec:	88 e0       	ldi	r24, 0x08	; 8
    6eee:	0e 94 f1 22 	call	0x45e2	; 0x45e2 <report_feedback_message>
          mc_reset(); // Force reset to ensure settings are initialized correctly.
    6ef2:	0e 94 47 18 	call	0x308e	; 0x308e <mc_reset>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6ef6:	f1 2c       	mov	r15, r1
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
          }
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
    6ef8:	ea c0       	rjmp	.+468    	; 0x70ce <system_execute_line+0x3b8>
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
    6efa:	82 e0       	ldi	r24, 0x02	; 2
    6efc:	89 83       	std	Y+1, r24	; 0x01
    6efe:	f8 01       	movw	r30, r16
    6f00:	82 81       	ldd	r24, Z+2	; 0x02
    6f02:	81 11       	cpse	r24, r1
    6f04:	15 c0       	rjmp	.+42     	; 0x6f30 <system_execute_line+0x21a>
    6f06:	f1 2c       	mov	r15, r1
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
              if (!(settings_read_startup_line(helper_var, line))) {
    6f08:	b8 01       	movw	r22, r16
    6f0a:	8f 2d       	mov	r24, r15
    6f0c:	0e 94 e1 29 	call	0x53c2	; 0x53c2 <settings_read_startup_line>
    6f10:	81 11       	cpse	r24, r1
    6f12:	04 c0       	rjmp	.+8      	; 0x6f1c <system_execute_line+0x206>
                report_status_message(STATUS_SETTING_READ_FAIL);
    6f14:	87 e0       	ldi	r24, 0x07	; 7
    6f16:	0e 94 50 22 	call	0x44a0	; 0x44a0 <report_status_message>
    6f1a:	04 c0       	rjmp	.+8      	; 0x6f24 <system_execute_line+0x20e>
              } else {
                report_startup_line(helper_var,line);
    6f1c:	b8 01       	movw	r22, r16
    6f1e:	8f 2d       	mov	r24, r15
    6f20:	0e 94 eb 26 	call	0x4dd6	; 0x4dd6 <report_startup_line>
          report_feedback_message(MESSAGE_RESTORE_DEFAULTS);
          mc_reset(); // Force reset to ensure settings are initialized correctly.
          break;
        case 'N' : // Startup lines. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { // Print startup lines
            for (helper_var=0; helper_var < N_STARTUP_LINE; helper_var++) {
    6f24:	f3 94       	inc	r15
    6f26:	f2 e0       	ldi	r31, 0x02	; 2
    6f28:	ff 12       	cpse	r15, r31
    6f2a:	ee cf       	rjmp	.-36     	; 0x6f08 <system_execute_line+0x1f2>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    6f2c:	f1 2c       	mov	r15, r1
    6f2e:	cf c0       	rjmp	.+414    	; 0x70ce <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    6f30:	91 11       	cpse	r25, r1
    6f32:	b3 c0       	rjmp	.+358    	; 0x709a <system_execute_line+0x384>
            helper_var = true;  // Set helper_var to flag storing method. 
    6f34:	ff 24       	eor	r15, r15
    6f36:	f3 94       	inc	r15
    6f38:	01 c0       	rjmp	.+2      	; 0x6f3c <system_execute_line+0x226>
// since there are motions already stored in the buffer. However, this 'lag' should not
// be an issue, since these commands are not typically used during a cycle.
uint8_t system_execute_line(char *line) 
{   
  uint8_t char_counter = 1; 
  uint8_t helper_var = 0; // Helper variable
    6f3a:	f1 2c       	mov	r15, r1
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6f3c:	ae 01       	movw	r20, r28
    6f3e:	4e 5f       	subi	r20, 0xFE	; 254
    6f40:	5f 4f       	sbci	r21, 0xFF	; 255
    6f42:	be 01       	movw	r22, r28
    6f44:	6f 5f       	subi	r22, 0xFF	; 255
    6f46:	7f 4f       	sbci	r23, 0xFF	; 255
    6f48:	c8 01       	movw	r24, r16
    6f4a:	0e 94 76 18 	call	0x30ec	; 0x30ec <read_float>
    6f4e:	88 23       	and	r24, r24
    6f50:	09 f4       	brne	.+2      	; 0x6f54 <system_execute_line+0x23e>
    6f52:	a7 c0       	rjmp	.+334    	; 0x70a2 <system_execute_line+0x38c>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    6f54:	89 81       	ldd	r24, Y+1	; 0x01
    6f56:	41 e0       	ldi	r20, 0x01	; 1
    6f58:	48 0f       	add	r20, r24
    6f5a:	49 83       	std	Y+1, r20	; 0x01
    6f5c:	f8 01       	movw	r30, r16
    6f5e:	e8 0f       	add	r30, r24
    6f60:	f1 1d       	adc	r31, r1
    6f62:	80 81       	ld	r24, Z
    6f64:	8d 33       	cpi	r24, 0x3D	; 61
    6f66:	09 f0       	breq	.+2      	; 0x6f6a <system_execute_line+0x254>
    6f68:	a0 c0       	rjmp	.+320    	; 0x70aa <system_execute_line+0x394>
          if (helper_var) { // Store startup line
    6f6a:	ff 20       	and	r15, r15
    6f6c:	31 f1       	breq	.+76     	; 0x6fba <system_execute_line+0x2a4>
    6f6e:	24 2f       	mov	r18, r20
            // Prepare sending gcode block to gcode parser by shifting all characters
            helper_var = char_counter; // Set helper variable as counter to start of gcode block
            do {
              line[char_counter-helper_var] = line[char_counter];
    6f70:	50 e0       	ldi	r21, 0x00	; 0
    6f72:	82 2f       	mov	r24, r18
    6f74:	90 e0       	ldi	r25, 0x00	; 0
    6f76:	d8 01       	movw	r26, r16
    6f78:	a8 0f       	add	r26, r24
    6f7a:	b9 1f       	adc	r27, r25
    6f7c:	3c 91       	ld	r19, X
    6f7e:	84 1b       	sub	r24, r20
    6f80:	95 0b       	sbc	r25, r21
    6f82:	f8 01       	movw	r30, r16
    6f84:	e8 0f       	add	r30, r24
    6f86:	f9 1f       	adc	r31, r25
    6f88:	30 83       	st	Z, r19
            } while (line[char_counter++] != 0);
    6f8a:	2f 5f       	subi	r18, 0xFF	; 255
    6f8c:	8c 91       	ld	r24, X
    6f8e:	81 11       	cpse	r24, r1
    6f90:	f0 cf       	rjmp	.-32     	; 0x6f72 <system_execute_line+0x25c>
    6f92:	29 83       	std	Y+1, r18	; 0x01
            // Execute gcode block to ensure block is valid.
            helper_var = gc_execute_line(line); // Set helper_var to returned status code.
    6f94:	c8 01       	movw	r24, r16
    6f96:	0e 94 16 06 	call	0xc2c	; 0xc2c <gc_execute_line>
    6f9a:	f8 2e       	mov	r15, r24
            if (helper_var) { return(helper_var); }
    6f9c:	81 11       	cpse	r24, r1
    6f9e:	97 c0       	rjmp	.+302    	; 0x70ce <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
    6fa0:	6a 81       	ldd	r22, Y+2	; 0x02
    6fa2:	7b 81       	ldd	r23, Y+3	; 0x03
    6fa4:	8c 81       	ldd	r24, Y+4	; 0x04
    6fa6:	9d 81       	ldd	r25, Y+5	; 0x05
    6fa8:	0e 94 f0 3d 	call	0x7be0	; 0x7be0 <trunc>
              settings_store_startup_line(helper_var,line);
    6fac:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    6fb0:	86 2f       	mov	r24, r22
    6fb2:	b8 01       	movw	r22, r16
    6fb4:	0e 94 f3 28 	call	0x51e6	; 0x51e6 <settings_store_startup_line>
    6fb8:	8a c0       	rjmp	.+276    	; 0x70ce <system_execute_line+0x3b8>
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    6fba:	ae 01       	movw	r20, r28
    6fbc:	4a 5f       	subi	r20, 0xFA	; 250
    6fbe:	5f 4f       	sbci	r21, 0xFF	; 255
    6fc0:	be 01       	movw	r22, r28
    6fc2:	6f 5f       	subi	r22, 0xFF	; 255
    6fc4:	7f 4f       	sbci	r23, 0xFF	; 255
    6fc6:	c8 01       	movw	r24, r16
    6fc8:	0e 94 76 18 	call	0x30ec	; 0x30ec <read_float>
    6fcc:	88 23       	and	r24, r24
    6fce:	09 f4       	brne	.+2      	; 0x6fd2 <system_execute_line+0x2bc>
    6fd0:	71 c0       	rjmp	.+226    	; 0x70b4 <system_execute_line+0x39e>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    6fd2:	89 81       	ldd	r24, Y+1	; 0x01
    6fd4:	f8 01       	movw	r30, r16
    6fd6:	e8 0f       	add	r30, r24
    6fd8:	f1 1d       	adc	r31, r1
    6fda:	80 81       	ld	r24, Z
    6fdc:	81 11       	cpse	r24, r1
    6fde:	6e c0       	rjmp	.+220    	; 0x70bc <system_execute_line+0x3a6>
    6fe0:	ca 80       	ldd	r12, Y+2	; 0x02
    6fe2:	db 80       	ldd	r13, Y+3	; 0x03
    6fe4:	ec 80       	ldd	r14, Y+4	; 0x04
    6fe6:	fd 80       	ldd	r15, Y+5	; 0x05
    6fe8:	20 e0       	ldi	r18, 0x00	; 0
    6fea:	30 e0       	ldi	r19, 0x00	; 0
    6fec:	4f e7       	ldi	r20, 0x7F	; 127
    6fee:	53 e4       	ldi	r21, 0x43	; 67
    6ff0:	c7 01       	movw	r24, r14
    6ff2:	b6 01       	movw	r22, r12
    6ff4:	0e 94 cd 3c 	call	0x799a	; 0x799a <__gesf2>
    6ff8:	18 16       	cp	r1, r24
    6ffa:	0c f4       	brge	.+2      	; 0x6ffe <system_execute_line+0x2e8>
    6ffc:	64 c0       	rjmp	.+200    	; 0x70c6 <system_execute_line+0x3b0>
            return(settings_store_global_setting((uint8_t)parameter, value));
    6ffe:	8e 80       	ldd	r8, Y+6	; 0x06
    7000:	9f 80       	ldd	r9, Y+7	; 0x07
    7002:	a8 84       	ldd	r10, Y+8	; 0x08
    7004:	b9 84       	ldd	r11, Y+9	; 0x09
    7006:	c7 01       	movw	r24, r14
    7008:	b6 01       	movw	r22, r12
    700a:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    700e:	86 2f       	mov	r24, r22
    7010:	b5 01       	movw	r22, r10
    7012:	a4 01       	movw	r20, r8
    7014:	0e 94 4a 2a 	call	0x5494	; 0x5494 <settings_store_global_setting>
    7018:	f8 2e       	mov	r15, r24
    701a:	59 c0       	rjmp	.+178    	; 0x70ce <system_execute_line+0x3b8>
  uint8_t helper_var = 0; // Helper variable
  float parameter, value;
  switch( line[char_counter] ) {
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    701c:	0f 2e       	mov	r0, r31
    701e:	f3 e0       	ldi	r31, 0x03	; 3
    7020:	ff 2e       	mov	r15, r31
    7022:	f0 2d       	mov	r31, r0
    7024:	54 c0       	rjmp	.+168    	; 0x70ce <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    7026:	f1 2c       	mov	r15, r1
    7028:	52 c0       	rjmp	.+164    	; 0x70ce <system_execute_line+0x3b8>
    case 0 : report_grbl_help(); break;
    case '$': case 'G': case 'C': case 'X':
      if ( line[(char_counter+1)] != 0 ) { return(STATUS_INVALID_STATEMENT); }
      switch( line[char_counter] ) {
        case '$' : // Prints Grbl settings
          if ( sys.state & (STATE_CYCLE | STATE_HOLD) ) { return(STATUS_IDLE_ERROR); } // Block during cycle. Takes too long to print.
    702a:	68 94       	set
    702c:	ff 24       	eor	r15, r15
    702e:	f3 f8       	bld	r15, 3
    7030:	4e c0       	rjmp	.+156    	; 0x70ce <system_execute_line+0x3b8>
          // simple and consistent.
          if ( sys.state == STATE_CHECK_MODE ) { 
            mc_reset(); 
            report_feedback_message(MESSAGE_DISABLED);
          } else {
            if (sys.state) { return(STATUS_IDLE_ERROR); } // Requires no alarm mode.
    7032:	68 94       	set
    7034:	ff 24       	eor	r15, r15
    7036:	f3 f8       	bld	r15, 3
    7038:	4a c0       	rjmp	.+148    	; 0x70ce <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    703a:	f1 2c       	mov	r15, r1
    703c:	48 c0       	rjmp	.+144    	; 0x70ce <system_execute_line+0x3b8>
//       break;
      }
      break;
    default : 
      // Block any system command that requires the state as IDLE/ALARM. (i.e. EEPROM, homing)
      if ( !(sys.state == STATE_IDLE || sys.state == STATE_ALARM) ) { return(STATUS_IDLE_ERROR); }
    703e:	68 94       	set
    7040:	ff 24       	eor	r15, r15
    7042:	f3 f8       	bld	r15, 3
    7044:	44 c0       	rjmp	.+136    	; 0x70ce <system_execute_line+0x3b8>
      switch( line[char_counter] ) {
        case '#' : // Print Grbl NGC parameters
          if ( line[++char_counter] != 0 ) { return(STATUS_INVALID_STATEMENT); }
    7046:	0f 2e       	mov	r0, r31
    7048:	f3 e0       	ldi	r31, 0x03	; 3
    704a:	ff 2e       	mov	r15, r31
    704c:	f0 2d       	mov	r31, r0
    704e:	3f c0       	rjmp	.+126    	; 0x70ce <system_execute_line+0x3b8>
            if (!sys.abort) {  // Execute startup scripts after successful homing.
              sys.state = STATE_IDLE; // Set to IDLE when complete.
              st_go_idle(); // Set steppers to the settings idle state before returning.
              system_execute_startup(line); 
            }
          } else { return(STATUS_SETTING_DISABLED); }
    7050:	0f 2e       	mov	r0, r31
    7052:	f5 e0       	ldi	r31, 0x05	; 5
    7054:	ff 2e       	mov	r15, r31
    7056:	f0 2d       	mov	r31, r0
    7058:	3a c0       	rjmp	.+116    	; 0x70ce <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
    705a:	f1 2c       	mov	r15, r1
    705c:	38 c0       	rjmp	.+112    	; 0x70ce <system_execute_line+0x3b8>
        case 'I' : // Print or store build info. [IDLE/ALARM]
          if ( line[++char_counter] == 0 ) { 
            settings_read_build_info(line);
            report_build_info(line);
          } else { // Store startup line [IDLE/ALARM]
            if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    705e:	0f 2e       	mov	r0, r31
    7060:	f3 e0       	ldi	r31, 0x03	; 3
    7062:	ff 2e       	mov	r15, r31
    7064:	f0 2d       	mov	r31, r0
    7066:	33 c0       	rjmp	.+102    	; 0x70ce <system_execute_line+0x3b8>
            } while (line[char_counter++] != 0);
            settings_store_build_info(line);
          }
          break; 
        case 'R' : // Restore defaults [IDLE/ALARM]
          if (line[++char_counter] != 'S') { return(STATUS_INVALID_STATEMENT); }
    7068:	0f 2e       	mov	r0, r31
    706a:	f3 e0       	ldi	r31, 0x03	; 3
    706c:	ff 2e       	mov	r15, r31
    706e:	f0 2d       	mov	r31, r0
    7070:	2e c0       	rjmp	.+92     	; 0x70ce <system_execute_line+0x3b8>
          if (line[++char_counter] != 'T') { return(STATUS_INVALID_STATEMENT); }
    7072:	0f 2e       	mov	r0, r31
    7074:	f3 e0       	ldi	r31, 0x03	; 3
    7076:	ff 2e       	mov	r15, r31
    7078:	f0 2d       	mov	r31, r0
    707a:	29 c0       	rjmp	.+82     	; 0x70ce <system_execute_line+0x3b8>
          if (line[++char_counter] != '=') { return(STATUS_INVALID_STATEMENT); }
    707c:	0f 2e       	mov	r0, r31
    707e:	f3 e0       	ldi	r31, 0x03	; 3
    7080:	ff 2e       	mov	r15, r31
    7082:	f0 2d       	mov	r31, r0
    7084:	24 c0       	rjmp	.+72     	; 0x70ce <system_execute_line+0x3b8>
          if (line[char_counter+2] != 0) { return(STATUS_INVALID_STATEMENT); }                        
    7086:	0f 2e       	mov	r0, r31
    7088:	f3 e0       	ldi	r31, 0x03	; 3
    708a:	ff 2e       	mov	r15, r31
    708c:	f0 2d       	mov	r31, r0
    708e:	1f c0       	rjmp	.+62     	; 0x70ce <system_execute_line+0x3b8>
          switch (line[++char_counter]) {
            case '$': settings_restore(SETTINGS_RESTORE_DEFAULTS); break;
            case '#': settings_restore(SETTINGS_RESTORE_PARAMETERS); break;
            case '*': settings_restore(SETTINGS_RESTORE_ALL); break;
            default: return(STATUS_INVALID_STATEMENT);
    7090:	0f 2e       	mov	r0, r31
    7092:	f3 e0       	ldi	r31, 0x03	; 3
    7094:	ff 2e       	mov	r15, r31
    7096:	f0 2d       	mov	r31, r0
    7098:	1a c0       	rjmp	.+52     	; 0x70ce <system_execute_line+0x3b8>
                report_startup_line(helper_var,line);
              }
            }
            break;
          } else { // Store startup line [IDLE Only] Prevents motion during ALARM.
            if (sys.state != STATE_IDLE) { return(STATUS_IDLE_ERROR); } // Store only when idle.
    709a:	68 94       	set
    709c:	ff 24       	eor	r15, r15
    709e:	f3 f8       	bld	r15, 3
    70a0:	16 c0       	rjmp	.+44     	; 0x70ce <system_execute_line+0x3b8>
            helper_var = true;  // Set helper_var to flag storing method. 
            // No break. Continues into default: to read remaining command characters.
          }
        default :  // Storing setting methods [IDLE/ALARM]
          if(!read_float(line, &char_counter, &parameter)) { return(STATUS_BAD_NUMBER_FORMAT); }
    70a2:	68 94       	set
    70a4:	ff 24       	eor	r15, r15
    70a6:	f1 f8       	bld	r15, 1
    70a8:	12 c0       	rjmp	.+36     	; 0x70ce <system_execute_line+0x3b8>
          if(line[char_counter++] != '=') { return(STATUS_INVALID_STATEMENT); }
    70aa:	0f 2e       	mov	r0, r31
    70ac:	f3 e0       	ldi	r31, 0x03	; 3
    70ae:	ff 2e       	mov	r15, r31
    70b0:	f0 2d       	mov	r31, r0
    70b2:	0d c0       	rjmp	.+26     	; 0x70ce <system_execute_line+0x3b8>
            else { 
              helper_var = trunc(parameter); // Set helper_var to int value of parameter
              settings_store_startup_line(helper_var,line);
            }
          } else { // Store global setting.
            if(!read_float(line, &char_counter, &value)) { return(STATUS_BAD_NUMBER_FORMAT); }
    70b4:	68 94       	set
    70b6:	ff 24       	eor	r15, r15
    70b8:	f1 f8       	bld	r15, 1
    70ba:	09 c0       	rjmp	.+18     	; 0x70ce <system_execute_line+0x3b8>
            if((line[char_counter] != 0) || (parameter > 255)) { return(STATUS_INVALID_STATEMENT); }
    70bc:	0f 2e       	mov	r0, r31
    70be:	f3 e0       	ldi	r31, 0x03	; 3
    70c0:	ff 2e       	mov	r15, r31
    70c2:	f0 2d       	mov	r31, r0
    70c4:	04 c0       	rjmp	.+8      	; 0x70ce <system_execute_line+0x3b8>
    70c6:	0f 2e       	mov	r0, r31
    70c8:	f3 e0       	ldi	r31, 0x03	; 3
    70ca:	ff 2e       	mov	r15, r31
    70cc:	f0 2d       	mov	r31, r0
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }    
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    70ce:	8f 2d       	mov	r24, r15
    70d0:	29 96       	adiw	r28, 0x09	; 9
    70d2:	0f b6       	in	r0, 0x3f	; 63
    70d4:	f8 94       	cli
    70d6:	de bf       	out	0x3e, r29	; 62
    70d8:	0f be       	out	0x3f, r0	; 63
    70da:	cd bf       	out	0x3d, r28	; 61
    70dc:	df 91       	pop	r29
    70de:	cf 91       	pop	r28
    70e0:	1f 91       	pop	r17
    70e2:	0f 91       	pop	r16
    70e4:	ff 90       	pop	r15
    70e6:	ef 90       	pop	r14
    70e8:	df 90       	pop	r13
    70ea:	cf 90       	pop	r12
    70ec:	bf 90       	pop	r11
    70ee:	af 90       	pop	r10
    70f0:	9f 90       	pop	r9
    70f2:	8f 90       	pop	r8
    70f4:	08 95       	ret

000070f6 <system_convert_axis_steps_to_mpos>:

// Returns machine position of axis 'idx'. Must be sent a 'step' array.
// NOTE: If motor steps and machine position are not in the same coordinate frame, this function
//   serves as a central place to compute the transformation.
float system_convert_axis_steps_to_mpos(int32_t *steps, uint8_t idx)
{
    70f6:	cf 93       	push	r28
    70f8:	df 93       	push	r29
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    70fa:	c6 2f       	mov	r28, r22
    70fc:	d0 e0       	ldi	r29, 0x00	; 0
    70fe:	cc 0f       	add	r28, r28
    7100:	dd 1f       	adc	r29, r29
    7102:	cc 0f       	add	r28, r28
    7104:	dd 1f       	adc	r29, r29
    7106:	8c 0f       	add	r24, r28
    7108:	9d 1f       	adc	r25, r29
  #endif
  return(pos);
    710a:	fc 01       	movw	r30, r24
    710c:	60 81       	ld	r22, Z
    710e:	71 81       	ldd	r23, Z+1	; 0x01
    7110:	82 81       	ldd	r24, Z+2	; 0x02
    7112:	93 81       	ldd	r25, Z+3	; 0x03
    7114:	0e 94 5f 3b 	call	0x76be	; 0x76be <__floatsisf>
      pos = (float)system_convert_corexy_to_y_axis_steps(steps) / settings.steps_per_mm[B_MOTOR];
    } else {
      pos = steps[idx]/settings.steps_per_mm[idx];
    }
  #else
    pos = steps[idx]/settings.steps_per_mm[idx];
    7118:	cd 51       	subi	r28, 0x1D	; 29
    711a:	d9 4f       	sbci	r29, 0xF9	; 249
  #endif
  return(pos);
    711c:	28 81       	ld	r18, Y
    711e:	39 81       	ldd	r19, Y+1	; 0x01
    7120:	4a 81       	ldd	r20, Y+2	; 0x02
    7122:	5b 81       	ldd	r21, Y+3	; 0x03
    7124:	0e 94 b5 3a 	call	0x756a	; 0x756a <__divsf3>
}
    7128:	df 91       	pop	r29
    712a:	cf 91       	pop	r28
    712c:	08 95       	ret

0000712e <system_convert_array_steps_to_mpos>:


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
    712e:	ef 92       	push	r14
    7130:	ff 92       	push	r15
    7132:	0f 93       	push	r16
    7134:	1f 93       	push	r17
    7136:	cf 93       	push	r28
    7138:	7b 01       	movw	r14, r22
    713a:	8c 01       	movw	r16, r24
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    713c:	c0 e0       	ldi	r28, 0x00	; 0
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
    713e:	6c 2f       	mov	r22, r28
    7140:	c7 01       	movw	r24, r14
    7142:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <system_convert_axis_steps_to_mpos>
    7146:	f8 01       	movw	r30, r16
    7148:	61 93       	st	Z+, r22
    714a:	71 93       	st	Z+, r23
    714c:	81 93       	st	Z+, r24
    714e:	91 93       	st	Z+, r25
    7150:	8f 01       	movw	r16, r30


void system_convert_array_steps_to_mpos(float *position, int32_t *steps)
{
  uint8_t idx;
  for (idx=0; idx<N_AXIS; idx++) {
    7152:	cf 5f       	subi	r28, 0xFF	; 255
    7154:	c3 30       	cpi	r28, 0x03	; 3
    7156:	99 f7       	brne	.-26     	; 0x713e <system_convert_array_steps_to_mpos+0x10>
    position[idx] = system_convert_axis_steps_to_mpos(steps, idx);
  }
  return;
}
    7158:	cf 91       	pop	r28
    715a:	1f 91       	pop	r17
    715c:	0f 91       	pop	r16
    715e:	ff 90       	pop	r15
    7160:	ef 90       	pop	r14
    7162:	08 95       	ret

00007164 <Uart_Init>:
	}
	else
	{
		return 0;
	}
}
    7164:	af 92       	push	r10
    7166:	bf 92       	push	r11
    7168:	cf 92       	push	r12
    716a:	df 92       	push	r13
    716c:	ef 92       	push	r14
    716e:	ff 92       	push	r15
    7170:	0f 93       	push	r16
    7172:	1f 93       	push	r17
    7174:	cf 93       	push	r28
    7176:	df 93       	push	r29
    7178:	dc 01       	movw	r26, r24
    717a:	11 96       	adiw	r26, 0x01	; 1
    717c:	8c 91       	ld	r24, X
    717e:	11 97       	sbiw	r26, 0x01	; 1
    7180:	81 30       	cpi	r24, 0x01	; 1
    7182:	31 f4       	brne	.+12     	; 0x7190 <Uart_Init+0x2c>
    7184:	e1 ec       	ldi	r30, 0xC1	; 193
    7186:	f0 e0       	ldi	r31, 0x00	; 0
    7188:	80 81       	ld	r24, Z
    718a:	88 61       	ori	r24, 0x18	; 24
    718c:	80 83       	st	Z, r24
    718e:	05 c0       	rjmp	.+10     	; 0x719a <Uart_Init+0x36>
    7190:	e1 ec       	ldi	r30, 0xC1	; 193
    7192:	f0 e0       	ldi	r31, 0x00	; 0
    7194:	80 81       	ld	r24, Z
    7196:	87 7e       	andi	r24, 0xE7	; 231
    7198:	80 83       	st	Z, r24
    719a:	16 96       	adiw	r26, 0x06	; 6
    719c:	8c 91       	ld	r24, X
    719e:	16 97       	sbiw	r26, 0x06	; 6
    71a0:	81 11       	cpse	r24, r1
    71a2:	0f c0       	rjmp	.+30     	; 0x71c2 <Uart_Init+0x5e>
    71a4:	e2 ec       	ldi	r30, 0xC2	; 194
    71a6:	f0 e0       	ldi	r31, 0x00	; 0
    71a8:	80 81       	ld	r24, Z
    71aa:	8c 7f       	andi	r24, 0xFC	; 252
    71ac:	80 83       	st	Z, r24
    71ae:	21 ec       	ldi	r18, 0xC1	; 193
    71b0:	30 e0       	ldi	r19, 0x00	; 0
    71b2:	e9 01       	movw	r28, r18
    71b4:	88 81       	ld	r24, Y
    71b6:	8b 7f       	andi	r24, 0xFB	; 251
    71b8:	88 83       	st	Y, r24
    71ba:	80 81       	ld	r24, Z
    71bc:	83 60       	ori	r24, 0x03	; 3
    71be:	80 83       	st	Z, r24
    71c0:	0c c0       	rjmp	.+24     	; 0x71da <Uart_Init+0x76>
    71c2:	81 30       	cpi	r24, 0x01	; 1
    71c4:	51 f4       	brne	.+20     	; 0x71da <Uart_Init+0x76>
    71c6:	e2 ec       	ldi	r30, 0xC2	; 194
    71c8:	f0 e0       	ldi	r31, 0x00	; 0
    71ca:	80 81       	ld	r24, Z
    71cc:	83 60       	ori	r24, 0x03	; 3
    71ce:	80 83       	st	Z, r24
    71d0:	e1 ec       	ldi	r30, 0xC1	; 193
    71d2:	f0 e0       	ldi	r31, 0x00	; 0
    71d4:	80 81       	ld	r24, Z
    71d6:	84 60       	ori	r24, 0x04	; 4
    71d8:	80 83       	st	Z, r24
    71da:	19 96       	adiw	r26, 0x09	; 9
    71dc:	8c 91       	ld	r24, X
    71de:	19 97       	sbiw	r26, 0x09	; 9
    71e0:	81 30       	cpi	r24, 0x01	; 1
    71e2:	19 f4       	brne	.+6      	; 0x71ea <Uart_Init+0x86>
    71e4:	8f b7       	in	r24, 0x3f	; 63
    71e6:	80 68       	ori	r24, 0x80	; 128
    71e8:	8f bf       	out	0x3f, r24	; 63
    71ea:	e0 e0       	ldi	r30, 0x00	; 0
    71ec:	f1 e0       	ldi	r31, 0x01	; 1
    71ee:	40 e0       	ldi	r20, 0x00	; 0
    71f0:	50 e0       	ldi	r21, 0x00	; 0
    71f2:	ba 01       	movw	r22, r20
    71f4:	00 81       	ld	r16, Z
    71f6:	11 81       	ldd	r17, Z+1	; 0x01
    71f8:	22 81       	ldd	r18, Z+2	; 0x02
    71fa:	33 81       	ldd	r19, Z+3	; 0x03
    71fc:	01 15       	cp	r16, r1
    71fe:	14 42       	sbci	r17, 0x24	; 36
    7200:	24 4f       	sbci	r18, 0xF4	; 244
    7202:	31 05       	cpc	r19, r1
    7204:	09 f0       	breq	.+2      	; 0x7208 <Uart_Init+0xa4>
    7206:	68 c0       	rjmp	.+208    	; 0x72d8 <Uart_Init+0x174>
    7208:	04 81       	ldd	r16, Z+4	; 0x04
    720a:	15 81       	ldd	r17, Z+5	; 0x05
    720c:	26 81       	ldd	r18, Z+6	; 0x06
    720e:	37 81       	ldd	r19, Z+7	; 0x07
    7210:	12 96       	adiw	r26, 0x02	; 2
    7212:	cd 90       	ld	r12, X+
    7214:	dd 90       	ld	r13, X+
    7216:	ed 90       	ld	r14, X+
    7218:	fc 90       	ld	r15, X
    721a:	15 97       	sbiw	r26, 0x05	; 5
    721c:	c0 16       	cp	r12, r16
    721e:	d1 06       	cpc	r13, r17
    7220:	e2 06       	cpc	r14, r18
    7222:	f3 06       	cpc	r15, r19
    7224:	09 f0       	breq	.+2      	; 0x7228 <Uart_Init+0xc4>
    7226:	58 c0       	rjmp	.+176    	; 0x72d8 <Uart_Init+0x174>
    7228:	fa 01       	movw	r30, r20
    722a:	ee 0f       	add	r30, r30
    722c:	ff 1f       	adc	r31, r31
    722e:	66 0f       	add	r22, r22
    7230:	77 1f       	adc	r23, r23
    7232:	66 0f       	add	r22, r22
    7234:	77 1f       	adc	r23, r23
    7236:	66 0f       	add	r22, r22
    7238:	77 1f       	adc	r23, r23
    723a:	e6 0f       	add	r30, r22
    723c:	f7 1f       	adc	r31, r23
    723e:	e0 50       	subi	r30, 0x00	; 0
    7240:	ff 4f       	sbci	r31, 0xFF	; 255
    7242:	81 85       	ldd	r24, Z+9	; 0x09
    7244:	81 30       	cpi	r24, 0x01	; 1
    7246:	09 f5       	brne	.+66     	; 0x728a <Uart_Init+0x126>
    7248:	a9 01       	movw	r20, r18
    724a:	98 01       	movw	r18, r16
    724c:	22 0f       	add	r18, r18
    724e:	33 1f       	adc	r19, r19
    7250:	44 1f       	adc	r20, r20
    7252:	55 1f       	adc	r21, r21
    7254:	22 0f       	add	r18, r18
    7256:	33 1f       	adc	r19, r19
    7258:	44 1f       	adc	r20, r20
    725a:	55 1f       	adc	r21, r21
    725c:	60 e0       	ldi	r22, 0x00	; 0
    725e:	74 e2       	ldi	r23, 0x24	; 36
    7260:	84 ef       	ldi	r24, 0xF4	; 244
    7262:	90 e0       	ldi	r25, 0x00	; 0
    7264:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__udivmodsi4>
    7268:	da 01       	movw	r26, r20
    726a:	c9 01       	movw	r24, r18
    726c:	01 97       	sbiw	r24, 0x01	; 1
    726e:	a1 09       	sbc	r26, r1
    7270:	b1 09       	sbc	r27, r1
    7272:	b6 95       	lsr	r27
    7274:	a7 95       	ror	r26
    7276:	97 95       	ror	r25
    7278:	87 95       	ror	r24
    727a:	b8 2e       	mov	r11, r24
    727c:	a9 2e       	mov	r10, r25
    727e:	e0 ec       	ldi	r30, 0xC0	; 192
    7280:	f0 e0       	ldi	r31, 0x00	; 0
    7282:	80 81       	ld	r24, Z
    7284:	82 60       	ori	r24, 0x02	; 2
    7286:	80 83       	st	Z, r24
    7288:	2e c0       	rjmp	.+92     	; 0x72e6 <Uart_Init+0x182>
    728a:	d9 01       	movw	r26, r18
    728c:	c8 01       	movw	r24, r16
    728e:	88 0f       	add	r24, r24
    7290:	99 1f       	adc	r25, r25
    7292:	aa 1f       	adc	r26, r26
    7294:	bb 1f       	adc	r27, r27
    7296:	88 0f       	add	r24, r24
    7298:	99 1f       	adc	r25, r25
    729a:	aa 1f       	adc	r26, r26
    729c:	bb 1f       	adc	r27, r27
    729e:	9c 01       	movw	r18, r24
    72a0:	ad 01       	movw	r20, r26
    72a2:	22 0f       	add	r18, r18
    72a4:	33 1f       	adc	r19, r19
    72a6:	44 1f       	adc	r20, r20
    72a8:	55 1f       	adc	r21, r21
    72aa:	60 e0       	ldi	r22, 0x00	; 0
    72ac:	74 e2       	ldi	r23, 0x24	; 36
    72ae:	84 ef       	ldi	r24, 0xF4	; 244
    72b0:	90 e0       	ldi	r25, 0x00	; 0
    72b2:	0e 94 22 3e 	call	0x7c44	; 0x7c44 <__udivmodsi4>
    72b6:	da 01       	movw	r26, r20
    72b8:	c9 01       	movw	r24, r18
    72ba:	01 97       	sbiw	r24, 0x01	; 1
    72bc:	a1 09       	sbc	r26, r1
    72be:	b1 09       	sbc	r27, r1
    72c0:	b6 95       	lsr	r27
    72c2:	a7 95       	ror	r26
    72c4:	97 95       	ror	r25
    72c6:	87 95       	ror	r24
    72c8:	b8 2e       	mov	r11, r24
    72ca:	a9 2e       	mov	r10, r25
    72cc:	e0 ec       	ldi	r30, 0xC0	; 192
    72ce:	f0 e0       	ldi	r31, 0x00	; 0
    72d0:	80 81       	ld	r24, Z
    72d2:	8d 7f       	andi	r24, 0xFD	; 253
    72d4:	80 83       	st	Z, r24
    72d6:	07 c0       	rjmp	.+14     	; 0x72e6 <Uart_Init+0x182>
    72d8:	4f 5f       	subi	r20, 0xFF	; 255
    72da:	5f 4f       	sbci	r21, 0xFF	; 255
    72dc:	3a 96       	adiw	r30, 0x0a	; 10
    72de:	49 30       	cpi	r20, 0x09	; 9
    72e0:	51 05       	cpc	r21, r1
    72e2:	09 f0       	breq	.+2      	; 0x72e6 <Uart_Init+0x182>
    72e4:	86 cf       	rjmp	.-244    	; 0x71f2 <Uart_Init+0x8e>
    72e6:	a0 92 c5 00 	sts	0x00C5, r10	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    72ea:	b0 92 c4 00 	sts	0x00C4, r11	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
    72ee:	df 91       	pop	r29
    72f0:	cf 91       	pop	r28
    72f2:	1f 91       	pop	r17
    72f4:	0f 91       	pop	r16
    72f6:	ff 90       	pop	r15
    72f8:	ef 90       	pop	r14
    72fa:	df 90       	pop	r13
    72fc:	cf 90       	pop	r12
    72fe:	bf 90       	pop	r11
    7300:	af 90       	pop	r10
    7302:	08 95       	ret

00007304 <Uart_interruptTrigger>:

void Uart_interruptTrigger(UartChannel_t Channel, Uart_interrupt Trigger)
{
	uint8_t number = Channel % NUM_UART_CHANNELS;
	
	if(Trigger == RECEIVE)
    7304:	61 30       	cpi	r22, 0x01	; 1
    7306:	31 f4       	brne	.+12     	; 0x7314 <Uart_interruptTrigger+0x10>
	{
		*uartctlstat2[number] |= (REGBIT7);
    7308:	e1 ec       	ldi	r30, 0xC1	; 193
    730a:	f0 e0       	ldi	r31, 0x00	; 0
    730c:	80 81       	ld	r24, Z
    730e:	80 68       	ori	r24, 0x80	; 128
    7310:	80 83       	st	Z, r24
    7312:	08 95       	ret
	}
	else if(Trigger == TRANSMIT)
    7314:	61 11       	cpse	r22, r1
    7316:	06 c0       	rjmp	.+12     	; 0x7324 <Uart_interruptTrigger+0x20>
	{
		*uartctlstat2[number] |= (REGBIT6);
    7318:	e1 ec       	ldi	r30, 0xC1	; 193
    731a:	f0 e0       	ldi	r31, 0x00	; 0
    731c:	80 81       	ld	r24, Z
    731e:	80 64       	ori	r24, 0x40	; 64
    7320:	80 83       	st	Z, r24
    7322:	08 95       	ret
	}
	else if(Trigger == DATA_EMPTY)
    7324:	62 30       	cpi	r22, 0x02	; 2
    7326:	29 f4       	brne	.+10     	; 0x7332 <Uart_interruptTrigger+0x2e>
	{
		*uartctlstat2[number] |= (REGBIT5);
    7328:	e1 ec       	ldi	r30, 0xC1	; 193
    732a:	f0 e0       	ldi	r31, 0x00	; 0
    732c:	80 81       	ld	r24, Z
    732e:	80 62       	ori	r24, 0x20	; 32
    7330:	80 83       	st	Z, r24
    7332:	08 95       	ret

00007334 <Uart_interruptClear>:

void Uart_interruptClear(UartChannel_t Channel, Uart_interrupt Trigger)
{
	uint8_t number = Channel % NUM_UART_CHANNELS;
	
	if(Trigger == RECEIVE)
    7334:	61 30       	cpi	r22, 0x01	; 1
    7336:	31 f4       	brne	.+12     	; 0x7344 <Uart_interruptClear+0x10>
	{
		*uartctlstat2[number] &= ~(REGBIT7);
    7338:	e1 ec       	ldi	r30, 0xC1	; 193
    733a:	f0 e0       	ldi	r31, 0x00	; 0
    733c:	80 81       	ld	r24, Z
    733e:	8f 77       	andi	r24, 0x7F	; 127
    7340:	80 83       	st	Z, r24
    7342:	08 95       	ret
	}
	else if(Trigger == TRANSMIT)
    7344:	61 11       	cpse	r22, r1
    7346:	06 c0       	rjmp	.+12     	; 0x7354 <Uart_interruptClear+0x20>
	{
		*uartctlstat2[number] &= ~(REGBIT6);
    7348:	e1 ec       	ldi	r30, 0xC1	; 193
    734a:	f0 e0       	ldi	r31, 0x00	; 0
    734c:	80 81       	ld	r24, Z
    734e:	8f 7b       	andi	r24, 0xBF	; 191
    7350:	80 83       	st	Z, r24
    7352:	08 95       	ret
	}
	else if(Trigger == DATA_EMPTY)
    7354:	62 30       	cpi	r22, 0x02	; 2
    7356:	29 f4       	brne	.+10     	; 0x7362 <Uart_interruptClear+0x2e>
	{
		*uartctlstat2[number] &= ~(REGBIT5);
    7358:	e1 ec       	ldi	r30, 0xC1	; 193
    735a:	f0 e0       	ldi	r31, 0x00	; 0
    735c:	80 81       	ld	r24, Z
    735e:	8f 7d       	andi	r24, 0xDF	; 223
    7360:	80 83       	st	Z, r24
    7362:	08 95       	ret

00007364 <Uart_ConfigGet>:
};

UartConfig_t const * const Uart_ConfigGet(void)
{
	return UartConfig;
}
    7364:	8a e5       	ldi	r24, 0x5A	; 90
    7366:	91 e0       	ldi	r25, 0x01	; 1
    7368:	08 95       	ret

0000736a <__subsf3>:
    736a:	50 58       	subi	r21, 0x80	; 128

0000736c <__addsf3>:
    736c:	bb 27       	eor	r27, r27
    736e:	aa 27       	eor	r26, r26
    7370:	0e 94 cd 39 	call	0x739a	; 0x739a <__addsf3x>
    7374:	0c 94 67 3c 	jmp	0x78ce	; 0x78ce <__fp_round>
    7378:	0e 94 2e 3c 	call	0x785c	; 0x785c <__fp_pscA>
    737c:	38 f0       	brcs	.+14     	; 0x738c <__addsf3+0x20>
    737e:	0e 94 35 3c 	call	0x786a	; 0x786a <__fp_pscB>
    7382:	20 f0       	brcs	.+8      	; 0x738c <__addsf3+0x20>
    7384:	39 f4       	brne	.+14     	; 0x7394 <__addsf3+0x28>
    7386:	9f 3f       	cpi	r25, 0xFF	; 255
    7388:	19 f4       	brne	.+6      	; 0x7390 <__addsf3+0x24>
    738a:	26 f4       	brtc	.+8      	; 0x7394 <__addsf3+0x28>
    738c:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>
    7390:	0e f4       	brtc	.+2      	; 0x7394 <__addsf3+0x28>
    7392:	e0 95       	com	r30
    7394:	e7 fb       	bst	r30, 7
    7396:	0c 94 d5 3b 	jmp	0x77aa	; 0x77aa <__fp_inf>

0000739a <__addsf3x>:
    739a:	e9 2f       	mov	r30, r25
    739c:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__fp_split3>
    73a0:	58 f3       	brcs	.-42     	; 0x7378 <__addsf3+0xc>
    73a2:	ba 17       	cp	r27, r26
    73a4:	62 07       	cpc	r22, r18
    73a6:	73 07       	cpc	r23, r19
    73a8:	84 07       	cpc	r24, r20
    73aa:	95 07       	cpc	r25, r21
    73ac:	20 f0       	brcs	.+8      	; 0x73b6 <__addsf3x+0x1c>
    73ae:	79 f4       	brne	.+30     	; 0x73ce <__addsf3x+0x34>
    73b0:	a6 f5       	brtc	.+104    	; 0x741a <__addsf3x+0x80>
    73b2:	0c 94 c6 3c 	jmp	0x798c	; 0x798c <__fp_zero>
    73b6:	0e f4       	brtc	.+2      	; 0x73ba <__addsf3x+0x20>
    73b8:	e0 95       	com	r30
    73ba:	0b 2e       	mov	r0, r27
    73bc:	ba 2f       	mov	r27, r26
    73be:	a0 2d       	mov	r26, r0
    73c0:	0b 01       	movw	r0, r22
    73c2:	b9 01       	movw	r22, r18
    73c4:	90 01       	movw	r18, r0
    73c6:	0c 01       	movw	r0, r24
    73c8:	ca 01       	movw	r24, r20
    73ca:	a0 01       	movw	r20, r0
    73cc:	11 24       	eor	r1, r1
    73ce:	ff 27       	eor	r31, r31
    73d0:	59 1b       	sub	r21, r25
    73d2:	99 f0       	breq	.+38     	; 0x73fa <__addsf3x+0x60>
    73d4:	59 3f       	cpi	r21, 0xF9	; 249
    73d6:	50 f4       	brcc	.+20     	; 0x73ec <__addsf3x+0x52>
    73d8:	50 3e       	cpi	r21, 0xE0	; 224
    73da:	68 f1       	brcs	.+90     	; 0x7436 <__addsf3x+0x9c>
    73dc:	1a 16       	cp	r1, r26
    73de:	f0 40       	sbci	r31, 0x00	; 0
    73e0:	a2 2f       	mov	r26, r18
    73e2:	23 2f       	mov	r18, r19
    73e4:	34 2f       	mov	r19, r20
    73e6:	44 27       	eor	r20, r20
    73e8:	58 5f       	subi	r21, 0xF8	; 248
    73ea:	f3 cf       	rjmp	.-26     	; 0x73d2 <__addsf3x+0x38>
    73ec:	46 95       	lsr	r20
    73ee:	37 95       	ror	r19
    73f0:	27 95       	ror	r18
    73f2:	a7 95       	ror	r26
    73f4:	f0 40       	sbci	r31, 0x00	; 0
    73f6:	53 95       	inc	r21
    73f8:	c9 f7       	brne	.-14     	; 0x73ec <__addsf3x+0x52>
    73fa:	7e f4       	brtc	.+30     	; 0x741a <__addsf3x+0x80>
    73fc:	1f 16       	cp	r1, r31
    73fe:	ba 0b       	sbc	r27, r26
    7400:	62 0b       	sbc	r22, r18
    7402:	73 0b       	sbc	r23, r19
    7404:	84 0b       	sbc	r24, r20
    7406:	ba f0       	brmi	.+46     	; 0x7436 <__addsf3x+0x9c>
    7408:	91 50       	subi	r25, 0x01	; 1
    740a:	a1 f0       	breq	.+40     	; 0x7434 <__addsf3x+0x9a>
    740c:	ff 0f       	add	r31, r31
    740e:	bb 1f       	adc	r27, r27
    7410:	66 1f       	adc	r22, r22
    7412:	77 1f       	adc	r23, r23
    7414:	88 1f       	adc	r24, r24
    7416:	c2 f7       	brpl	.-16     	; 0x7408 <__addsf3x+0x6e>
    7418:	0e c0       	rjmp	.+28     	; 0x7436 <__addsf3x+0x9c>
    741a:	ba 0f       	add	r27, r26
    741c:	62 1f       	adc	r22, r18
    741e:	73 1f       	adc	r23, r19
    7420:	84 1f       	adc	r24, r20
    7422:	48 f4       	brcc	.+18     	; 0x7436 <__addsf3x+0x9c>
    7424:	87 95       	ror	r24
    7426:	77 95       	ror	r23
    7428:	67 95       	ror	r22
    742a:	b7 95       	ror	r27
    742c:	f7 95       	ror	r31
    742e:	9e 3f       	cpi	r25, 0xFE	; 254
    7430:	08 f0       	brcs	.+2      	; 0x7434 <__addsf3x+0x9a>
    7432:	b0 cf       	rjmp	.-160    	; 0x7394 <__addsf3+0x28>
    7434:	93 95       	inc	r25
    7436:	88 0f       	add	r24, r24
    7438:	08 f0       	brcs	.+2      	; 0x743c <__addsf3x+0xa2>
    743a:	99 27       	eor	r25, r25
    743c:	ee 0f       	add	r30, r30
    743e:	97 95       	ror	r25
    7440:	87 95       	ror	r24
    7442:	08 95       	ret
    7444:	0e 94 2e 3c 	call	0x785c	; 0x785c <__fp_pscA>
    7448:	60 f0       	brcs	.+24     	; 0x7462 <__addsf3x+0xc8>
    744a:	80 e8       	ldi	r24, 0x80	; 128
    744c:	91 e0       	ldi	r25, 0x01	; 1
    744e:	09 f4       	brne	.+2      	; 0x7452 <__addsf3x+0xb8>
    7450:	9e ef       	ldi	r25, 0xFE	; 254
    7452:	0e 94 35 3c 	call	0x786a	; 0x786a <__fp_pscB>
    7456:	28 f0       	brcs	.+10     	; 0x7462 <__addsf3x+0xc8>
    7458:	40 e8       	ldi	r20, 0x80	; 128
    745a:	51 e0       	ldi	r21, 0x01	; 1
    745c:	71 f4       	brne	.+28     	; 0x747a <atan2+0x10>
    745e:	5e ef       	ldi	r21, 0xFE	; 254
    7460:	0c c0       	rjmp	.+24     	; 0x747a <atan2+0x10>
    7462:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>
    7466:	0c 94 c6 3c 	jmp	0x798c	; 0x798c <__fp_zero>

0000746a <atan2>:
    746a:	e9 2f       	mov	r30, r25
    746c:	e0 78       	andi	r30, 0x80	; 128
    746e:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__fp_split3>
    7472:	40 f3       	brcs	.-48     	; 0x7444 <__addsf3x+0xaa>
    7474:	09 2e       	mov	r0, r25
    7476:	05 2a       	or	r0, r21
    7478:	b1 f3       	breq	.-20     	; 0x7466 <__addsf3x+0xcc>
    747a:	26 17       	cp	r18, r22
    747c:	37 07       	cpc	r19, r23
    747e:	48 07       	cpc	r20, r24
    7480:	59 07       	cpc	r21, r25
    7482:	38 f0       	brcs	.+14     	; 0x7492 <atan2+0x28>
    7484:	0e 2e       	mov	r0, r30
    7486:	07 f8       	bld	r0, 7
    7488:	e0 25       	eor	r30, r0
    748a:	69 f0       	breq	.+26     	; 0x74a6 <atan2+0x3c>
    748c:	e0 25       	eor	r30, r0
    748e:	e0 64       	ori	r30, 0x40	; 64
    7490:	0a c0       	rjmp	.+20     	; 0x74a6 <atan2+0x3c>
    7492:	ef 63       	ori	r30, 0x3F	; 63
    7494:	07 f8       	bld	r0, 7
    7496:	00 94       	com	r0
    7498:	07 fa       	bst	r0, 7
    749a:	db 01       	movw	r26, r22
    749c:	b9 01       	movw	r22, r18
    749e:	9d 01       	movw	r18, r26
    74a0:	dc 01       	movw	r26, r24
    74a2:	ca 01       	movw	r24, r20
    74a4:	ad 01       	movw	r20, r26
    74a6:	ef 93       	push	r30
    74a8:	0e 94 cc 3a 	call	0x7598	; 0x7598 <__divsf3_pse>
    74ac:	0e 94 67 3c 	call	0x78ce	; 0x78ce <__fp_round>
    74b0:	0e 94 65 3a 	call	0x74ca	; 0x74ca <atan>
    74b4:	5f 91       	pop	r21
    74b6:	55 23       	and	r21, r21
    74b8:	39 f0       	breq	.+14     	; 0x74c8 <atan2+0x5e>
    74ba:	2b ed       	ldi	r18, 0xDB	; 219
    74bc:	3f e0       	ldi	r19, 0x0F	; 15
    74be:	49 e4       	ldi	r20, 0x49	; 73
    74c0:	50 fd       	sbrc	r21, 0
    74c2:	49 ec       	ldi	r20, 0xC9	; 201
    74c4:	0c 94 b6 39 	jmp	0x736c	; 0x736c <__addsf3>
    74c8:	08 95       	ret

000074ca <atan>:
    74ca:	df 93       	push	r29
    74cc:	dd 27       	eor	r29, r29
    74ce:	b9 2f       	mov	r27, r25
    74d0:	bf 77       	andi	r27, 0x7F	; 127
    74d2:	40 e8       	ldi	r20, 0x80	; 128
    74d4:	5f e3       	ldi	r21, 0x3F	; 63
    74d6:	16 16       	cp	r1, r22
    74d8:	17 06       	cpc	r1, r23
    74da:	48 07       	cpc	r20, r24
    74dc:	5b 07       	cpc	r21, r27
    74de:	18 f4       	brcc	.+6      	; 0x74e6 <atan+0x1c>
    74e0:	d9 2f       	mov	r29, r25
    74e2:	0e 94 d2 3c 	call	0x79a4	; 0x79a4 <inverse>
    74e6:	9f 93       	push	r25
    74e8:	8f 93       	push	r24
    74ea:	7f 93       	push	r23
    74ec:	6f 93       	push	r22
    74ee:	0e 94 ec 3d 	call	0x7bd8	; 0x7bd8 <square>
    74f2:	e4 ea       	ldi	r30, 0xA4	; 164
    74f4:	f2 e0       	ldi	r31, 0x02	; 2
    74f6:	0e 94 07 3c 	call	0x780e	; 0x780e <__fp_powser>
    74fa:	0e 94 67 3c 	call	0x78ce	; 0x78ce <__fp_round>
    74fe:	2f 91       	pop	r18
    7500:	3f 91       	pop	r19
    7502:	4f 91       	pop	r20
    7504:	5f 91       	pop	r21
    7506:	0e 94 20 3d 	call	0x7a40	; 0x7a40 <__mulsf3x>
    750a:	dd 23       	and	r29, r29
    750c:	51 f0       	breq	.+20     	; 0x7522 <atan+0x58>
    750e:	90 58       	subi	r25, 0x80	; 128
    7510:	a2 ea       	ldi	r26, 0xA2	; 162
    7512:	2a ed       	ldi	r18, 0xDA	; 218
    7514:	3f e0       	ldi	r19, 0x0F	; 15
    7516:	49 ec       	ldi	r20, 0xC9	; 201
    7518:	5f e3       	ldi	r21, 0x3F	; 63
    751a:	d0 78       	andi	r29, 0x80	; 128
    751c:	5d 27       	eor	r21, r29
    751e:	0e 94 cd 39 	call	0x739a	; 0x739a <__addsf3x>
    7522:	df 91       	pop	r29
    7524:	0c 94 67 3c 	jmp	0x78ce	; 0x78ce <__fp_round>

00007528 <ceil>:
    7528:	0e 94 ae 3c 	call	0x795c	; 0x795c <__fp_trunc>
    752c:	90 f0       	brcs	.+36     	; 0x7552 <ceil+0x2a>
    752e:	9f 37       	cpi	r25, 0x7F	; 127
    7530:	48 f4       	brcc	.+18     	; 0x7544 <ceil+0x1c>
    7532:	91 11       	cpse	r25, r1
    7534:	16 f4       	brtc	.+4      	; 0x753a <ceil+0x12>
    7536:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    753a:	60 e0       	ldi	r22, 0x00	; 0
    753c:	70 e0       	ldi	r23, 0x00	; 0
    753e:	80 e8       	ldi	r24, 0x80	; 128
    7540:	9f e3       	ldi	r25, 0x3F	; 63
    7542:	08 95       	ret
    7544:	26 f0       	brts	.+8      	; 0x754e <ceil+0x26>
    7546:	1b 16       	cp	r1, r27
    7548:	61 1d       	adc	r22, r1
    754a:	71 1d       	adc	r23, r1
    754c:	81 1d       	adc	r24, r1
    754e:	0c 94 db 3b 	jmp	0x77b6	; 0x77b6 <__fp_mintl>
    7552:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__fp_mpack>

00007556 <__cmpsf2>:
    7556:	0e 94 b1 3b 	call	0x7762	; 0x7762 <__fp_cmp>
    755a:	08 f4       	brcc	.+2      	; 0x755e <__cmpsf2+0x8>
    755c:	81 e0       	ldi	r24, 0x01	; 1
    755e:	08 95       	ret

00007560 <cos>:
    7560:	0e 94 3e 3c 	call	0x787c	; 0x787c <__fp_rempio2>
    7564:	e3 95       	inc	r30
    7566:	0c 94 78 3c 	jmp	0x78f0	; 0x78f0 <__fp_sinus>

0000756a <__divsf3>:
    756a:	0e 94 c9 3a 	call	0x7592	; 0x7592 <__divsf3x>
    756e:	0c 94 67 3c 	jmp	0x78ce	; 0x78ce <__fp_round>
    7572:	0e 94 35 3c 	call	0x786a	; 0x786a <__fp_pscB>
    7576:	58 f0       	brcs	.+22     	; 0x758e <__divsf3+0x24>
    7578:	0e 94 2e 3c 	call	0x785c	; 0x785c <__fp_pscA>
    757c:	40 f0       	brcs	.+16     	; 0x758e <__divsf3+0x24>
    757e:	29 f4       	brne	.+10     	; 0x758a <__divsf3+0x20>
    7580:	5f 3f       	cpi	r21, 0xFF	; 255
    7582:	29 f0       	breq	.+10     	; 0x758e <__divsf3+0x24>
    7584:	0c 94 d5 3b 	jmp	0x77aa	; 0x77aa <__fp_inf>
    7588:	51 11       	cpse	r21, r1
    758a:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    758e:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>

00007592 <__divsf3x>:
    7592:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__fp_split3>
    7596:	68 f3       	brcs	.-38     	; 0x7572 <__divsf3+0x8>

00007598 <__divsf3_pse>:
    7598:	99 23       	and	r25, r25
    759a:	b1 f3       	breq	.-20     	; 0x7588 <__divsf3+0x1e>
    759c:	55 23       	and	r21, r21
    759e:	91 f3       	breq	.-28     	; 0x7584 <__divsf3+0x1a>
    75a0:	95 1b       	sub	r25, r21
    75a2:	55 0b       	sbc	r21, r21
    75a4:	bb 27       	eor	r27, r27
    75a6:	aa 27       	eor	r26, r26
    75a8:	62 17       	cp	r22, r18
    75aa:	73 07       	cpc	r23, r19
    75ac:	84 07       	cpc	r24, r20
    75ae:	38 f0       	brcs	.+14     	; 0x75be <__divsf3_pse+0x26>
    75b0:	9f 5f       	subi	r25, 0xFF	; 255
    75b2:	5f 4f       	sbci	r21, 0xFF	; 255
    75b4:	22 0f       	add	r18, r18
    75b6:	33 1f       	adc	r19, r19
    75b8:	44 1f       	adc	r20, r20
    75ba:	aa 1f       	adc	r26, r26
    75bc:	a9 f3       	breq	.-22     	; 0x75a8 <__divsf3_pse+0x10>
    75be:	35 d0       	rcall	.+106    	; 0x762a <__divsf3_pse+0x92>
    75c0:	0e 2e       	mov	r0, r30
    75c2:	3a f0       	brmi	.+14     	; 0x75d2 <__divsf3_pse+0x3a>
    75c4:	e0 e8       	ldi	r30, 0x80	; 128
    75c6:	32 d0       	rcall	.+100    	; 0x762c <__divsf3_pse+0x94>
    75c8:	91 50       	subi	r25, 0x01	; 1
    75ca:	50 40       	sbci	r21, 0x00	; 0
    75cc:	e6 95       	lsr	r30
    75ce:	00 1c       	adc	r0, r0
    75d0:	ca f7       	brpl	.-14     	; 0x75c4 <__divsf3_pse+0x2c>
    75d2:	2b d0       	rcall	.+86     	; 0x762a <__divsf3_pse+0x92>
    75d4:	fe 2f       	mov	r31, r30
    75d6:	29 d0       	rcall	.+82     	; 0x762a <__divsf3_pse+0x92>
    75d8:	66 0f       	add	r22, r22
    75da:	77 1f       	adc	r23, r23
    75dc:	88 1f       	adc	r24, r24
    75de:	bb 1f       	adc	r27, r27
    75e0:	26 17       	cp	r18, r22
    75e2:	37 07       	cpc	r19, r23
    75e4:	48 07       	cpc	r20, r24
    75e6:	ab 07       	cpc	r26, r27
    75e8:	b0 e8       	ldi	r27, 0x80	; 128
    75ea:	09 f0       	breq	.+2      	; 0x75ee <__divsf3_pse+0x56>
    75ec:	bb 0b       	sbc	r27, r27
    75ee:	80 2d       	mov	r24, r0
    75f0:	bf 01       	movw	r22, r30
    75f2:	ff 27       	eor	r31, r31
    75f4:	93 58       	subi	r25, 0x83	; 131
    75f6:	5f 4f       	sbci	r21, 0xFF	; 255
    75f8:	3a f0       	brmi	.+14     	; 0x7608 <__divsf3_pse+0x70>
    75fa:	9e 3f       	cpi	r25, 0xFE	; 254
    75fc:	51 05       	cpc	r21, r1
    75fe:	78 f0       	brcs	.+30     	; 0x761e <__divsf3_pse+0x86>
    7600:	0c 94 d5 3b 	jmp	0x77aa	; 0x77aa <__fp_inf>
    7604:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    7608:	5f 3f       	cpi	r21, 0xFF	; 255
    760a:	e4 f3       	brlt	.-8      	; 0x7604 <__divsf3_pse+0x6c>
    760c:	98 3e       	cpi	r25, 0xE8	; 232
    760e:	d4 f3       	brlt	.-12     	; 0x7604 <__divsf3_pse+0x6c>
    7610:	86 95       	lsr	r24
    7612:	77 95       	ror	r23
    7614:	67 95       	ror	r22
    7616:	b7 95       	ror	r27
    7618:	f7 95       	ror	r31
    761a:	9f 5f       	subi	r25, 0xFF	; 255
    761c:	c9 f7       	brne	.-14     	; 0x7610 <__divsf3_pse+0x78>
    761e:	88 0f       	add	r24, r24
    7620:	91 1d       	adc	r25, r1
    7622:	96 95       	lsr	r25
    7624:	87 95       	ror	r24
    7626:	97 f9       	bld	r25, 7
    7628:	08 95       	ret
    762a:	e1 e0       	ldi	r30, 0x01	; 1
    762c:	66 0f       	add	r22, r22
    762e:	77 1f       	adc	r23, r23
    7630:	88 1f       	adc	r24, r24
    7632:	bb 1f       	adc	r27, r27
    7634:	62 17       	cp	r22, r18
    7636:	73 07       	cpc	r23, r19
    7638:	84 07       	cpc	r24, r20
    763a:	ba 07       	cpc	r27, r26
    763c:	20 f0       	brcs	.+8      	; 0x7646 <__divsf3_pse+0xae>
    763e:	62 1b       	sub	r22, r18
    7640:	73 0b       	sbc	r23, r19
    7642:	84 0b       	sbc	r24, r20
    7644:	ba 0b       	sbc	r27, r26
    7646:	ee 1f       	adc	r30, r30
    7648:	88 f7       	brcc	.-30     	; 0x762c <__divsf3_pse+0x94>
    764a:	e0 95       	com	r30
    764c:	08 95       	ret

0000764e <__fixsfsi>:
    764e:	0e 94 2e 3b 	call	0x765c	; 0x765c <__fixunssfsi>
    7652:	68 94       	set
    7654:	b1 11       	cpse	r27, r1
    7656:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    765a:	08 95       	ret

0000765c <__fixunssfsi>:
    765c:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    7660:	88 f0       	brcs	.+34     	; 0x7684 <__fixunssfsi+0x28>
    7662:	9f 57       	subi	r25, 0x7F	; 127
    7664:	98 f0       	brcs	.+38     	; 0x768c <__fixunssfsi+0x30>
    7666:	b9 2f       	mov	r27, r25
    7668:	99 27       	eor	r25, r25
    766a:	b7 51       	subi	r27, 0x17	; 23
    766c:	b0 f0       	brcs	.+44     	; 0x769a <__fixunssfsi+0x3e>
    766e:	e1 f0       	breq	.+56     	; 0x76a8 <__fixunssfsi+0x4c>
    7670:	66 0f       	add	r22, r22
    7672:	77 1f       	adc	r23, r23
    7674:	88 1f       	adc	r24, r24
    7676:	99 1f       	adc	r25, r25
    7678:	1a f0       	brmi	.+6      	; 0x7680 <__fixunssfsi+0x24>
    767a:	ba 95       	dec	r27
    767c:	c9 f7       	brne	.-14     	; 0x7670 <__fixunssfsi+0x14>
    767e:	14 c0       	rjmp	.+40     	; 0x76a8 <__fixunssfsi+0x4c>
    7680:	b1 30       	cpi	r27, 0x01	; 1
    7682:	91 f0       	breq	.+36     	; 0x76a8 <__fixunssfsi+0x4c>
    7684:	0e 94 c6 3c 	call	0x798c	; 0x798c <__fp_zero>
    7688:	b1 e0       	ldi	r27, 0x01	; 1
    768a:	08 95       	ret
    768c:	0c 94 c6 3c 	jmp	0x798c	; 0x798c <__fp_zero>
    7690:	67 2f       	mov	r22, r23
    7692:	78 2f       	mov	r23, r24
    7694:	88 27       	eor	r24, r24
    7696:	b8 5f       	subi	r27, 0xF8	; 248
    7698:	39 f0       	breq	.+14     	; 0x76a8 <__fixunssfsi+0x4c>
    769a:	b9 3f       	cpi	r27, 0xF9	; 249
    769c:	cc f3       	brlt	.-14     	; 0x7690 <__fixunssfsi+0x34>
    769e:	86 95       	lsr	r24
    76a0:	77 95       	ror	r23
    76a2:	67 95       	ror	r22
    76a4:	b3 95       	inc	r27
    76a6:	d9 f7       	brne	.-10     	; 0x769e <__fixunssfsi+0x42>
    76a8:	3e f4       	brtc	.+14     	; 0x76b8 <__fixunssfsi+0x5c>
    76aa:	90 95       	com	r25
    76ac:	80 95       	com	r24
    76ae:	70 95       	com	r23
    76b0:	61 95       	neg	r22
    76b2:	7f 4f       	sbci	r23, 0xFF	; 255
    76b4:	8f 4f       	sbci	r24, 0xFF	; 255
    76b6:	9f 4f       	sbci	r25, 0xFF	; 255
    76b8:	08 95       	ret

000076ba <__floatunsisf>:
    76ba:	e8 94       	clt
    76bc:	09 c0       	rjmp	.+18     	; 0x76d0 <__floatsisf+0x12>

000076be <__floatsisf>:
    76be:	97 fb       	bst	r25, 7
    76c0:	3e f4       	brtc	.+14     	; 0x76d0 <__floatsisf+0x12>
    76c2:	90 95       	com	r25
    76c4:	80 95       	com	r24
    76c6:	70 95       	com	r23
    76c8:	61 95       	neg	r22
    76ca:	7f 4f       	sbci	r23, 0xFF	; 255
    76cc:	8f 4f       	sbci	r24, 0xFF	; 255
    76ce:	9f 4f       	sbci	r25, 0xFF	; 255
    76d0:	99 23       	and	r25, r25
    76d2:	a9 f0       	breq	.+42     	; 0x76fe <__floatsisf+0x40>
    76d4:	f9 2f       	mov	r31, r25
    76d6:	96 e9       	ldi	r25, 0x96	; 150
    76d8:	bb 27       	eor	r27, r27
    76da:	93 95       	inc	r25
    76dc:	f6 95       	lsr	r31
    76de:	87 95       	ror	r24
    76e0:	77 95       	ror	r23
    76e2:	67 95       	ror	r22
    76e4:	b7 95       	ror	r27
    76e6:	f1 11       	cpse	r31, r1
    76e8:	f8 cf       	rjmp	.-16     	; 0x76da <__floatsisf+0x1c>
    76ea:	fa f4       	brpl	.+62     	; 0x772a <__floatsisf+0x6c>
    76ec:	bb 0f       	add	r27, r27
    76ee:	11 f4       	brne	.+4      	; 0x76f4 <__floatsisf+0x36>
    76f0:	60 ff       	sbrs	r22, 0
    76f2:	1b c0       	rjmp	.+54     	; 0x772a <__floatsisf+0x6c>
    76f4:	6f 5f       	subi	r22, 0xFF	; 255
    76f6:	7f 4f       	sbci	r23, 0xFF	; 255
    76f8:	8f 4f       	sbci	r24, 0xFF	; 255
    76fa:	9f 4f       	sbci	r25, 0xFF	; 255
    76fc:	16 c0       	rjmp	.+44     	; 0x772a <__floatsisf+0x6c>
    76fe:	88 23       	and	r24, r24
    7700:	11 f0       	breq	.+4      	; 0x7706 <__floatsisf+0x48>
    7702:	96 e9       	ldi	r25, 0x96	; 150
    7704:	11 c0       	rjmp	.+34     	; 0x7728 <__floatsisf+0x6a>
    7706:	77 23       	and	r23, r23
    7708:	21 f0       	breq	.+8      	; 0x7712 <__floatsisf+0x54>
    770a:	9e e8       	ldi	r25, 0x8E	; 142
    770c:	87 2f       	mov	r24, r23
    770e:	76 2f       	mov	r23, r22
    7710:	05 c0       	rjmp	.+10     	; 0x771c <__floatsisf+0x5e>
    7712:	66 23       	and	r22, r22
    7714:	71 f0       	breq	.+28     	; 0x7732 <__floatsisf+0x74>
    7716:	96 e8       	ldi	r25, 0x86	; 134
    7718:	86 2f       	mov	r24, r22
    771a:	70 e0       	ldi	r23, 0x00	; 0
    771c:	60 e0       	ldi	r22, 0x00	; 0
    771e:	2a f0       	brmi	.+10     	; 0x772a <__floatsisf+0x6c>
    7720:	9a 95       	dec	r25
    7722:	66 0f       	add	r22, r22
    7724:	77 1f       	adc	r23, r23
    7726:	88 1f       	adc	r24, r24
    7728:	da f7       	brpl	.-10     	; 0x7720 <__floatsisf+0x62>
    772a:	88 0f       	add	r24, r24
    772c:	96 95       	lsr	r25
    772e:	87 95       	ror	r24
    7730:	97 f9       	bld	r25, 7
    7732:	08 95       	ret

00007734 <floor>:
    7734:	0e 94 ae 3c 	call	0x795c	; 0x795c <__fp_trunc>
    7738:	90 f0       	brcs	.+36     	; 0x775e <floor+0x2a>
    773a:	9f 37       	cpi	r25, 0x7F	; 127
    773c:	48 f4       	brcc	.+18     	; 0x7750 <floor+0x1c>
    773e:	91 11       	cpse	r25, r1
    7740:	16 f0       	brts	.+4      	; 0x7746 <floor+0x12>
    7742:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    7746:	60 e0       	ldi	r22, 0x00	; 0
    7748:	70 e0       	ldi	r23, 0x00	; 0
    774a:	80 e8       	ldi	r24, 0x80	; 128
    774c:	9f eb       	ldi	r25, 0xBF	; 191
    774e:	08 95       	ret
    7750:	26 f4       	brtc	.+8      	; 0x775a <floor+0x26>
    7752:	1b 16       	cp	r1, r27
    7754:	61 1d       	adc	r22, r1
    7756:	71 1d       	adc	r23, r1
    7758:	81 1d       	adc	r24, r1
    775a:	0c 94 db 3b 	jmp	0x77b6	; 0x77b6 <__fp_mintl>
    775e:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__fp_mpack>

00007762 <__fp_cmp>:
    7762:	99 0f       	add	r25, r25
    7764:	00 08       	sbc	r0, r0
    7766:	55 0f       	add	r21, r21
    7768:	aa 0b       	sbc	r26, r26
    776a:	e0 e8       	ldi	r30, 0x80	; 128
    776c:	fe ef       	ldi	r31, 0xFE	; 254
    776e:	16 16       	cp	r1, r22
    7770:	17 06       	cpc	r1, r23
    7772:	e8 07       	cpc	r30, r24
    7774:	f9 07       	cpc	r31, r25
    7776:	c0 f0       	brcs	.+48     	; 0x77a8 <__fp_cmp+0x46>
    7778:	12 16       	cp	r1, r18
    777a:	13 06       	cpc	r1, r19
    777c:	e4 07       	cpc	r30, r20
    777e:	f5 07       	cpc	r31, r21
    7780:	98 f0       	brcs	.+38     	; 0x77a8 <__fp_cmp+0x46>
    7782:	62 1b       	sub	r22, r18
    7784:	73 0b       	sbc	r23, r19
    7786:	84 0b       	sbc	r24, r20
    7788:	95 0b       	sbc	r25, r21
    778a:	39 f4       	brne	.+14     	; 0x779a <__fp_cmp+0x38>
    778c:	0a 26       	eor	r0, r26
    778e:	61 f0       	breq	.+24     	; 0x77a8 <__fp_cmp+0x46>
    7790:	23 2b       	or	r18, r19
    7792:	24 2b       	or	r18, r20
    7794:	25 2b       	or	r18, r21
    7796:	21 f4       	brne	.+8      	; 0x77a0 <__fp_cmp+0x3e>
    7798:	08 95       	ret
    779a:	0a 26       	eor	r0, r26
    779c:	09 f4       	brne	.+2      	; 0x77a0 <__fp_cmp+0x3e>
    779e:	a1 40       	sbci	r26, 0x01	; 1
    77a0:	a6 95       	lsr	r26
    77a2:	8f ef       	ldi	r24, 0xFF	; 255
    77a4:	81 1d       	adc	r24, r1
    77a6:	81 1d       	adc	r24, r1
    77a8:	08 95       	ret

000077aa <__fp_inf>:
    77aa:	97 f9       	bld	r25, 7
    77ac:	9f 67       	ori	r25, 0x7F	; 127
    77ae:	80 e8       	ldi	r24, 0x80	; 128
    77b0:	70 e0       	ldi	r23, 0x00	; 0
    77b2:	60 e0       	ldi	r22, 0x00	; 0
    77b4:	08 95       	ret

000077b6 <__fp_mintl>:
    77b6:	88 23       	and	r24, r24
    77b8:	71 f4       	brne	.+28     	; 0x77d6 <__fp_mintl+0x20>
    77ba:	77 23       	and	r23, r23
    77bc:	21 f0       	breq	.+8      	; 0x77c6 <__fp_mintl+0x10>
    77be:	98 50       	subi	r25, 0x08	; 8
    77c0:	87 2b       	or	r24, r23
    77c2:	76 2f       	mov	r23, r22
    77c4:	07 c0       	rjmp	.+14     	; 0x77d4 <__fp_mintl+0x1e>
    77c6:	66 23       	and	r22, r22
    77c8:	11 f4       	brne	.+4      	; 0x77ce <__fp_mintl+0x18>
    77ca:	99 27       	eor	r25, r25
    77cc:	0d c0       	rjmp	.+26     	; 0x77e8 <__fp_mintl+0x32>
    77ce:	90 51       	subi	r25, 0x10	; 16
    77d0:	86 2b       	or	r24, r22
    77d2:	70 e0       	ldi	r23, 0x00	; 0
    77d4:	60 e0       	ldi	r22, 0x00	; 0
    77d6:	2a f0       	brmi	.+10     	; 0x77e2 <__fp_mintl+0x2c>
    77d8:	9a 95       	dec	r25
    77da:	66 0f       	add	r22, r22
    77dc:	77 1f       	adc	r23, r23
    77de:	88 1f       	adc	r24, r24
    77e0:	da f7       	brpl	.-10     	; 0x77d8 <__fp_mintl+0x22>
    77e2:	88 0f       	add	r24, r24
    77e4:	96 95       	lsr	r25
    77e6:	87 95       	ror	r24
    77e8:	97 f9       	bld	r25, 7
    77ea:	08 95       	ret

000077ec <__fp_mpack>:
    77ec:	9f 3f       	cpi	r25, 0xFF	; 255
    77ee:	31 f0       	breq	.+12     	; 0x77fc <__fp_mpack_finite+0xc>

000077f0 <__fp_mpack_finite>:
    77f0:	91 50       	subi	r25, 0x01	; 1
    77f2:	20 f4       	brcc	.+8      	; 0x77fc <__fp_mpack_finite+0xc>
    77f4:	87 95       	ror	r24
    77f6:	77 95       	ror	r23
    77f8:	67 95       	ror	r22
    77fa:	b7 95       	ror	r27
    77fc:	88 0f       	add	r24, r24
    77fe:	91 1d       	adc	r25, r1
    7800:	96 95       	lsr	r25
    7802:	87 95       	ror	r24
    7804:	97 f9       	bld	r25, 7
    7806:	08 95       	ret

00007808 <__fp_nan>:
    7808:	9f ef       	ldi	r25, 0xFF	; 255
    780a:	80 ec       	ldi	r24, 0xC0	; 192
    780c:	08 95       	ret

0000780e <__fp_powser>:
    780e:	df 93       	push	r29
    7810:	cf 93       	push	r28
    7812:	1f 93       	push	r17
    7814:	0f 93       	push	r16
    7816:	ff 92       	push	r15
    7818:	ef 92       	push	r14
    781a:	df 92       	push	r13
    781c:	7b 01       	movw	r14, r22
    781e:	8c 01       	movw	r16, r24
    7820:	68 94       	set
    7822:	06 c0       	rjmp	.+12     	; 0x7830 <__fp_powser+0x22>
    7824:	da 2e       	mov	r13, r26
    7826:	ef 01       	movw	r28, r30
    7828:	0e 94 20 3d 	call	0x7a40	; 0x7a40 <__mulsf3x>
    782c:	fe 01       	movw	r30, r28
    782e:	e8 94       	clt
    7830:	a5 91       	lpm	r26, Z+
    7832:	25 91       	lpm	r18, Z+
    7834:	35 91       	lpm	r19, Z+
    7836:	45 91       	lpm	r20, Z+
    7838:	55 91       	lpm	r21, Z+
    783a:	a6 f3       	brts	.-24     	; 0x7824 <__fp_powser+0x16>
    783c:	ef 01       	movw	r28, r30
    783e:	0e 94 cd 39 	call	0x739a	; 0x739a <__addsf3x>
    7842:	fe 01       	movw	r30, r28
    7844:	97 01       	movw	r18, r14
    7846:	a8 01       	movw	r20, r16
    7848:	da 94       	dec	r13
    784a:	69 f7       	brne	.-38     	; 0x7826 <__fp_powser+0x18>
    784c:	df 90       	pop	r13
    784e:	ef 90       	pop	r14
    7850:	ff 90       	pop	r15
    7852:	0f 91       	pop	r16
    7854:	1f 91       	pop	r17
    7856:	cf 91       	pop	r28
    7858:	df 91       	pop	r29
    785a:	08 95       	ret

0000785c <__fp_pscA>:
    785c:	00 24       	eor	r0, r0
    785e:	0a 94       	dec	r0
    7860:	16 16       	cp	r1, r22
    7862:	17 06       	cpc	r1, r23
    7864:	18 06       	cpc	r1, r24
    7866:	09 06       	cpc	r0, r25
    7868:	08 95       	ret

0000786a <__fp_pscB>:
    786a:	00 24       	eor	r0, r0
    786c:	0a 94       	dec	r0
    786e:	12 16       	cp	r1, r18
    7870:	13 06       	cpc	r1, r19
    7872:	14 06       	cpc	r1, r20
    7874:	05 06       	cpc	r0, r21
    7876:	08 95       	ret
    7878:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>

0000787c <__fp_rempio2>:
    787c:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    7880:	d8 f3       	brcs	.-10     	; 0x7878 <__fp_pscB+0xe>
    7882:	e8 94       	clt
    7884:	e0 e0       	ldi	r30, 0x00	; 0
    7886:	bb 27       	eor	r27, r27
    7888:	9f 57       	subi	r25, 0x7F	; 127
    788a:	f0 f0       	brcs	.+60     	; 0x78c8 <__fp_rempio2+0x4c>
    788c:	2a ed       	ldi	r18, 0xDA	; 218
    788e:	3f e0       	ldi	r19, 0x0F	; 15
    7890:	49 ec       	ldi	r20, 0xC9	; 201
    7892:	06 c0       	rjmp	.+12     	; 0x78a0 <__fp_rempio2+0x24>
    7894:	ee 0f       	add	r30, r30
    7896:	bb 0f       	add	r27, r27
    7898:	66 1f       	adc	r22, r22
    789a:	77 1f       	adc	r23, r23
    789c:	88 1f       	adc	r24, r24
    789e:	28 f0       	brcs	.+10     	; 0x78aa <__fp_rempio2+0x2e>
    78a0:	b2 3a       	cpi	r27, 0xA2	; 162
    78a2:	62 07       	cpc	r22, r18
    78a4:	73 07       	cpc	r23, r19
    78a6:	84 07       	cpc	r24, r20
    78a8:	28 f0       	brcs	.+10     	; 0x78b4 <__fp_rempio2+0x38>
    78aa:	b2 5a       	subi	r27, 0xA2	; 162
    78ac:	62 0b       	sbc	r22, r18
    78ae:	73 0b       	sbc	r23, r19
    78b0:	84 0b       	sbc	r24, r20
    78b2:	e3 95       	inc	r30
    78b4:	9a 95       	dec	r25
    78b6:	72 f7       	brpl	.-36     	; 0x7894 <__fp_rempio2+0x18>
    78b8:	80 38       	cpi	r24, 0x80	; 128
    78ba:	30 f4       	brcc	.+12     	; 0x78c8 <__fp_rempio2+0x4c>
    78bc:	9a 95       	dec	r25
    78be:	bb 0f       	add	r27, r27
    78c0:	66 1f       	adc	r22, r22
    78c2:	77 1f       	adc	r23, r23
    78c4:	88 1f       	adc	r24, r24
    78c6:	d2 f7       	brpl	.-12     	; 0x78bc <__fp_rempio2+0x40>
    78c8:	90 48       	sbci	r25, 0x80	; 128
    78ca:	0c 94 f8 3b 	jmp	0x77f0	; 0x77f0 <__fp_mpack_finite>

000078ce <__fp_round>:
    78ce:	09 2e       	mov	r0, r25
    78d0:	03 94       	inc	r0
    78d2:	00 0c       	add	r0, r0
    78d4:	11 f4       	brne	.+4      	; 0x78da <__fp_round+0xc>
    78d6:	88 23       	and	r24, r24
    78d8:	52 f0       	brmi	.+20     	; 0x78ee <__fp_round+0x20>
    78da:	bb 0f       	add	r27, r27
    78dc:	40 f4       	brcc	.+16     	; 0x78ee <__fp_round+0x20>
    78de:	bf 2b       	or	r27, r31
    78e0:	11 f4       	brne	.+4      	; 0x78e6 <__fp_round+0x18>
    78e2:	60 ff       	sbrs	r22, 0
    78e4:	04 c0       	rjmp	.+8      	; 0x78ee <__fp_round+0x20>
    78e6:	6f 5f       	subi	r22, 0xFF	; 255
    78e8:	7f 4f       	sbci	r23, 0xFF	; 255
    78ea:	8f 4f       	sbci	r24, 0xFF	; 255
    78ec:	9f 4f       	sbci	r25, 0xFF	; 255
    78ee:	08 95       	ret

000078f0 <__fp_sinus>:
    78f0:	ef 93       	push	r30
    78f2:	e0 ff       	sbrs	r30, 0
    78f4:	07 c0       	rjmp	.+14     	; 0x7904 <__fp_sinus+0x14>
    78f6:	a2 ea       	ldi	r26, 0xA2	; 162
    78f8:	2a ed       	ldi	r18, 0xDA	; 218
    78fa:	3f e0       	ldi	r19, 0x0F	; 15
    78fc:	49 ec       	ldi	r20, 0xC9	; 201
    78fe:	5f eb       	ldi	r21, 0xBF	; 191
    7900:	0e 94 cd 39 	call	0x739a	; 0x739a <__addsf3x>
    7904:	0e 94 67 3c 	call	0x78ce	; 0x78ce <__fp_round>
    7908:	0f 90       	pop	r0
    790a:	03 94       	inc	r0
    790c:	01 fc       	sbrc	r0, 1
    790e:	90 58       	subi	r25, 0x80	; 128
    7910:	e1 ed       	ldi	r30, 0xD1	; 209
    7912:	f2 e0       	ldi	r31, 0x02	; 2
    7914:	0c 94 02 3e 	jmp	0x7c04	; 0x7c04 <__fp_powsodd>

00007918 <__fp_split3>:
    7918:	57 fd       	sbrc	r21, 7
    791a:	90 58       	subi	r25, 0x80	; 128
    791c:	44 0f       	add	r20, r20
    791e:	55 1f       	adc	r21, r21
    7920:	59 f0       	breq	.+22     	; 0x7938 <__fp_splitA+0x10>
    7922:	5f 3f       	cpi	r21, 0xFF	; 255
    7924:	71 f0       	breq	.+28     	; 0x7942 <__fp_splitA+0x1a>
    7926:	47 95       	ror	r20

00007928 <__fp_splitA>:
    7928:	88 0f       	add	r24, r24
    792a:	97 fb       	bst	r25, 7
    792c:	99 1f       	adc	r25, r25
    792e:	61 f0       	breq	.+24     	; 0x7948 <__fp_splitA+0x20>
    7930:	9f 3f       	cpi	r25, 0xFF	; 255
    7932:	79 f0       	breq	.+30     	; 0x7952 <__fp_splitA+0x2a>
    7934:	87 95       	ror	r24
    7936:	08 95       	ret
    7938:	12 16       	cp	r1, r18
    793a:	13 06       	cpc	r1, r19
    793c:	14 06       	cpc	r1, r20
    793e:	55 1f       	adc	r21, r21
    7940:	f2 cf       	rjmp	.-28     	; 0x7926 <__fp_split3+0xe>
    7942:	46 95       	lsr	r20
    7944:	f1 df       	rcall	.-30     	; 0x7928 <__fp_splitA>
    7946:	08 c0       	rjmp	.+16     	; 0x7958 <__fp_splitA+0x30>
    7948:	16 16       	cp	r1, r22
    794a:	17 06       	cpc	r1, r23
    794c:	18 06       	cpc	r1, r24
    794e:	99 1f       	adc	r25, r25
    7950:	f1 cf       	rjmp	.-30     	; 0x7934 <__fp_splitA+0xc>
    7952:	86 95       	lsr	r24
    7954:	71 05       	cpc	r23, r1
    7956:	61 05       	cpc	r22, r1
    7958:	08 94       	sec
    795a:	08 95       	ret

0000795c <__fp_trunc>:
    795c:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    7960:	a0 f0       	brcs	.+40     	; 0x798a <__fp_trunc+0x2e>
    7962:	be e7       	ldi	r27, 0x7E	; 126
    7964:	b9 17       	cp	r27, r25
    7966:	88 f4       	brcc	.+34     	; 0x798a <__fp_trunc+0x2e>
    7968:	bb 27       	eor	r27, r27
    796a:	9f 38       	cpi	r25, 0x8F	; 143
    796c:	60 f4       	brcc	.+24     	; 0x7986 <__fp_trunc+0x2a>
    796e:	16 16       	cp	r1, r22
    7970:	b1 1d       	adc	r27, r1
    7972:	67 2f       	mov	r22, r23
    7974:	78 2f       	mov	r23, r24
    7976:	88 27       	eor	r24, r24
    7978:	98 5f       	subi	r25, 0xF8	; 248
    797a:	f7 cf       	rjmp	.-18     	; 0x796a <__fp_trunc+0xe>
    797c:	86 95       	lsr	r24
    797e:	77 95       	ror	r23
    7980:	67 95       	ror	r22
    7982:	b1 1d       	adc	r27, r1
    7984:	93 95       	inc	r25
    7986:	96 39       	cpi	r25, 0x96	; 150
    7988:	c8 f3       	brcs	.-14     	; 0x797c <__fp_trunc+0x20>
    798a:	08 95       	ret

0000798c <__fp_zero>:
    798c:	e8 94       	clt

0000798e <__fp_szero>:
    798e:	bb 27       	eor	r27, r27
    7990:	66 27       	eor	r22, r22
    7992:	77 27       	eor	r23, r23
    7994:	cb 01       	movw	r24, r22
    7996:	97 f9       	bld	r25, 7
    7998:	08 95       	ret

0000799a <__gesf2>:
    799a:	0e 94 b1 3b 	call	0x7762	; 0x7762 <__fp_cmp>
    799e:	08 f4       	brcc	.+2      	; 0x79a2 <__gesf2+0x8>
    79a0:	8f ef       	ldi	r24, 0xFF	; 255
    79a2:	08 95       	ret

000079a4 <inverse>:
    79a4:	9b 01       	movw	r18, r22
    79a6:	ac 01       	movw	r20, r24
    79a8:	60 e0       	ldi	r22, 0x00	; 0
    79aa:	70 e0       	ldi	r23, 0x00	; 0
    79ac:	80 e8       	ldi	r24, 0x80	; 128
    79ae:	9f e3       	ldi	r25, 0x3F	; 63
    79b0:	0c 94 b5 3a 	jmp	0x756a	; 0x756a <__divsf3>

000079b4 <lround>:
    79b4:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    79b8:	58 f1       	brcs	.+86     	; 0x7a10 <lround+0x5c>
    79ba:	9e 57       	subi	r25, 0x7E	; 126
    79bc:	60 f1       	brcs	.+88     	; 0x7a16 <lround+0x62>
    79be:	98 51       	subi	r25, 0x18	; 24
    79c0:	a0 f0       	brcs	.+40     	; 0x79ea <lround+0x36>
    79c2:	e9 f0       	breq	.+58     	; 0x79fe <lround+0x4a>
    79c4:	98 30       	cpi	r25, 0x08	; 8
    79c6:	20 f5       	brcc	.+72     	; 0x7a10 <lround+0x5c>
    79c8:	09 2e       	mov	r0, r25
    79ca:	99 27       	eor	r25, r25
    79cc:	66 0f       	add	r22, r22
    79ce:	77 1f       	adc	r23, r23
    79d0:	88 1f       	adc	r24, r24
    79d2:	99 1f       	adc	r25, r25
    79d4:	0a 94       	dec	r0
    79d6:	d1 f7       	brne	.-12     	; 0x79cc <lround+0x18>
    79d8:	12 c0       	rjmp	.+36     	; 0x79fe <lround+0x4a>
    79da:	06 2e       	mov	r0, r22
    79dc:	67 2f       	mov	r22, r23
    79de:	78 2f       	mov	r23, r24
    79e0:	88 27       	eor	r24, r24
    79e2:	98 5f       	subi	r25, 0xF8	; 248
    79e4:	11 f4       	brne	.+4      	; 0x79ea <lround+0x36>
    79e6:	00 0c       	add	r0, r0
    79e8:	07 c0       	rjmp	.+14     	; 0x79f8 <lround+0x44>
    79ea:	99 3f       	cpi	r25, 0xF9	; 249
    79ec:	b4 f3       	brlt	.-20     	; 0x79da <lround+0x26>
    79ee:	86 95       	lsr	r24
    79f0:	77 95       	ror	r23
    79f2:	67 95       	ror	r22
    79f4:	93 95       	inc	r25
    79f6:	d9 f7       	brne	.-10     	; 0x79ee <lround+0x3a>
    79f8:	61 1d       	adc	r22, r1
    79fa:	71 1d       	adc	r23, r1
    79fc:	81 1d       	adc	r24, r1
    79fe:	3e f4       	brtc	.+14     	; 0x7a0e <lround+0x5a>
    7a00:	90 95       	com	r25
    7a02:	80 95       	com	r24
    7a04:	70 95       	com	r23
    7a06:	61 95       	neg	r22
    7a08:	7f 4f       	sbci	r23, 0xFF	; 255
    7a0a:	8f 4f       	sbci	r24, 0xFF	; 255
    7a0c:	9f 4f       	sbci	r25, 0xFF	; 255
    7a0e:	08 95       	ret
    7a10:	68 94       	set
    7a12:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    7a16:	0c 94 c6 3c 	jmp	0x798c	; 0x798c <__fp_zero>

00007a1a <__mulsf3>:
    7a1a:	0e 94 20 3d 	call	0x7a40	; 0x7a40 <__mulsf3x>
    7a1e:	0c 94 67 3c 	jmp	0x78ce	; 0x78ce <__fp_round>
    7a22:	0e 94 2e 3c 	call	0x785c	; 0x785c <__fp_pscA>
    7a26:	38 f0       	brcs	.+14     	; 0x7a36 <__mulsf3+0x1c>
    7a28:	0e 94 35 3c 	call	0x786a	; 0x786a <__fp_pscB>
    7a2c:	20 f0       	brcs	.+8      	; 0x7a36 <__mulsf3+0x1c>
    7a2e:	95 23       	and	r25, r21
    7a30:	11 f0       	breq	.+4      	; 0x7a36 <__mulsf3+0x1c>
    7a32:	0c 94 d5 3b 	jmp	0x77aa	; 0x77aa <__fp_inf>
    7a36:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>
    7a3a:	11 24       	eor	r1, r1
    7a3c:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>

00007a40 <__mulsf3x>:
    7a40:	0e 94 8c 3c 	call	0x7918	; 0x7918 <__fp_split3>
    7a44:	70 f3       	brcs	.-36     	; 0x7a22 <__mulsf3+0x8>

00007a46 <__mulsf3_pse>:
    7a46:	95 9f       	mul	r25, r21
    7a48:	c1 f3       	breq	.-16     	; 0x7a3a <__mulsf3+0x20>
    7a4a:	95 0f       	add	r25, r21
    7a4c:	50 e0       	ldi	r21, 0x00	; 0
    7a4e:	55 1f       	adc	r21, r21
    7a50:	62 9f       	mul	r22, r18
    7a52:	f0 01       	movw	r30, r0
    7a54:	72 9f       	mul	r23, r18
    7a56:	bb 27       	eor	r27, r27
    7a58:	f0 0d       	add	r31, r0
    7a5a:	b1 1d       	adc	r27, r1
    7a5c:	63 9f       	mul	r22, r19
    7a5e:	aa 27       	eor	r26, r26
    7a60:	f0 0d       	add	r31, r0
    7a62:	b1 1d       	adc	r27, r1
    7a64:	aa 1f       	adc	r26, r26
    7a66:	64 9f       	mul	r22, r20
    7a68:	66 27       	eor	r22, r22
    7a6a:	b0 0d       	add	r27, r0
    7a6c:	a1 1d       	adc	r26, r1
    7a6e:	66 1f       	adc	r22, r22
    7a70:	82 9f       	mul	r24, r18
    7a72:	22 27       	eor	r18, r18
    7a74:	b0 0d       	add	r27, r0
    7a76:	a1 1d       	adc	r26, r1
    7a78:	62 1f       	adc	r22, r18
    7a7a:	73 9f       	mul	r23, r19
    7a7c:	b0 0d       	add	r27, r0
    7a7e:	a1 1d       	adc	r26, r1
    7a80:	62 1f       	adc	r22, r18
    7a82:	83 9f       	mul	r24, r19
    7a84:	a0 0d       	add	r26, r0
    7a86:	61 1d       	adc	r22, r1
    7a88:	22 1f       	adc	r18, r18
    7a8a:	74 9f       	mul	r23, r20
    7a8c:	33 27       	eor	r19, r19
    7a8e:	a0 0d       	add	r26, r0
    7a90:	61 1d       	adc	r22, r1
    7a92:	23 1f       	adc	r18, r19
    7a94:	84 9f       	mul	r24, r20
    7a96:	60 0d       	add	r22, r0
    7a98:	21 1d       	adc	r18, r1
    7a9a:	82 2f       	mov	r24, r18
    7a9c:	76 2f       	mov	r23, r22
    7a9e:	6a 2f       	mov	r22, r26
    7aa0:	11 24       	eor	r1, r1
    7aa2:	9f 57       	subi	r25, 0x7F	; 127
    7aa4:	50 40       	sbci	r21, 0x00	; 0
    7aa6:	9a f0       	brmi	.+38     	; 0x7ace <__mulsf3_pse+0x88>
    7aa8:	f1 f0       	breq	.+60     	; 0x7ae6 <__mulsf3_pse+0xa0>
    7aaa:	88 23       	and	r24, r24
    7aac:	4a f0       	brmi	.+18     	; 0x7ac0 <__mulsf3_pse+0x7a>
    7aae:	ee 0f       	add	r30, r30
    7ab0:	ff 1f       	adc	r31, r31
    7ab2:	bb 1f       	adc	r27, r27
    7ab4:	66 1f       	adc	r22, r22
    7ab6:	77 1f       	adc	r23, r23
    7ab8:	88 1f       	adc	r24, r24
    7aba:	91 50       	subi	r25, 0x01	; 1
    7abc:	50 40       	sbci	r21, 0x00	; 0
    7abe:	a9 f7       	brne	.-22     	; 0x7aaa <__mulsf3_pse+0x64>
    7ac0:	9e 3f       	cpi	r25, 0xFE	; 254
    7ac2:	51 05       	cpc	r21, r1
    7ac4:	80 f0       	brcs	.+32     	; 0x7ae6 <__mulsf3_pse+0xa0>
    7ac6:	0c 94 d5 3b 	jmp	0x77aa	; 0x77aa <__fp_inf>
    7aca:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    7ace:	5f 3f       	cpi	r21, 0xFF	; 255
    7ad0:	e4 f3       	brlt	.-8      	; 0x7aca <__mulsf3_pse+0x84>
    7ad2:	98 3e       	cpi	r25, 0xE8	; 232
    7ad4:	d4 f3       	brlt	.-12     	; 0x7aca <__mulsf3_pse+0x84>
    7ad6:	86 95       	lsr	r24
    7ad8:	77 95       	ror	r23
    7ada:	67 95       	ror	r22
    7adc:	b7 95       	ror	r27
    7ade:	f7 95       	ror	r31
    7ae0:	e7 95       	ror	r30
    7ae2:	9f 5f       	subi	r25, 0xFF	; 255
    7ae4:	c1 f7       	brne	.-16     	; 0x7ad6 <__mulsf3_pse+0x90>
    7ae6:	fe 2b       	or	r31, r30
    7ae8:	88 0f       	add	r24, r24
    7aea:	91 1d       	adc	r25, r1
    7aec:	96 95       	lsr	r25
    7aee:	87 95       	ror	r24
    7af0:	97 f9       	bld	r25, 7
    7af2:	08 95       	ret

00007af4 <round>:
    7af4:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    7af8:	e8 f0       	brcs	.+58     	; 0x7b34 <round+0x40>
    7afa:	9e 37       	cpi	r25, 0x7E	; 126
    7afc:	e8 f0       	brcs	.+58     	; 0x7b38 <round+0x44>
    7afe:	96 39       	cpi	r25, 0x96	; 150
    7b00:	b8 f4       	brcc	.+46     	; 0x7b30 <round+0x3c>
    7b02:	9e 38       	cpi	r25, 0x8E	; 142
    7b04:	48 f4       	brcc	.+18     	; 0x7b18 <round+0x24>
    7b06:	67 2f       	mov	r22, r23
    7b08:	78 2f       	mov	r23, r24
    7b0a:	88 27       	eor	r24, r24
    7b0c:	98 5f       	subi	r25, 0xF8	; 248
    7b0e:	f9 cf       	rjmp	.-14     	; 0x7b02 <round+0xe>
    7b10:	86 95       	lsr	r24
    7b12:	77 95       	ror	r23
    7b14:	67 95       	ror	r22
    7b16:	93 95       	inc	r25
    7b18:	95 39       	cpi	r25, 0x95	; 149
    7b1a:	d0 f3       	brcs	.-12     	; 0x7b10 <round+0x1c>
    7b1c:	b6 2f       	mov	r27, r22
    7b1e:	b1 70       	andi	r27, 0x01	; 1
    7b20:	6b 0f       	add	r22, r27
    7b22:	71 1d       	adc	r23, r1
    7b24:	81 1d       	adc	r24, r1
    7b26:	20 f4       	brcc	.+8      	; 0x7b30 <round+0x3c>
    7b28:	87 95       	ror	r24
    7b2a:	77 95       	ror	r23
    7b2c:	67 95       	ror	r22
    7b2e:	93 95       	inc	r25
    7b30:	0c 94 db 3b 	jmp	0x77b6	; 0x77b6 <__fp_mintl>
    7b34:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__fp_mpack>
    7b38:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>

00007b3c <sin>:
    7b3c:	9f 93       	push	r25
    7b3e:	0e 94 3e 3c 	call	0x787c	; 0x787c <__fp_rempio2>
    7b42:	0f 90       	pop	r0
    7b44:	07 fc       	sbrc	r0, 7
    7b46:	ee 5f       	subi	r30, 0xFE	; 254
    7b48:	0c 94 78 3c 	jmp	0x78f0	; 0x78f0 <__fp_sinus>
    7b4c:	19 f4       	brne	.+6      	; 0x7b54 <sin+0x18>
    7b4e:	16 f4       	brtc	.+4      	; 0x7b54 <sin+0x18>
    7b50:	0c 94 04 3c 	jmp	0x7808	; 0x7808 <__fp_nan>
    7b54:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__fp_mpack>

00007b58 <sqrt>:
    7b58:	0e 94 94 3c 	call	0x7928	; 0x7928 <__fp_splitA>
    7b5c:	b8 f3       	brcs	.-18     	; 0x7b4c <sin+0x10>
    7b5e:	99 23       	and	r25, r25
    7b60:	c9 f3       	breq	.-14     	; 0x7b54 <sin+0x18>
    7b62:	b6 f3       	brts	.-20     	; 0x7b50 <sin+0x14>
    7b64:	9f 57       	subi	r25, 0x7F	; 127
    7b66:	55 0b       	sbc	r21, r21
    7b68:	87 ff       	sbrs	r24, 7
    7b6a:	0e 94 fb 3d 	call	0x7bf6	; 0x7bf6 <__fp_norm2>
    7b6e:	00 24       	eor	r0, r0
    7b70:	a0 e6       	ldi	r26, 0x60	; 96
    7b72:	40 ea       	ldi	r20, 0xA0	; 160
    7b74:	90 01       	movw	r18, r0
    7b76:	80 58       	subi	r24, 0x80	; 128
    7b78:	56 95       	lsr	r21
    7b7a:	97 95       	ror	r25
    7b7c:	28 f4       	brcc	.+10     	; 0x7b88 <sqrt+0x30>
    7b7e:	80 5c       	subi	r24, 0xC0	; 192
    7b80:	66 0f       	add	r22, r22
    7b82:	77 1f       	adc	r23, r23
    7b84:	88 1f       	adc	r24, r24
    7b86:	20 f0       	brcs	.+8      	; 0x7b90 <sqrt+0x38>
    7b88:	26 17       	cp	r18, r22
    7b8a:	37 07       	cpc	r19, r23
    7b8c:	48 07       	cpc	r20, r24
    7b8e:	30 f4       	brcc	.+12     	; 0x7b9c <sqrt+0x44>
    7b90:	62 1b       	sub	r22, r18
    7b92:	73 0b       	sbc	r23, r19
    7b94:	84 0b       	sbc	r24, r20
    7b96:	20 29       	or	r18, r0
    7b98:	31 29       	or	r19, r1
    7b9a:	4a 2b       	or	r20, r26
    7b9c:	a6 95       	lsr	r26
    7b9e:	17 94       	ror	r1
    7ba0:	07 94       	ror	r0
    7ba2:	20 25       	eor	r18, r0
    7ba4:	31 25       	eor	r19, r1
    7ba6:	4a 27       	eor	r20, r26
    7ba8:	58 f7       	brcc	.-42     	; 0x7b80 <sqrt+0x28>
    7baa:	66 0f       	add	r22, r22
    7bac:	77 1f       	adc	r23, r23
    7bae:	88 1f       	adc	r24, r24
    7bb0:	20 f0       	brcs	.+8      	; 0x7bba <sqrt+0x62>
    7bb2:	26 17       	cp	r18, r22
    7bb4:	37 07       	cpc	r19, r23
    7bb6:	48 07       	cpc	r20, r24
    7bb8:	30 f4       	brcc	.+12     	; 0x7bc6 <sqrt+0x6e>
    7bba:	62 0b       	sbc	r22, r18
    7bbc:	73 0b       	sbc	r23, r19
    7bbe:	84 0b       	sbc	r24, r20
    7bc0:	20 0d       	add	r18, r0
    7bc2:	31 1d       	adc	r19, r1
    7bc4:	41 1d       	adc	r20, r1
    7bc6:	a0 95       	com	r26
    7bc8:	81 f7       	brne	.-32     	; 0x7baa <sqrt+0x52>
    7bca:	b9 01       	movw	r22, r18
    7bcc:	84 2f       	mov	r24, r20
    7bce:	91 58       	subi	r25, 0x81	; 129
    7bd0:	88 0f       	add	r24, r24
    7bd2:	96 95       	lsr	r25
    7bd4:	87 95       	ror	r24
    7bd6:	08 95       	ret

00007bd8 <square>:
    7bd8:	9b 01       	movw	r18, r22
    7bda:	ac 01       	movw	r20, r24
    7bdc:	0c 94 0d 3d 	jmp	0x7a1a	; 0x7a1a <__mulsf3>

00007be0 <trunc>:
    7be0:	0e 94 ae 3c 	call	0x795c	; 0x795c <__fp_trunc>
    7be4:	30 f0       	brcs	.+12     	; 0x7bf2 <trunc+0x12>
    7be6:	9f 37       	cpi	r25, 0x7F	; 127
    7be8:	10 f4       	brcc	.+4      	; 0x7bee <trunc+0xe>
    7bea:	0c 94 c7 3c 	jmp	0x798e	; 0x798e <__fp_szero>
    7bee:	0c 94 db 3b 	jmp	0x77b6	; 0x77b6 <__fp_mintl>
    7bf2:	0c 94 f6 3b 	jmp	0x77ec	; 0x77ec <__fp_mpack>

00007bf6 <__fp_norm2>:
    7bf6:	91 50       	subi	r25, 0x01	; 1
    7bf8:	50 40       	sbci	r21, 0x00	; 0
    7bfa:	66 0f       	add	r22, r22
    7bfc:	77 1f       	adc	r23, r23
    7bfe:	88 1f       	adc	r24, r24
    7c00:	d2 f7       	brpl	.-12     	; 0x7bf6 <__fp_norm2>
    7c02:	08 95       	ret

00007c04 <__fp_powsodd>:
    7c04:	9f 93       	push	r25
    7c06:	8f 93       	push	r24
    7c08:	7f 93       	push	r23
    7c0a:	6f 93       	push	r22
    7c0c:	ff 93       	push	r31
    7c0e:	ef 93       	push	r30
    7c10:	9b 01       	movw	r18, r22
    7c12:	ac 01       	movw	r20, r24
    7c14:	0e 94 0d 3d 	call	0x7a1a	; 0x7a1a <__mulsf3>
    7c18:	ef 91       	pop	r30
    7c1a:	ff 91       	pop	r31
    7c1c:	0e 94 07 3c 	call	0x780e	; 0x780e <__fp_powser>
    7c20:	2f 91       	pop	r18
    7c22:	3f 91       	pop	r19
    7c24:	4f 91       	pop	r20
    7c26:	5f 91       	pop	r21
    7c28:	0c 94 0d 3d 	jmp	0x7a1a	; 0x7a1a <__mulsf3>

00007c2c <__udivmodqi4>:
    7c2c:	99 1b       	sub	r25, r25
    7c2e:	79 e0       	ldi	r23, 0x09	; 9
    7c30:	04 c0       	rjmp	.+8      	; 0x7c3a <__udivmodqi4_ep>

00007c32 <__udivmodqi4_loop>:
    7c32:	99 1f       	adc	r25, r25
    7c34:	96 17       	cp	r25, r22
    7c36:	08 f0       	brcs	.+2      	; 0x7c3a <__udivmodqi4_ep>
    7c38:	96 1b       	sub	r25, r22

00007c3a <__udivmodqi4_ep>:
    7c3a:	88 1f       	adc	r24, r24
    7c3c:	7a 95       	dec	r23
    7c3e:	c9 f7       	brne	.-14     	; 0x7c32 <__udivmodqi4_loop>
    7c40:	80 95       	com	r24
    7c42:	08 95       	ret

00007c44 <__udivmodsi4>:
    7c44:	a1 e2       	ldi	r26, 0x21	; 33
    7c46:	1a 2e       	mov	r1, r26
    7c48:	aa 1b       	sub	r26, r26
    7c4a:	bb 1b       	sub	r27, r27
    7c4c:	fd 01       	movw	r30, r26
    7c4e:	0d c0       	rjmp	.+26     	; 0x7c6a <__udivmodsi4_ep>

00007c50 <__udivmodsi4_loop>:
    7c50:	aa 1f       	adc	r26, r26
    7c52:	bb 1f       	adc	r27, r27
    7c54:	ee 1f       	adc	r30, r30
    7c56:	ff 1f       	adc	r31, r31
    7c58:	a2 17       	cp	r26, r18
    7c5a:	b3 07       	cpc	r27, r19
    7c5c:	e4 07       	cpc	r30, r20
    7c5e:	f5 07       	cpc	r31, r21
    7c60:	20 f0       	brcs	.+8      	; 0x7c6a <__udivmodsi4_ep>
    7c62:	a2 1b       	sub	r26, r18
    7c64:	b3 0b       	sbc	r27, r19
    7c66:	e4 0b       	sbc	r30, r20
    7c68:	f5 0b       	sbc	r31, r21

00007c6a <__udivmodsi4_ep>:
    7c6a:	66 1f       	adc	r22, r22
    7c6c:	77 1f       	adc	r23, r23
    7c6e:	88 1f       	adc	r24, r24
    7c70:	99 1f       	adc	r25, r25
    7c72:	1a 94       	dec	r1
    7c74:	69 f7       	brne	.-38     	; 0x7c50 <__udivmodsi4_loop>
    7c76:	60 95       	com	r22
    7c78:	70 95       	com	r23
    7c7a:	80 95       	com	r24
    7c7c:	90 95       	com	r25
    7c7e:	9b 01       	movw	r18, r22
    7c80:	ac 01       	movw	r20, r24
    7c82:	bd 01       	movw	r22, r26
    7c84:	cf 01       	movw	r24, r30
    7c86:	08 95       	ret

00007c88 <__tablejump2__>:
    7c88:	ee 0f       	add	r30, r30
    7c8a:	ff 1f       	adc	r31, r31
    7c8c:	05 90       	lpm	r0, Z+
    7c8e:	f4 91       	lpm	r31, Z
    7c90:	e0 2d       	mov	r30, r0
    7c92:	09 94       	ijmp

00007c94 <_exit>:
    7c94:	f8 94       	cli

00007c96 <__stop_program>:
    7c96:	ff cf       	rjmp	.-2      	; 0x7c96 <__stop_program>
